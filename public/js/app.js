/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/bootstrap/dist/js/bootstrap.bundle.js":
/*!************************************************************!*\
  !*** ./node_modules/bootstrap/dist/js/bootstrap.bundle.js ***!
  \************************************************************/
/***/ (function(module) {

eval("{/*!\r\n  * Bootstrap v5.3.7 (https://getbootstrap.com/)\r\n  * Copyright 2011-2025 The Bootstrap Authors (https://github.com/twbs/bootstrap/graphs/contributors)\r\n  * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n  */\r\n(function (global, factory) {\r\n   true ? module.exports = factory() :\r\n  0;\r\n})(this, (function () { 'use strict';\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap dom/data.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const elementMap = new Map();\r\n  const Data = {\r\n    set(element, key, instance) {\r\n      if (!elementMap.has(element)) {\r\n        elementMap.set(element, new Map());\r\n      }\r\n      const instanceMap = elementMap.get(element);\r\n\r\n      // make it clear we only want one instance per element\r\n      // can be removed later when multiple key/instances are fine to be used\r\n      if (!instanceMap.has(key) && instanceMap.size !== 0) {\r\n        // eslint-disable-next-line no-console\r\n        console.error(`Bootstrap doesn't allow more than one instance per element. Bound instance: ${Array.from(instanceMap.keys())[0]}.`);\r\n        return;\r\n      }\r\n      instanceMap.set(key, instance);\r\n    },\r\n    get(element, key) {\r\n      if (elementMap.has(element)) {\r\n        return elementMap.get(element).get(key) || null;\r\n      }\r\n      return null;\r\n    },\r\n    remove(element, key) {\r\n      if (!elementMap.has(element)) {\r\n        return;\r\n      }\r\n      const instanceMap = elementMap.get(element);\r\n      instanceMap.delete(key);\r\n\r\n      // free up element references if there are no instances left for an element\r\n      if (instanceMap.size === 0) {\r\n        elementMap.delete(element);\r\n      }\r\n    }\r\n  };\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap util/index.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n  const MAX_UID = 1000000;\r\n  const MILLISECONDS_MULTIPLIER = 1000;\r\n  const TRANSITION_END = 'transitionend';\r\n\r\n  /**\r\n   * Properly escape IDs selectors to handle weird IDs\r\n   * @param {string} selector\r\n   * @returns {string}\r\n   */\r\n  const parseSelector = selector => {\r\n    if (selector && window.CSS && window.CSS.escape) {\r\n      // document.querySelector needs escaping to handle IDs (html5+) containing for instance /\r\n      selector = selector.replace(/#([^\\s\"#']+)/g, (match, id) => `#${CSS.escape(id)}`);\r\n    }\r\n    return selector;\r\n  };\r\n\r\n  // Shout-out Angus Croll (https://goo.gl/pxwQGp)\r\n  const toType = object => {\r\n    if (object === null || object === undefined) {\r\n      return `${object}`;\r\n    }\r\n    return Object.prototype.toString.call(object).match(/\\s([a-z]+)/i)[1].toLowerCase();\r\n  };\r\n\r\n  /**\r\n   * Public Util API\r\n   */\r\n\r\n  const getUID = prefix => {\r\n    do {\r\n      prefix += Math.floor(Math.random() * MAX_UID);\r\n    } while (document.getElementById(prefix));\r\n    return prefix;\r\n  };\r\n  const getTransitionDurationFromElement = element => {\r\n    if (!element) {\r\n      return 0;\r\n    }\r\n\r\n    // Get transition-duration of the element\r\n    let {\r\n      transitionDuration,\r\n      transitionDelay\r\n    } = window.getComputedStyle(element);\r\n    const floatTransitionDuration = Number.parseFloat(transitionDuration);\r\n    const floatTransitionDelay = Number.parseFloat(transitionDelay);\r\n\r\n    // Return 0 if element or transition duration is not found\r\n    if (!floatTransitionDuration && !floatTransitionDelay) {\r\n      return 0;\r\n    }\r\n\r\n    // If multiple durations are defined, take the first\r\n    transitionDuration = transitionDuration.split(',')[0];\r\n    transitionDelay = transitionDelay.split(',')[0];\r\n    return (Number.parseFloat(transitionDuration) + Number.parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;\r\n  };\r\n  const triggerTransitionEnd = element => {\r\n    element.dispatchEvent(new Event(TRANSITION_END));\r\n  };\r\n  const isElement$1 = object => {\r\n    if (!object || typeof object !== 'object') {\r\n      return false;\r\n    }\r\n    if (typeof object.jquery !== 'undefined') {\r\n      object = object[0];\r\n    }\r\n    return typeof object.nodeType !== 'undefined';\r\n  };\r\n  const getElement = object => {\r\n    // it's a jQuery object or a node element\r\n    if (isElement$1(object)) {\r\n      return object.jquery ? object[0] : object;\r\n    }\r\n    if (typeof object === 'string' && object.length > 0) {\r\n      return document.querySelector(parseSelector(object));\r\n    }\r\n    return null;\r\n  };\r\n  const isVisible = element => {\r\n    if (!isElement$1(element) || element.getClientRects().length === 0) {\r\n      return false;\r\n    }\r\n    const elementIsVisible = getComputedStyle(element).getPropertyValue('visibility') === 'visible';\r\n    // Handle `details` element as its content may falsie appear visible when it is closed\r\n    const closedDetails = element.closest('details:not([open])');\r\n    if (!closedDetails) {\r\n      return elementIsVisible;\r\n    }\r\n    if (closedDetails !== element) {\r\n      const summary = element.closest('summary');\r\n      if (summary && summary.parentNode !== closedDetails) {\r\n        return false;\r\n      }\r\n      if (summary === null) {\r\n        return false;\r\n      }\r\n    }\r\n    return elementIsVisible;\r\n  };\r\n  const isDisabled = element => {\r\n    if (!element || element.nodeType !== Node.ELEMENT_NODE) {\r\n      return true;\r\n    }\r\n    if (element.classList.contains('disabled')) {\r\n      return true;\r\n    }\r\n    if (typeof element.disabled !== 'undefined') {\r\n      return element.disabled;\r\n    }\r\n    return element.hasAttribute('disabled') && element.getAttribute('disabled') !== 'false';\r\n  };\r\n  const findShadowRoot = element => {\r\n    if (!document.documentElement.attachShadow) {\r\n      return null;\r\n    }\r\n\r\n    // Can find the shadow root otherwise it'll return the document\r\n    if (typeof element.getRootNode === 'function') {\r\n      const root = element.getRootNode();\r\n      return root instanceof ShadowRoot ? root : null;\r\n    }\r\n    if (element instanceof ShadowRoot) {\r\n      return element;\r\n    }\r\n\r\n    // when we don't find a shadow root\r\n    if (!element.parentNode) {\r\n      return null;\r\n    }\r\n    return findShadowRoot(element.parentNode);\r\n  };\r\n  const noop = () => {};\r\n\r\n  /**\r\n   * Trick to restart an element's animation\r\n   *\r\n   * @param {HTMLElement} element\r\n   * @return void\r\n   *\r\n   * @see https://www.harrytheo.com/blog/2021/02/restart-a-css-animation-with-javascript/#restarting-a-css-animation\r\n   */\r\n  const reflow = element => {\r\n    element.offsetHeight; // eslint-disable-line no-unused-expressions\r\n  };\r\n  const getjQuery = () => {\r\n    if (window.jQuery && !document.body.hasAttribute('data-bs-no-jquery')) {\r\n      return window.jQuery;\r\n    }\r\n    return null;\r\n  };\r\n  const DOMContentLoadedCallbacks = [];\r\n  const onDOMContentLoaded = callback => {\r\n    if (document.readyState === 'loading') {\r\n      // add listener on the first call when the document is in loading state\r\n      if (!DOMContentLoadedCallbacks.length) {\r\n        document.addEventListener('DOMContentLoaded', () => {\r\n          for (const callback of DOMContentLoadedCallbacks) {\r\n            callback();\r\n          }\r\n        });\r\n      }\r\n      DOMContentLoadedCallbacks.push(callback);\r\n    } else {\r\n      callback();\r\n    }\r\n  };\r\n  const isRTL = () => document.documentElement.dir === 'rtl';\r\n  const defineJQueryPlugin = plugin => {\r\n    onDOMContentLoaded(() => {\r\n      const $ = getjQuery();\r\n      /* istanbul ignore if */\r\n      if ($) {\r\n        const name = plugin.NAME;\r\n        const JQUERY_NO_CONFLICT = $.fn[name];\r\n        $.fn[name] = plugin.jQueryInterface;\r\n        $.fn[name].Constructor = plugin;\r\n        $.fn[name].noConflict = () => {\r\n          $.fn[name] = JQUERY_NO_CONFLICT;\r\n          return plugin.jQueryInterface;\r\n        };\r\n      }\r\n    });\r\n  };\r\n  const execute = (possibleCallback, args = [], defaultValue = possibleCallback) => {\r\n    return typeof possibleCallback === 'function' ? possibleCallback.call(...args) : defaultValue;\r\n  };\r\n  const executeAfterTransition = (callback, transitionElement, waitForTransition = true) => {\r\n    if (!waitForTransition) {\r\n      execute(callback);\r\n      return;\r\n    }\r\n    const durationPadding = 5;\r\n    const emulatedDuration = getTransitionDurationFromElement(transitionElement) + durationPadding;\r\n    let called = false;\r\n    const handler = ({\r\n      target\r\n    }) => {\r\n      if (target !== transitionElement) {\r\n        return;\r\n      }\r\n      called = true;\r\n      transitionElement.removeEventListener(TRANSITION_END, handler);\r\n      execute(callback);\r\n    };\r\n    transitionElement.addEventListener(TRANSITION_END, handler);\r\n    setTimeout(() => {\r\n      if (!called) {\r\n        triggerTransitionEnd(transitionElement);\r\n      }\r\n    }, emulatedDuration);\r\n  };\r\n\r\n  /**\r\n   * Return the previous/next element of a list.\r\n   *\r\n   * @param {array} list    The list of elements\r\n   * @param activeElement   The active element\r\n   * @param shouldGetNext   Choose to get next or previous element\r\n   * @param isCycleAllowed\r\n   * @return {Element|elem} The proper element\r\n   */\r\n  const getNextActiveElement = (list, activeElement, shouldGetNext, isCycleAllowed) => {\r\n    const listLength = list.length;\r\n    let index = list.indexOf(activeElement);\r\n\r\n    // if the element does not exist in the list return an element\r\n    // depending on the direction and if cycle is allowed\r\n    if (index === -1) {\r\n      return !shouldGetNext && isCycleAllowed ? list[listLength - 1] : list[0];\r\n    }\r\n    index += shouldGetNext ? 1 : -1;\r\n    if (isCycleAllowed) {\r\n      index = (index + listLength) % listLength;\r\n    }\r\n    return list[Math.max(0, Math.min(index, listLength - 1))];\r\n  };\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap dom/event-handler.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const namespaceRegex = /[^.]*(?=\\..*)\\.|.*/;\r\n  const stripNameRegex = /\\..*/;\r\n  const stripUidRegex = /::\\d+$/;\r\n  const eventRegistry = {}; // Events storage\r\n  let uidEvent = 1;\r\n  const customEvents = {\r\n    mouseenter: 'mouseover',\r\n    mouseleave: 'mouseout'\r\n  };\r\n  const nativeEvents = new Set(['click', 'dblclick', 'mouseup', 'mousedown', 'contextmenu', 'mousewheel', 'DOMMouseScroll', 'mouseover', 'mouseout', 'mousemove', 'selectstart', 'selectend', 'keydown', 'keypress', 'keyup', 'orientationchange', 'touchstart', 'touchmove', 'touchend', 'touchcancel', 'pointerdown', 'pointermove', 'pointerup', 'pointerleave', 'pointercancel', 'gesturestart', 'gesturechange', 'gestureend', 'focus', 'blur', 'change', 'reset', 'select', 'submit', 'focusin', 'focusout', 'load', 'unload', 'beforeunload', 'resize', 'move', 'DOMContentLoaded', 'readystatechange', 'error', 'abort', 'scroll']);\r\n\r\n  /**\r\n   * Private methods\r\n   */\r\n\r\n  function makeEventUid(element, uid) {\r\n    return uid && `${uid}::${uidEvent++}` || element.uidEvent || uidEvent++;\r\n  }\r\n  function getElementEvents(element) {\r\n    const uid = makeEventUid(element);\r\n    element.uidEvent = uid;\r\n    eventRegistry[uid] = eventRegistry[uid] || {};\r\n    return eventRegistry[uid];\r\n  }\r\n  function bootstrapHandler(element, fn) {\r\n    return function handler(event) {\r\n      hydrateObj(event, {\r\n        delegateTarget: element\r\n      });\r\n      if (handler.oneOff) {\r\n        EventHandler.off(element, event.type, fn);\r\n      }\r\n      return fn.apply(element, [event]);\r\n    };\r\n  }\r\n  function bootstrapDelegationHandler(element, selector, fn) {\r\n    return function handler(event) {\r\n      const domElements = element.querySelectorAll(selector);\r\n      for (let {\r\n        target\r\n      } = event; target && target !== this; target = target.parentNode) {\r\n        for (const domElement of domElements) {\r\n          if (domElement !== target) {\r\n            continue;\r\n          }\r\n          hydrateObj(event, {\r\n            delegateTarget: target\r\n          });\r\n          if (handler.oneOff) {\r\n            EventHandler.off(element, event.type, selector, fn);\r\n          }\r\n          return fn.apply(target, [event]);\r\n        }\r\n      }\r\n    };\r\n  }\r\n  function findHandler(events, callable, delegationSelector = null) {\r\n    return Object.values(events).find(event => event.callable === callable && event.delegationSelector === delegationSelector);\r\n  }\r\n  function normalizeParameters(originalTypeEvent, handler, delegationFunction) {\r\n    const isDelegated = typeof handler === 'string';\r\n    // TODO: tooltip passes `false` instead of selector, so we need to check\r\n    const callable = isDelegated ? delegationFunction : handler || delegationFunction;\r\n    let typeEvent = getTypeEvent(originalTypeEvent);\r\n    if (!nativeEvents.has(typeEvent)) {\r\n      typeEvent = originalTypeEvent;\r\n    }\r\n    return [isDelegated, callable, typeEvent];\r\n  }\r\n  function addHandler(element, originalTypeEvent, handler, delegationFunction, oneOff) {\r\n    if (typeof originalTypeEvent !== 'string' || !element) {\r\n      return;\r\n    }\r\n    let [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);\r\n\r\n    // in case of mouseenter or mouseleave wrap the handler within a function that checks for its DOM position\r\n    // this prevents the handler from being dispatched the same way as mouseover or mouseout does\r\n    if (originalTypeEvent in customEvents) {\r\n      const wrapFunction = fn => {\r\n        return function (event) {\r\n          if (!event.relatedTarget || event.relatedTarget !== event.delegateTarget && !event.delegateTarget.contains(event.relatedTarget)) {\r\n            return fn.call(this, event);\r\n          }\r\n        };\r\n      };\r\n      callable = wrapFunction(callable);\r\n    }\r\n    const events = getElementEvents(element);\r\n    const handlers = events[typeEvent] || (events[typeEvent] = {});\r\n    const previousFunction = findHandler(handlers, callable, isDelegated ? handler : null);\r\n    if (previousFunction) {\r\n      previousFunction.oneOff = previousFunction.oneOff && oneOff;\r\n      return;\r\n    }\r\n    const uid = makeEventUid(callable, originalTypeEvent.replace(namespaceRegex, ''));\r\n    const fn = isDelegated ? bootstrapDelegationHandler(element, handler, callable) : bootstrapHandler(element, callable);\r\n    fn.delegationSelector = isDelegated ? handler : null;\r\n    fn.callable = callable;\r\n    fn.oneOff = oneOff;\r\n    fn.uidEvent = uid;\r\n    handlers[uid] = fn;\r\n    element.addEventListener(typeEvent, fn, isDelegated);\r\n  }\r\n  function removeHandler(element, events, typeEvent, handler, delegationSelector) {\r\n    const fn = findHandler(events[typeEvent], handler, delegationSelector);\r\n    if (!fn) {\r\n      return;\r\n    }\r\n    element.removeEventListener(typeEvent, fn, Boolean(delegationSelector));\r\n    delete events[typeEvent][fn.uidEvent];\r\n  }\r\n  function removeNamespacedHandlers(element, events, typeEvent, namespace) {\r\n    const storeElementEvent = events[typeEvent] || {};\r\n    for (const [handlerKey, event] of Object.entries(storeElementEvent)) {\r\n      if (handlerKey.includes(namespace)) {\r\n        removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\r\n      }\r\n    }\r\n  }\r\n  function getTypeEvent(event) {\r\n    // allow to get the native events from namespaced events ('click.bs.button' --> 'click')\r\n    event = event.replace(stripNameRegex, '');\r\n    return customEvents[event] || event;\r\n  }\r\n  const EventHandler = {\r\n    on(element, event, handler, delegationFunction) {\r\n      addHandler(element, event, handler, delegationFunction, false);\r\n    },\r\n    one(element, event, handler, delegationFunction) {\r\n      addHandler(element, event, handler, delegationFunction, true);\r\n    },\r\n    off(element, originalTypeEvent, handler, delegationFunction) {\r\n      if (typeof originalTypeEvent !== 'string' || !element) {\r\n        return;\r\n      }\r\n      const [isDelegated, callable, typeEvent] = normalizeParameters(originalTypeEvent, handler, delegationFunction);\r\n      const inNamespace = typeEvent !== originalTypeEvent;\r\n      const events = getElementEvents(element);\r\n      const storeElementEvent = events[typeEvent] || {};\r\n      const isNamespace = originalTypeEvent.startsWith('.');\r\n      if (typeof callable !== 'undefined') {\r\n        // Simplest case: handler is passed, remove that listener ONLY.\r\n        if (!Object.keys(storeElementEvent).length) {\r\n          return;\r\n        }\r\n        removeHandler(element, events, typeEvent, callable, isDelegated ? handler : null);\r\n        return;\r\n      }\r\n      if (isNamespace) {\r\n        for (const elementEvent of Object.keys(events)) {\r\n          removeNamespacedHandlers(element, events, elementEvent, originalTypeEvent.slice(1));\r\n        }\r\n      }\r\n      for (const [keyHandlers, event] of Object.entries(storeElementEvent)) {\r\n        const handlerKey = keyHandlers.replace(stripUidRegex, '');\r\n        if (!inNamespace || originalTypeEvent.includes(handlerKey)) {\r\n          removeHandler(element, events, typeEvent, event.callable, event.delegationSelector);\r\n        }\r\n      }\r\n    },\r\n    trigger(element, event, args) {\r\n      if (typeof event !== 'string' || !element) {\r\n        return null;\r\n      }\r\n      const $ = getjQuery();\r\n      const typeEvent = getTypeEvent(event);\r\n      const inNamespace = event !== typeEvent;\r\n      let jQueryEvent = null;\r\n      let bubbles = true;\r\n      let nativeDispatch = true;\r\n      let defaultPrevented = false;\r\n      if (inNamespace && $) {\r\n        jQueryEvent = $.Event(event, args);\r\n        $(element).trigger(jQueryEvent);\r\n        bubbles = !jQueryEvent.isPropagationStopped();\r\n        nativeDispatch = !jQueryEvent.isImmediatePropagationStopped();\r\n        defaultPrevented = jQueryEvent.isDefaultPrevented();\r\n      }\r\n      const evt = hydrateObj(new Event(event, {\r\n        bubbles,\r\n        cancelable: true\r\n      }), args);\r\n      if (defaultPrevented) {\r\n        evt.preventDefault();\r\n      }\r\n      if (nativeDispatch) {\r\n        element.dispatchEvent(evt);\r\n      }\r\n      if (evt.defaultPrevented && jQueryEvent) {\r\n        jQueryEvent.preventDefault();\r\n      }\r\n      return evt;\r\n    }\r\n  };\r\n  function hydrateObj(obj, meta = {}) {\r\n    for (const [key, value] of Object.entries(meta)) {\r\n      try {\r\n        obj[key] = value;\r\n      } catch (_unused) {\r\n        Object.defineProperty(obj, key, {\r\n          configurable: true,\r\n          get() {\r\n            return value;\r\n          }\r\n        });\r\n      }\r\n    }\r\n    return obj;\r\n  }\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap dom/manipulator.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n  function normalizeData(value) {\r\n    if (value === 'true') {\r\n      return true;\r\n    }\r\n    if (value === 'false') {\r\n      return false;\r\n    }\r\n    if (value === Number(value).toString()) {\r\n      return Number(value);\r\n    }\r\n    if (value === '' || value === 'null') {\r\n      return null;\r\n    }\r\n    if (typeof value !== 'string') {\r\n      return value;\r\n    }\r\n    try {\r\n      return JSON.parse(decodeURIComponent(value));\r\n    } catch (_unused) {\r\n      return value;\r\n    }\r\n  }\r\n  function normalizeDataKey(key) {\r\n    return key.replace(/[A-Z]/g, chr => `-${chr.toLowerCase()}`);\r\n  }\r\n  const Manipulator = {\r\n    setDataAttribute(element, key, value) {\r\n      element.setAttribute(`data-bs-${normalizeDataKey(key)}`, value);\r\n    },\r\n    removeDataAttribute(element, key) {\r\n      element.removeAttribute(`data-bs-${normalizeDataKey(key)}`);\r\n    },\r\n    getDataAttributes(element) {\r\n      if (!element) {\r\n        return {};\r\n      }\r\n      const attributes = {};\r\n      const bsKeys = Object.keys(element.dataset).filter(key => key.startsWith('bs') && !key.startsWith('bsConfig'));\r\n      for (const key of bsKeys) {\r\n        let pureKey = key.replace(/^bs/, '');\r\n        pureKey = pureKey.charAt(0).toLowerCase() + pureKey.slice(1);\r\n        attributes[pureKey] = normalizeData(element.dataset[key]);\r\n      }\r\n      return attributes;\r\n    },\r\n    getDataAttribute(element, key) {\r\n      return normalizeData(element.getAttribute(`data-bs-${normalizeDataKey(key)}`));\r\n    }\r\n  };\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap util/config.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Config {\r\n    // Getters\r\n    static get Default() {\r\n      return {};\r\n    }\r\n    static get DefaultType() {\r\n      return {};\r\n    }\r\n    static get NAME() {\r\n      throw new Error('You have to implement the static method \"NAME\", for each component!');\r\n    }\r\n    _getConfig(config) {\r\n      config = this._mergeConfigObj(config);\r\n      config = this._configAfterMerge(config);\r\n      this._typeCheckConfig(config);\r\n      return config;\r\n    }\r\n    _configAfterMerge(config) {\r\n      return config;\r\n    }\r\n    _mergeConfigObj(config, element) {\r\n      const jsonConfig = isElement$1(element) ? Manipulator.getDataAttribute(element, 'config') : {}; // try to parse\r\n\r\n      return {\r\n        ...this.constructor.Default,\r\n        ...(typeof jsonConfig === 'object' ? jsonConfig : {}),\r\n        ...(isElement$1(element) ? Manipulator.getDataAttributes(element) : {}),\r\n        ...(typeof config === 'object' ? config : {})\r\n      };\r\n    }\r\n    _typeCheckConfig(config, configTypes = this.constructor.DefaultType) {\r\n      for (const [property, expectedTypes] of Object.entries(configTypes)) {\r\n        const value = config[property];\r\n        const valueType = isElement$1(value) ? 'element' : toType(value);\r\n        if (!new RegExp(expectedTypes).test(valueType)) {\r\n          throw new TypeError(`${this.constructor.NAME.toUpperCase()}: Option \"${property}\" provided type \"${valueType}\" but expected type \"${expectedTypes}\".`);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap base-component.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const VERSION = '5.3.7';\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class BaseComponent extends Config {\r\n    constructor(element, config) {\r\n      super();\r\n      element = getElement(element);\r\n      if (!element) {\r\n        return;\r\n      }\r\n      this._element = element;\r\n      this._config = this._getConfig(config);\r\n      Data.set(this._element, this.constructor.DATA_KEY, this);\r\n    }\r\n\r\n    // Public\r\n    dispose() {\r\n      Data.remove(this._element, this.constructor.DATA_KEY);\r\n      EventHandler.off(this._element, this.constructor.EVENT_KEY);\r\n      for (const propertyName of Object.getOwnPropertyNames(this)) {\r\n        this[propertyName] = null;\r\n      }\r\n    }\r\n\r\n    // Private\r\n    _queueCallback(callback, element, isAnimated = true) {\r\n      executeAfterTransition(callback, element, isAnimated);\r\n    }\r\n    _getConfig(config) {\r\n      config = this._mergeConfigObj(config, this._element);\r\n      config = this._configAfterMerge(config);\r\n      this._typeCheckConfig(config);\r\n      return config;\r\n    }\r\n\r\n    // Static\r\n    static getInstance(element) {\r\n      return Data.get(getElement(element), this.DATA_KEY);\r\n    }\r\n    static getOrCreateInstance(element, config = {}) {\r\n      return this.getInstance(element) || new this(element, typeof config === 'object' ? config : null);\r\n    }\r\n    static get VERSION() {\r\n      return VERSION;\r\n    }\r\n    static get DATA_KEY() {\r\n      return `bs.${this.NAME}`;\r\n    }\r\n    static get EVENT_KEY() {\r\n      return `.${this.DATA_KEY}`;\r\n    }\r\n    static eventName(name) {\r\n      return `${name}${this.EVENT_KEY}`;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap dom/selector-engine.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n  const getSelector = element => {\r\n    let selector = element.getAttribute('data-bs-target');\r\n    if (!selector || selector === '#') {\r\n      let hrefAttribute = element.getAttribute('href');\r\n\r\n      // The only valid content that could double as a selector are IDs or classes,\r\n      // so everything starting with `#` or `.`. If a \"real\" URL is used as the selector,\r\n      // `document.querySelector` will rightfully complain it is invalid.\r\n      // See https://github.com/twbs/bootstrap/issues/32273\r\n      if (!hrefAttribute || !hrefAttribute.includes('#') && !hrefAttribute.startsWith('.')) {\r\n        return null;\r\n      }\r\n\r\n      // Just in case some CMS puts out a full URL with the anchor appended\r\n      if (hrefAttribute.includes('#') && !hrefAttribute.startsWith('#')) {\r\n        hrefAttribute = `#${hrefAttribute.split('#')[1]}`;\r\n      }\r\n      selector = hrefAttribute && hrefAttribute !== '#' ? hrefAttribute.trim() : null;\r\n    }\r\n    return selector ? selector.split(',').map(sel => parseSelector(sel)).join(',') : null;\r\n  };\r\n  const SelectorEngine = {\r\n    find(selector, element = document.documentElement) {\r\n      return [].concat(...Element.prototype.querySelectorAll.call(element, selector));\r\n    },\r\n    findOne(selector, element = document.documentElement) {\r\n      return Element.prototype.querySelector.call(element, selector);\r\n    },\r\n    children(element, selector) {\r\n      return [].concat(...element.children).filter(child => child.matches(selector));\r\n    },\r\n    parents(element, selector) {\r\n      const parents = [];\r\n      let ancestor = element.parentNode.closest(selector);\r\n      while (ancestor) {\r\n        parents.push(ancestor);\r\n        ancestor = ancestor.parentNode.closest(selector);\r\n      }\r\n      return parents;\r\n    },\r\n    prev(element, selector) {\r\n      let previous = element.previousElementSibling;\r\n      while (previous) {\r\n        if (previous.matches(selector)) {\r\n          return [previous];\r\n        }\r\n        previous = previous.previousElementSibling;\r\n      }\r\n      return [];\r\n    },\r\n    // TODO: this is now unused; remove later along with prev()\r\n    next(element, selector) {\r\n      let next = element.nextElementSibling;\r\n      while (next) {\r\n        if (next.matches(selector)) {\r\n          return [next];\r\n        }\r\n        next = next.nextElementSibling;\r\n      }\r\n      return [];\r\n    },\r\n    focusableChildren(element) {\r\n      const focusables = ['a', 'button', 'input', 'textarea', 'select', 'details', '[tabindex]', '[contenteditable=\"true\"]'].map(selector => `${selector}:not([tabindex^=\"-\"])`).join(',');\r\n      return this.find(focusables, element).filter(el => !isDisabled(el) && isVisible(el));\r\n    },\r\n    getSelectorFromElement(element) {\r\n      const selector = getSelector(element);\r\n      if (selector) {\r\n        return SelectorEngine.findOne(selector) ? selector : null;\r\n      }\r\n      return null;\r\n    },\r\n    getElementFromSelector(element) {\r\n      const selector = getSelector(element);\r\n      return selector ? SelectorEngine.findOne(selector) : null;\r\n    },\r\n    getMultipleElementsFromSelector(element) {\r\n      const selector = getSelector(element);\r\n      return selector ? SelectorEngine.find(selector) : [];\r\n    }\r\n  };\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap util/component-functions.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n  const enableDismissTrigger = (component, method = 'hide') => {\r\n    const clickEvent = `click.dismiss${component.EVENT_KEY}`;\r\n    const name = component.NAME;\r\n    EventHandler.on(document, clickEvent, `[data-bs-dismiss=\"${name}\"]`, function (event) {\r\n      if (['A', 'AREA'].includes(this.tagName)) {\r\n        event.preventDefault();\r\n      }\r\n      if (isDisabled(this)) {\r\n        return;\r\n      }\r\n      const target = SelectorEngine.getElementFromSelector(this) || this.closest(`.${name}`);\r\n      const instance = component.getOrCreateInstance(target);\r\n\r\n      // Method argument is left, for Alert and only, as it doesn't implement the 'hide' method\r\n      instance[method]();\r\n    });\r\n  };\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap alert.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$f = 'alert';\r\n  const DATA_KEY$a = 'bs.alert';\r\n  const EVENT_KEY$b = `.${DATA_KEY$a}`;\r\n  const EVENT_CLOSE = `close${EVENT_KEY$b}`;\r\n  const EVENT_CLOSED = `closed${EVENT_KEY$b}`;\r\n  const CLASS_NAME_FADE$5 = 'fade';\r\n  const CLASS_NAME_SHOW$8 = 'show';\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Alert extends BaseComponent {\r\n    // Getters\r\n    static get NAME() {\r\n      return NAME$f;\r\n    }\r\n\r\n    // Public\r\n    close() {\r\n      const closeEvent = EventHandler.trigger(this._element, EVENT_CLOSE);\r\n      if (closeEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      this._element.classList.remove(CLASS_NAME_SHOW$8);\r\n      const isAnimated = this._element.classList.contains(CLASS_NAME_FADE$5);\r\n      this._queueCallback(() => this._destroyElement(), this._element, isAnimated);\r\n    }\r\n\r\n    // Private\r\n    _destroyElement() {\r\n      this._element.remove();\r\n      EventHandler.trigger(this._element, EVENT_CLOSED);\r\n      this.dispose();\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = Alert.getOrCreateInstance(this);\r\n        if (typeof config !== 'string') {\r\n          return;\r\n        }\r\n        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n        data[config](this);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  enableDismissTrigger(Alert, 'close');\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Alert);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap button.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$e = 'button';\r\n  const DATA_KEY$9 = 'bs.button';\r\n  const EVENT_KEY$a = `.${DATA_KEY$9}`;\r\n  const DATA_API_KEY$6 = '.data-api';\r\n  const CLASS_NAME_ACTIVE$3 = 'active';\r\n  const SELECTOR_DATA_TOGGLE$5 = '[data-bs-toggle=\"button\"]';\r\n  const EVENT_CLICK_DATA_API$6 = `click${EVENT_KEY$a}${DATA_API_KEY$6}`;\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Button extends BaseComponent {\r\n    // Getters\r\n    static get NAME() {\r\n      return NAME$e;\r\n    }\r\n\r\n    // Public\r\n    toggle() {\r\n      // Toggle class and sync the `aria-pressed` attribute with the return value of the `.toggle()` method\r\n      this._element.setAttribute('aria-pressed', this._element.classList.toggle(CLASS_NAME_ACTIVE$3));\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = Button.getOrCreateInstance(this);\r\n        if (config === 'toggle') {\r\n          data[config]();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  EventHandler.on(document, EVENT_CLICK_DATA_API$6, SELECTOR_DATA_TOGGLE$5, event => {\r\n    event.preventDefault();\r\n    const button = event.target.closest(SELECTOR_DATA_TOGGLE$5);\r\n    const data = Button.getOrCreateInstance(button);\r\n    data.toggle();\r\n  });\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Button);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap util/swipe.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$d = 'swipe';\r\n  const EVENT_KEY$9 = '.bs.swipe';\r\n  const EVENT_TOUCHSTART = `touchstart${EVENT_KEY$9}`;\r\n  const EVENT_TOUCHMOVE = `touchmove${EVENT_KEY$9}`;\r\n  const EVENT_TOUCHEND = `touchend${EVENT_KEY$9}`;\r\n  const EVENT_POINTERDOWN = `pointerdown${EVENT_KEY$9}`;\r\n  const EVENT_POINTERUP = `pointerup${EVENT_KEY$9}`;\r\n  const POINTER_TYPE_TOUCH = 'touch';\r\n  const POINTER_TYPE_PEN = 'pen';\r\n  const CLASS_NAME_POINTER_EVENT = 'pointer-event';\r\n  const SWIPE_THRESHOLD = 40;\r\n  const Default$c = {\r\n    endCallback: null,\r\n    leftCallback: null,\r\n    rightCallback: null\r\n  };\r\n  const DefaultType$c = {\r\n    endCallback: '(function|null)',\r\n    leftCallback: '(function|null)',\r\n    rightCallback: '(function|null)'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Swipe extends Config {\r\n    constructor(element, config) {\r\n      super();\r\n      this._element = element;\r\n      if (!element || !Swipe.isSupported()) {\r\n        return;\r\n      }\r\n      this._config = this._getConfig(config);\r\n      this._deltaX = 0;\r\n      this._supportPointerEvents = Boolean(window.PointerEvent);\r\n      this._initEvents();\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$c;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$c;\r\n    }\r\n    static get NAME() {\r\n      return NAME$d;\r\n    }\r\n\r\n    // Public\r\n    dispose() {\r\n      EventHandler.off(this._element, EVENT_KEY$9);\r\n    }\r\n\r\n    // Private\r\n    _start(event) {\r\n      if (!this._supportPointerEvents) {\r\n        this._deltaX = event.touches[0].clientX;\r\n        return;\r\n      }\r\n      if (this._eventIsPointerPenTouch(event)) {\r\n        this._deltaX = event.clientX;\r\n      }\r\n    }\r\n    _end(event) {\r\n      if (this._eventIsPointerPenTouch(event)) {\r\n        this._deltaX = event.clientX - this._deltaX;\r\n      }\r\n      this._handleSwipe();\r\n      execute(this._config.endCallback);\r\n    }\r\n    _move(event) {\r\n      this._deltaX = event.touches && event.touches.length > 1 ? 0 : event.touches[0].clientX - this._deltaX;\r\n    }\r\n    _handleSwipe() {\r\n      const absDeltaX = Math.abs(this._deltaX);\r\n      if (absDeltaX <= SWIPE_THRESHOLD) {\r\n        return;\r\n      }\r\n      const direction = absDeltaX / this._deltaX;\r\n      this._deltaX = 0;\r\n      if (!direction) {\r\n        return;\r\n      }\r\n      execute(direction > 0 ? this._config.rightCallback : this._config.leftCallback);\r\n    }\r\n    _initEvents() {\r\n      if (this._supportPointerEvents) {\r\n        EventHandler.on(this._element, EVENT_POINTERDOWN, event => this._start(event));\r\n        EventHandler.on(this._element, EVENT_POINTERUP, event => this._end(event));\r\n        this._element.classList.add(CLASS_NAME_POINTER_EVENT);\r\n      } else {\r\n        EventHandler.on(this._element, EVENT_TOUCHSTART, event => this._start(event));\r\n        EventHandler.on(this._element, EVENT_TOUCHMOVE, event => this._move(event));\r\n        EventHandler.on(this._element, EVENT_TOUCHEND, event => this._end(event));\r\n      }\r\n    }\r\n    _eventIsPointerPenTouch(event) {\r\n      return this._supportPointerEvents && (event.pointerType === POINTER_TYPE_PEN || event.pointerType === POINTER_TYPE_TOUCH);\r\n    }\r\n\r\n    // Static\r\n    static isSupported() {\r\n      return 'ontouchstart' in document.documentElement || navigator.maxTouchPoints > 0;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap carousel.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$c = 'carousel';\r\n  const DATA_KEY$8 = 'bs.carousel';\r\n  const EVENT_KEY$8 = `.${DATA_KEY$8}`;\r\n  const DATA_API_KEY$5 = '.data-api';\r\n  const ARROW_LEFT_KEY$1 = 'ArrowLeft';\r\n  const ARROW_RIGHT_KEY$1 = 'ArrowRight';\r\n  const TOUCHEVENT_COMPAT_WAIT = 500; // Time for mouse compat events to fire after touch\r\n\r\n  const ORDER_NEXT = 'next';\r\n  const ORDER_PREV = 'prev';\r\n  const DIRECTION_LEFT = 'left';\r\n  const DIRECTION_RIGHT = 'right';\r\n  const EVENT_SLIDE = `slide${EVENT_KEY$8}`;\r\n  const EVENT_SLID = `slid${EVENT_KEY$8}`;\r\n  const EVENT_KEYDOWN$1 = `keydown${EVENT_KEY$8}`;\r\n  const EVENT_MOUSEENTER$1 = `mouseenter${EVENT_KEY$8}`;\r\n  const EVENT_MOUSELEAVE$1 = `mouseleave${EVENT_KEY$8}`;\r\n  const EVENT_DRAG_START = `dragstart${EVENT_KEY$8}`;\r\n  const EVENT_LOAD_DATA_API$3 = `load${EVENT_KEY$8}${DATA_API_KEY$5}`;\r\n  const EVENT_CLICK_DATA_API$5 = `click${EVENT_KEY$8}${DATA_API_KEY$5}`;\r\n  const CLASS_NAME_CAROUSEL = 'carousel';\r\n  const CLASS_NAME_ACTIVE$2 = 'active';\r\n  const CLASS_NAME_SLIDE = 'slide';\r\n  const CLASS_NAME_END = 'carousel-item-end';\r\n  const CLASS_NAME_START = 'carousel-item-start';\r\n  const CLASS_NAME_NEXT = 'carousel-item-next';\r\n  const CLASS_NAME_PREV = 'carousel-item-prev';\r\n  const SELECTOR_ACTIVE = '.active';\r\n  const SELECTOR_ITEM = '.carousel-item';\r\n  const SELECTOR_ACTIVE_ITEM = SELECTOR_ACTIVE + SELECTOR_ITEM;\r\n  const SELECTOR_ITEM_IMG = '.carousel-item img';\r\n  const SELECTOR_INDICATORS = '.carousel-indicators';\r\n  const SELECTOR_DATA_SLIDE = '[data-bs-slide], [data-bs-slide-to]';\r\n  const SELECTOR_DATA_RIDE = '[data-bs-ride=\"carousel\"]';\r\n  const KEY_TO_DIRECTION = {\r\n    [ARROW_LEFT_KEY$1]: DIRECTION_RIGHT,\r\n    [ARROW_RIGHT_KEY$1]: DIRECTION_LEFT\r\n  };\r\n  const Default$b = {\r\n    interval: 5000,\r\n    keyboard: true,\r\n    pause: 'hover',\r\n    ride: false,\r\n    touch: true,\r\n    wrap: true\r\n  };\r\n  const DefaultType$b = {\r\n    interval: '(number|boolean)',\r\n    // TODO:v6 remove boolean support\r\n    keyboard: 'boolean',\r\n    pause: '(string|boolean)',\r\n    ride: '(boolean|string)',\r\n    touch: 'boolean',\r\n    wrap: 'boolean'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Carousel extends BaseComponent {\r\n    constructor(element, config) {\r\n      super(element, config);\r\n      this._interval = null;\r\n      this._activeElement = null;\r\n      this._isSliding = false;\r\n      this.touchTimeout = null;\r\n      this._swipeHelper = null;\r\n      this._indicatorsElement = SelectorEngine.findOne(SELECTOR_INDICATORS, this._element);\r\n      this._addEventListeners();\r\n      if (this._config.ride === CLASS_NAME_CAROUSEL) {\r\n        this.cycle();\r\n      }\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$b;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$b;\r\n    }\r\n    static get NAME() {\r\n      return NAME$c;\r\n    }\r\n\r\n    // Public\r\n    next() {\r\n      this._slide(ORDER_NEXT);\r\n    }\r\n    nextWhenVisible() {\r\n      // FIXME TODO use `document.visibilityState`\r\n      // Don't call next when the page isn't visible\r\n      // or the carousel or its parent isn't visible\r\n      if (!document.hidden && isVisible(this._element)) {\r\n        this.next();\r\n      }\r\n    }\r\n    prev() {\r\n      this._slide(ORDER_PREV);\r\n    }\r\n    pause() {\r\n      if (this._isSliding) {\r\n        triggerTransitionEnd(this._element);\r\n      }\r\n      this._clearInterval();\r\n    }\r\n    cycle() {\r\n      this._clearInterval();\r\n      this._updateInterval();\r\n      this._interval = setInterval(() => this.nextWhenVisible(), this._config.interval);\r\n    }\r\n    _maybeEnableCycle() {\r\n      if (!this._config.ride) {\r\n        return;\r\n      }\r\n      if (this._isSliding) {\r\n        EventHandler.one(this._element, EVENT_SLID, () => this.cycle());\r\n        return;\r\n      }\r\n      this.cycle();\r\n    }\r\n    to(index) {\r\n      const items = this._getItems();\r\n      if (index > items.length - 1 || index < 0) {\r\n        return;\r\n      }\r\n      if (this._isSliding) {\r\n        EventHandler.one(this._element, EVENT_SLID, () => this.to(index));\r\n        return;\r\n      }\r\n      const activeIndex = this._getItemIndex(this._getActive());\r\n      if (activeIndex === index) {\r\n        return;\r\n      }\r\n      const order = index > activeIndex ? ORDER_NEXT : ORDER_PREV;\r\n      this._slide(order, items[index]);\r\n    }\r\n    dispose() {\r\n      if (this._swipeHelper) {\r\n        this._swipeHelper.dispose();\r\n      }\r\n      super.dispose();\r\n    }\r\n\r\n    // Private\r\n    _configAfterMerge(config) {\r\n      config.defaultInterval = config.interval;\r\n      return config;\r\n    }\r\n    _addEventListeners() {\r\n      if (this._config.keyboard) {\r\n        EventHandler.on(this._element, EVENT_KEYDOWN$1, event => this._keydown(event));\r\n      }\r\n      if (this._config.pause === 'hover') {\r\n        EventHandler.on(this._element, EVENT_MOUSEENTER$1, () => this.pause());\r\n        EventHandler.on(this._element, EVENT_MOUSELEAVE$1, () => this._maybeEnableCycle());\r\n      }\r\n      if (this._config.touch && Swipe.isSupported()) {\r\n        this._addTouchEventListeners();\r\n      }\r\n    }\r\n    _addTouchEventListeners() {\r\n      for (const img of SelectorEngine.find(SELECTOR_ITEM_IMG, this._element)) {\r\n        EventHandler.on(img, EVENT_DRAG_START, event => event.preventDefault());\r\n      }\r\n      const endCallBack = () => {\r\n        if (this._config.pause !== 'hover') {\r\n          return;\r\n        }\r\n\r\n        // If it's a touch-enabled device, mouseenter/leave are fired as\r\n        // part of the mouse compatibility events on first tap - the carousel\r\n        // would stop cycling until user tapped out of it;\r\n        // here, we listen for touchend, explicitly pause the carousel\r\n        // (as if it's the second time we tap on it, mouseenter compat event\r\n        // is NOT fired) and after a timeout (to allow for mouse compatibility\r\n        // events to fire) we explicitly restart cycling\r\n\r\n        this.pause();\r\n        if (this.touchTimeout) {\r\n          clearTimeout(this.touchTimeout);\r\n        }\r\n        this.touchTimeout = setTimeout(() => this._maybeEnableCycle(), TOUCHEVENT_COMPAT_WAIT + this._config.interval);\r\n      };\r\n      const swipeConfig = {\r\n        leftCallback: () => this._slide(this._directionToOrder(DIRECTION_LEFT)),\r\n        rightCallback: () => this._slide(this._directionToOrder(DIRECTION_RIGHT)),\r\n        endCallback: endCallBack\r\n      };\r\n      this._swipeHelper = new Swipe(this._element, swipeConfig);\r\n    }\r\n    _keydown(event) {\r\n      if (/input|textarea/i.test(event.target.tagName)) {\r\n        return;\r\n      }\r\n      const direction = KEY_TO_DIRECTION[event.key];\r\n      if (direction) {\r\n        event.preventDefault();\r\n        this._slide(this._directionToOrder(direction));\r\n      }\r\n    }\r\n    _getItemIndex(element) {\r\n      return this._getItems().indexOf(element);\r\n    }\r\n    _setActiveIndicatorElement(index) {\r\n      if (!this._indicatorsElement) {\r\n        return;\r\n      }\r\n      const activeIndicator = SelectorEngine.findOne(SELECTOR_ACTIVE, this._indicatorsElement);\r\n      activeIndicator.classList.remove(CLASS_NAME_ACTIVE$2);\r\n      activeIndicator.removeAttribute('aria-current');\r\n      const newActiveIndicator = SelectorEngine.findOne(`[data-bs-slide-to=\"${index}\"]`, this._indicatorsElement);\r\n      if (newActiveIndicator) {\r\n        newActiveIndicator.classList.add(CLASS_NAME_ACTIVE$2);\r\n        newActiveIndicator.setAttribute('aria-current', 'true');\r\n      }\r\n    }\r\n    _updateInterval() {\r\n      const element = this._activeElement || this._getActive();\r\n      if (!element) {\r\n        return;\r\n      }\r\n      const elementInterval = Number.parseInt(element.getAttribute('data-bs-interval'), 10);\r\n      this._config.interval = elementInterval || this._config.defaultInterval;\r\n    }\r\n    _slide(order, element = null) {\r\n      if (this._isSliding) {\r\n        return;\r\n      }\r\n      const activeElement = this._getActive();\r\n      const isNext = order === ORDER_NEXT;\r\n      const nextElement = element || getNextActiveElement(this._getItems(), activeElement, isNext, this._config.wrap);\r\n      if (nextElement === activeElement) {\r\n        return;\r\n      }\r\n      const nextElementIndex = this._getItemIndex(nextElement);\r\n      const triggerEvent = eventName => {\r\n        return EventHandler.trigger(this._element, eventName, {\r\n          relatedTarget: nextElement,\r\n          direction: this._orderToDirection(order),\r\n          from: this._getItemIndex(activeElement),\r\n          to: nextElementIndex\r\n        });\r\n      };\r\n      const slideEvent = triggerEvent(EVENT_SLIDE);\r\n      if (slideEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      if (!activeElement || !nextElement) {\r\n        // Some weirdness is happening, so we bail\r\n        // TODO: change tests that use empty divs to avoid this check\r\n        return;\r\n      }\r\n      const isCycling = Boolean(this._interval);\r\n      this.pause();\r\n      this._isSliding = true;\r\n      this._setActiveIndicatorElement(nextElementIndex);\r\n      this._activeElement = nextElement;\r\n      const directionalClassName = isNext ? CLASS_NAME_START : CLASS_NAME_END;\r\n      const orderClassName = isNext ? CLASS_NAME_NEXT : CLASS_NAME_PREV;\r\n      nextElement.classList.add(orderClassName);\r\n      reflow(nextElement);\r\n      activeElement.classList.add(directionalClassName);\r\n      nextElement.classList.add(directionalClassName);\r\n      const completeCallBack = () => {\r\n        nextElement.classList.remove(directionalClassName, orderClassName);\r\n        nextElement.classList.add(CLASS_NAME_ACTIVE$2);\r\n        activeElement.classList.remove(CLASS_NAME_ACTIVE$2, orderClassName, directionalClassName);\r\n        this._isSliding = false;\r\n        triggerEvent(EVENT_SLID);\r\n      };\r\n      this._queueCallback(completeCallBack, activeElement, this._isAnimated());\r\n      if (isCycling) {\r\n        this.cycle();\r\n      }\r\n    }\r\n    _isAnimated() {\r\n      return this._element.classList.contains(CLASS_NAME_SLIDE);\r\n    }\r\n    _getActive() {\r\n      return SelectorEngine.findOne(SELECTOR_ACTIVE_ITEM, this._element);\r\n    }\r\n    _getItems() {\r\n      return SelectorEngine.find(SELECTOR_ITEM, this._element);\r\n    }\r\n    _clearInterval() {\r\n      if (this._interval) {\r\n        clearInterval(this._interval);\r\n        this._interval = null;\r\n      }\r\n    }\r\n    _directionToOrder(direction) {\r\n      if (isRTL()) {\r\n        return direction === DIRECTION_LEFT ? ORDER_PREV : ORDER_NEXT;\r\n      }\r\n      return direction === DIRECTION_LEFT ? ORDER_NEXT : ORDER_PREV;\r\n    }\r\n    _orderToDirection(order) {\r\n      if (isRTL()) {\r\n        return order === ORDER_PREV ? DIRECTION_LEFT : DIRECTION_RIGHT;\r\n      }\r\n      return order === ORDER_PREV ? DIRECTION_RIGHT : DIRECTION_LEFT;\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = Carousel.getOrCreateInstance(this, config);\r\n        if (typeof config === 'number') {\r\n          data.to(config);\r\n          return;\r\n        }\r\n        if (typeof config === 'string') {\r\n          if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\r\n            throw new TypeError(`No method named \"${config}\"`);\r\n          }\r\n          data[config]();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  EventHandler.on(document, EVENT_CLICK_DATA_API$5, SELECTOR_DATA_SLIDE, function (event) {\r\n    const target = SelectorEngine.getElementFromSelector(this);\r\n    if (!target || !target.classList.contains(CLASS_NAME_CAROUSEL)) {\r\n      return;\r\n    }\r\n    event.preventDefault();\r\n    const carousel = Carousel.getOrCreateInstance(target);\r\n    const slideIndex = this.getAttribute('data-bs-slide-to');\r\n    if (slideIndex) {\r\n      carousel.to(slideIndex);\r\n      carousel._maybeEnableCycle();\r\n      return;\r\n    }\r\n    if (Manipulator.getDataAttribute(this, 'slide') === 'next') {\r\n      carousel.next();\r\n      carousel._maybeEnableCycle();\r\n      return;\r\n    }\r\n    carousel.prev();\r\n    carousel._maybeEnableCycle();\r\n  });\r\n  EventHandler.on(window, EVENT_LOAD_DATA_API$3, () => {\r\n    const carousels = SelectorEngine.find(SELECTOR_DATA_RIDE);\r\n    for (const carousel of carousels) {\r\n      Carousel.getOrCreateInstance(carousel);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Carousel);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap collapse.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$b = 'collapse';\r\n  const DATA_KEY$7 = 'bs.collapse';\r\n  const EVENT_KEY$7 = `.${DATA_KEY$7}`;\r\n  const DATA_API_KEY$4 = '.data-api';\r\n  const EVENT_SHOW$6 = `show${EVENT_KEY$7}`;\r\n  const EVENT_SHOWN$6 = `shown${EVENT_KEY$7}`;\r\n  const EVENT_HIDE$6 = `hide${EVENT_KEY$7}`;\r\n  const EVENT_HIDDEN$6 = `hidden${EVENT_KEY$7}`;\r\n  const EVENT_CLICK_DATA_API$4 = `click${EVENT_KEY$7}${DATA_API_KEY$4}`;\r\n  const CLASS_NAME_SHOW$7 = 'show';\r\n  const CLASS_NAME_COLLAPSE = 'collapse';\r\n  const CLASS_NAME_COLLAPSING = 'collapsing';\r\n  const CLASS_NAME_COLLAPSED = 'collapsed';\r\n  const CLASS_NAME_DEEPER_CHILDREN = `:scope .${CLASS_NAME_COLLAPSE} .${CLASS_NAME_COLLAPSE}`;\r\n  const CLASS_NAME_HORIZONTAL = 'collapse-horizontal';\r\n  const WIDTH = 'width';\r\n  const HEIGHT = 'height';\r\n  const SELECTOR_ACTIVES = '.collapse.show, .collapse.collapsing';\r\n  const SELECTOR_DATA_TOGGLE$4 = '[data-bs-toggle=\"collapse\"]';\r\n  const Default$a = {\r\n    parent: null,\r\n    toggle: true\r\n  };\r\n  const DefaultType$a = {\r\n    parent: '(null|element)',\r\n    toggle: 'boolean'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Collapse extends BaseComponent {\r\n    constructor(element, config) {\r\n      super(element, config);\r\n      this._isTransitioning = false;\r\n      this._triggerArray = [];\r\n      const toggleList = SelectorEngine.find(SELECTOR_DATA_TOGGLE$4);\r\n      for (const elem of toggleList) {\r\n        const selector = SelectorEngine.getSelectorFromElement(elem);\r\n        const filterElement = SelectorEngine.find(selector).filter(foundElement => foundElement === this._element);\r\n        if (selector !== null && filterElement.length) {\r\n          this._triggerArray.push(elem);\r\n        }\r\n      }\r\n      this._initializeChildren();\r\n      if (!this._config.parent) {\r\n        this._addAriaAndCollapsedClass(this._triggerArray, this._isShown());\r\n      }\r\n      if (this._config.toggle) {\r\n        this.toggle();\r\n      }\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$a;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$a;\r\n    }\r\n    static get NAME() {\r\n      return NAME$b;\r\n    }\r\n\r\n    // Public\r\n    toggle() {\r\n      if (this._isShown()) {\r\n        this.hide();\r\n      } else {\r\n        this.show();\r\n      }\r\n    }\r\n    show() {\r\n      if (this._isTransitioning || this._isShown()) {\r\n        return;\r\n      }\r\n      let activeChildren = [];\r\n\r\n      // find active children\r\n      if (this._config.parent) {\r\n        activeChildren = this._getFirstLevelChildren(SELECTOR_ACTIVES).filter(element => element !== this._element).map(element => Collapse.getOrCreateInstance(element, {\r\n          toggle: false\r\n        }));\r\n      }\r\n      if (activeChildren.length && activeChildren[0]._isTransitioning) {\r\n        return;\r\n      }\r\n      const startEvent = EventHandler.trigger(this._element, EVENT_SHOW$6);\r\n      if (startEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      for (const activeInstance of activeChildren) {\r\n        activeInstance.hide();\r\n      }\r\n      const dimension = this._getDimension();\r\n      this._element.classList.remove(CLASS_NAME_COLLAPSE);\r\n      this._element.classList.add(CLASS_NAME_COLLAPSING);\r\n      this._element.style[dimension] = 0;\r\n      this._addAriaAndCollapsedClass(this._triggerArray, true);\r\n      this._isTransitioning = true;\r\n      const complete = () => {\r\n        this._isTransitioning = false;\r\n        this._element.classList.remove(CLASS_NAME_COLLAPSING);\r\n        this._element.classList.add(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\r\n        this._element.style[dimension] = '';\r\n        EventHandler.trigger(this._element, EVENT_SHOWN$6);\r\n      };\r\n      const capitalizedDimension = dimension[0].toUpperCase() + dimension.slice(1);\r\n      const scrollSize = `scroll${capitalizedDimension}`;\r\n      this._queueCallback(complete, this._element, true);\r\n      this._element.style[dimension] = `${this._element[scrollSize]}px`;\r\n    }\r\n    hide() {\r\n      if (this._isTransitioning || !this._isShown()) {\r\n        return;\r\n      }\r\n      const startEvent = EventHandler.trigger(this._element, EVENT_HIDE$6);\r\n      if (startEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      const dimension = this._getDimension();\r\n      this._element.style[dimension] = `${this._element.getBoundingClientRect()[dimension]}px`;\r\n      reflow(this._element);\r\n      this._element.classList.add(CLASS_NAME_COLLAPSING);\r\n      this._element.classList.remove(CLASS_NAME_COLLAPSE, CLASS_NAME_SHOW$7);\r\n      for (const trigger of this._triggerArray) {\r\n        const element = SelectorEngine.getElementFromSelector(trigger);\r\n        if (element && !this._isShown(element)) {\r\n          this._addAriaAndCollapsedClass([trigger], false);\r\n        }\r\n      }\r\n      this._isTransitioning = true;\r\n      const complete = () => {\r\n        this._isTransitioning = false;\r\n        this._element.classList.remove(CLASS_NAME_COLLAPSING);\r\n        this._element.classList.add(CLASS_NAME_COLLAPSE);\r\n        EventHandler.trigger(this._element, EVENT_HIDDEN$6);\r\n      };\r\n      this._element.style[dimension] = '';\r\n      this._queueCallback(complete, this._element, true);\r\n    }\r\n\r\n    // Private\r\n    _isShown(element = this._element) {\r\n      return element.classList.contains(CLASS_NAME_SHOW$7);\r\n    }\r\n    _configAfterMerge(config) {\r\n      config.toggle = Boolean(config.toggle); // Coerce string values\r\n      config.parent = getElement(config.parent);\r\n      return config;\r\n    }\r\n    _getDimension() {\r\n      return this._element.classList.contains(CLASS_NAME_HORIZONTAL) ? WIDTH : HEIGHT;\r\n    }\r\n    _initializeChildren() {\r\n      if (!this._config.parent) {\r\n        return;\r\n      }\r\n      const children = this._getFirstLevelChildren(SELECTOR_DATA_TOGGLE$4);\r\n      for (const element of children) {\r\n        const selected = SelectorEngine.getElementFromSelector(element);\r\n        if (selected) {\r\n          this._addAriaAndCollapsedClass([element], this._isShown(selected));\r\n        }\r\n      }\r\n    }\r\n    _getFirstLevelChildren(selector) {\r\n      const children = SelectorEngine.find(CLASS_NAME_DEEPER_CHILDREN, this._config.parent);\r\n      // remove children if greater depth\r\n      return SelectorEngine.find(selector, this._config.parent).filter(element => !children.includes(element));\r\n    }\r\n    _addAriaAndCollapsedClass(triggerArray, isOpen) {\r\n      if (!triggerArray.length) {\r\n        return;\r\n      }\r\n      for (const element of triggerArray) {\r\n        element.classList.toggle(CLASS_NAME_COLLAPSED, !isOpen);\r\n        element.setAttribute('aria-expanded', isOpen);\r\n      }\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      const _config = {};\r\n      if (typeof config === 'string' && /show|hide/.test(config)) {\r\n        _config.toggle = false;\r\n      }\r\n      return this.each(function () {\r\n        const data = Collapse.getOrCreateInstance(this, _config);\r\n        if (typeof config === 'string') {\r\n          if (typeof data[config] === 'undefined') {\r\n            throw new TypeError(`No method named \"${config}\"`);\r\n          }\r\n          data[config]();\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  EventHandler.on(document, EVENT_CLICK_DATA_API$4, SELECTOR_DATA_TOGGLE$4, function (event) {\r\n    // preventDefault only for <a> elements (which change the URL) not inside the collapsible element\r\n    if (event.target.tagName === 'A' || event.delegateTarget && event.delegateTarget.tagName === 'A') {\r\n      event.preventDefault();\r\n    }\r\n    for (const element of SelectorEngine.getMultipleElementsFromSelector(this)) {\r\n      Collapse.getOrCreateInstance(element, {\r\n        toggle: false\r\n      }).toggle();\r\n    }\r\n  });\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Collapse);\r\n\r\n  var top = 'top';\r\n  var bottom = 'bottom';\r\n  var right = 'right';\r\n  var left = 'left';\r\n  var auto = 'auto';\r\n  var basePlacements = [top, bottom, right, left];\r\n  var start = 'start';\r\n  var end = 'end';\r\n  var clippingParents = 'clippingParents';\r\n  var viewport = 'viewport';\r\n  var popper = 'popper';\r\n  var reference = 'reference';\r\n  var variationPlacements = /*#__PURE__*/basePlacements.reduce(function (acc, placement) {\r\n    return acc.concat([placement + \"-\" + start, placement + \"-\" + end]);\r\n  }, []);\r\n  var placements = /*#__PURE__*/[].concat(basePlacements, [auto]).reduce(function (acc, placement) {\r\n    return acc.concat([placement, placement + \"-\" + start, placement + \"-\" + end]);\r\n  }, []); // modifiers that need to read the DOM\r\n\r\n  var beforeRead = 'beforeRead';\r\n  var read = 'read';\r\n  var afterRead = 'afterRead'; // pure-logic modifiers\r\n\r\n  var beforeMain = 'beforeMain';\r\n  var main = 'main';\r\n  var afterMain = 'afterMain'; // modifier with the purpose to write to the DOM (or write into a framework state)\r\n\r\n  var beforeWrite = 'beforeWrite';\r\n  var write = 'write';\r\n  var afterWrite = 'afterWrite';\r\n  var modifierPhases = [beforeRead, read, afterRead, beforeMain, main, afterMain, beforeWrite, write, afterWrite];\r\n\r\n  function getNodeName(element) {\r\n    return element ? (element.nodeName || '').toLowerCase() : null;\r\n  }\r\n\r\n  function getWindow(node) {\r\n    if (node == null) {\r\n      return window;\r\n    }\r\n\r\n    if (node.toString() !== '[object Window]') {\r\n      var ownerDocument = node.ownerDocument;\r\n      return ownerDocument ? ownerDocument.defaultView || window : window;\r\n    }\r\n\r\n    return node;\r\n  }\r\n\r\n  function isElement(node) {\r\n    var OwnElement = getWindow(node).Element;\r\n    return node instanceof OwnElement || node instanceof Element;\r\n  }\r\n\r\n  function isHTMLElement(node) {\r\n    var OwnElement = getWindow(node).HTMLElement;\r\n    return node instanceof OwnElement || node instanceof HTMLElement;\r\n  }\r\n\r\n  function isShadowRoot(node) {\r\n    // IE 11 has no ShadowRoot\r\n    if (typeof ShadowRoot === 'undefined') {\r\n      return false;\r\n    }\r\n\r\n    var OwnElement = getWindow(node).ShadowRoot;\r\n    return node instanceof OwnElement || node instanceof ShadowRoot;\r\n  }\r\n\r\n  // and applies them to the HTMLElements such as popper and arrow\r\n\r\n  function applyStyles(_ref) {\r\n    var state = _ref.state;\r\n    Object.keys(state.elements).forEach(function (name) {\r\n      var style = state.styles[name] || {};\r\n      var attributes = state.attributes[name] || {};\r\n      var element = state.elements[name]; // arrow is optional + virtual elements\r\n\r\n      if (!isHTMLElement(element) || !getNodeName(element)) {\r\n        return;\r\n      } // Flow doesn't support to extend this property, but it's the most\r\n      // effective way to apply styles to an HTMLElement\r\n      // $FlowFixMe[cannot-write]\r\n\r\n\r\n      Object.assign(element.style, style);\r\n      Object.keys(attributes).forEach(function (name) {\r\n        var value = attributes[name];\r\n\r\n        if (value === false) {\r\n          element.removeAttribute(name);\r\n        } else {\r\n          element.setAttribute(name, value === true ? '' : value);\r\n        }\r\n      });\r\n    });\r\n  }\r\n\r\n  function effect$2(_ref2) {\r\n    var state = _ref2.state;\r\n    var initialStyles = {\r\n      popper: {\r\n        position: state.options.strategy,\r\n        left: '0',\r\n        top: '0',\r\n        margin: '0'\r\n      },\r\n      arrow: {\r\n        position: 'absolute'\r\n      },\r\n      reference: {}\r\n    };\r\n    Object.assign(state.elements.popper.style, initialStyles.popper);\r\n    state.styles = initialStyles;\r\n\r\n    if (state.elements.arrow) {\r\n      Object.assign(state.elements.arrow.style, initialStyles.arrow);\r\n    }\r\n\r\n    return function () {\r\n      Object.keys(state.elements).forEach(function (name) {\r\n        var element = state.elements[name];\r\n        var attributes = state.attributes[name] || {};\r\n        var styleProperties = Object.keys(state.styles.hasOwnProperty(name) ? state.styles[name] : initialStyles[name]); // Set all values to an empty string to unset them\r\n\r\n        var style = styleProperties.reduce(function (style, property) {\r\n          style[property] = '';\r\n          return style;\r\n        }, {}); // arrow is optional + virtual elements\r\n\r\n        if (!isHTMLElement(element) || !getNodeName(element)) {\r\n          return;\r\n        }\r\n\r\n        Object.assign(element.style, style);\r\n        Object.keys(attributes).forEach(function (attribute) {\r\n          element.removeAttribute(attribute);\r\n        });\r\n      });\r\n    };\r\n  } // eslint-disable-next-line import/no-unused-modules\r\n\r\n\r\n  const applyStyles$1 = {\r\n    name: 'applyStyles',\r\n    enabled: true,\r\n    phase: 'write',\r\n    fn: applyStyles,\r\n    effect: effect$2,\r\n    requires: ['computeStyles']\r\n  };\r\n\r\n  function getBasePlacement(placement) {\r\n    return placement.split('-')[0];\r\n  }\r\n\r\n  var max = Math.max;\r\n  var min = Math.min;\r\n  var round = Math.round;\r\n\r\n  function getUAString() {\r\n    var uaData = navigator.userAgentData;\r\n\r\n    if (uaData != null && uaData.brands && Array.isArray(uaData.brands)) {\r\n      return uaData.brands.map(function (item) {\r\n        return item.brand + \"/\" + item.version;\r\n      }).join(' ');\r\n    }\r\n\r\n    return navigator.userAgent;\r\n  }\r\n\r\n  function isLayoutViewport() {\r\n    return !/^((?!chrome|android).)*safari/i.test(getUAString());\r\n  }\r\n\r\n  function getBoundingClientRect(element, includeScale, isFixedStrategy) {\r\n    if (includeScale === void 0) {\r\n      includeScale = false;\r\n    }\r\n\r\n    if (isFixedStrategy === void 0) {\r\n      isFixedStrategy = false;\r\n    }\r\n\r\n    var clientRect = element.getBoundingClientRect();\r\n    var scaleX = 1;\r\n    var scaleY = 1;\r\n\r\n    if (includeScale && isHTMLElement(element)) {\r\n      scaleX = element.offsetWidth > 0 ? round(clientRect.width) / element.offsetWidth || 1 : 1;\r\n      scaleY = element.offsetHeight > 0 ? round(clientRect.height) / element.offsetHeight || 1 : 1;\r\n    }\r\n\r\n    var _ref = isElement(element) ? getWindow(element) : window,\r\n        visualViewport = _ref.visualViewport;\r\n\r\n    var addVisualOffsets = !isLayoutViewport() && isFixedStrategy;\r\n    var x = (clientRect.left + (addVisualOffsets && visualViewport ? visualViewport.offsetLeft : 0)) / scaleX;\r\n    var y = (clientRect.top + (addVisualOffsets && visualViewport ? visualViewport.offsetTop : 0)) / scaleY;\r\n    var width = clientRect.width / scaleX;\r\n    var height = clientRect.height / scaleY;\r\n    return {\r\n      width: width,\r\n      height: height,\r\n      top: y,\r\n      right: x + width,\r\n      bottom: y + height,\r\n      left: x,\r\n      x: x,\r\n      y: y\r\n    };\r\n  }\r\n\r\n  // means it doesn't take into account transforms.\r\n\r\n  function getLayoutRect(element) {\r\n    var clientRect = getBoundingClientRect(element); // Use the clientRect sizes if it's not been transformed.\r\n    // Fixes https://github.com/popperjs/popper-core/issues/1223\r\n\r\n    var width = element.offsetWidth;\r\n    var height = element.offsetHeight;\r\n\r\n    if (Math.abs(clientRect.width - width) <= 1) {\r\n      width = clientRect.width;\r\n    }\r\n\r\n    if (Math.abs(clientRect.height - height) <= 1) {\r\n      height = clientRect.height;\r\n    }\r\n\r\n    return {\r\n      x: element.offsetLeft,\r\n      y: element.offsetTop,\r\n      width: width,\r\n      height: height\r\n    };\r\n  }\r\n\r\n  function contains(parent, child) {\r\n    var rootNode = child.getRootNode && child.getRootNode(); // First, attempt with faster native method\r\n\r\n    if (parent.contains(child)) {\r\n      return true;\r\n    } // then fallback to custom implementation with Shadow DOM support\r\n    else if (rootNode && isShadowRoot(rootNode)) {\r\n        var next = child;\r\n\r\n        do {\r\n          if (next && parent.isSameNode(next)) {\r\n            return true;\r\n          } // $FlowFixMe[prop-missing]: need a better way to handle this...\r\n\r\n\r\n          next = next.parentNode || next.host;\r\n        } while (next);\r\n      } // Give up, the result is false\r\n\r\n\r\n    return false;\r\n  }\r\n\r\n  function getComputedStyle$1(element) {\r\n    return getWindow(element).getComputedStyle(element);\r\n  }\r\n\r\n  function isTableElement(element) {\r\n    return ['table', 'td', 'th'].indexOf(getNodeName(element)) >= 0;\r\n  }\r\n\r\n  function getDocumentElement(element) {\r\n    // $FlowFixMe[incompatible-return]: assume body is always available\r\n    return ((isElement(element) ? element.ownerDocument : // $FlowFixMe[prop-missing]\r\n    element.document) || window.document).documentElement;\r\n  }\r\n\r\n  function getParentNode(element) {\r\n    if (getNodeName(element) === 'html') {\r\n      return element;\r\n    }\r\n\r\n    return (// this is a quicker (but less type safe) way to save quite some bytes from the bundle\r\n      // $FlowFixMe[incompatible-return]\r\n      // $FlowFixMe[prop-missing]\r\n      element.assignedSlot || // step into the shadow DOM of the parent of a slotted node\r\n      element.parentNode || ( // DOM Element detected\r\n      isShadowRoot(element) ? element.host : null) || // ShadowRoot detected\r\n      // $FlowFixMe[incompatible-call]: HTMLElement is a Node\r\n      getDocumentElement(element) // fallback\r\n\r\n    );\r\n  }\r\n\r\n  function getTrueOffsetParent(element) {\r\n    if (!isHTMLElement(element) || // https://github.com/popperjs/popper-core/issues/837\r\n    getComputedStyle$1(element).position === 'fixed') {\r\n      return null;\r\n    }\r\n\r\n    return element.offsetParent;\r\n  } // `.offsetParent` reports `null` for fixed elements, while absolute elements\r\n  // return the containing block\r\n\r\n\r\n  function getContainingBlock(element) {\r\n    var isFirefox = /firefox/i.test(getUAString());\r\n    var isIE = /Trident/i.test(getUAString());\r\n\r\n    if (isIE && isHTMLElement(element)) {\r\n      // In IE 9, 10 and 11 fixed elements containing block is always established by the viewport\r\n      var elementCss = getComputedStyle$1(element);\r\n\r\n      if (elementCss.position === 'fixed') {\r\n        return null;\r\n      }\r\n    }\r\n\r\n    var currentNode = getParentNode(element);\r\n\r\n    if (isShadowRoot(currentNode)) {\r\n      currentNode = currentNode.host;\r\n    }\r\n\r\n    while (isHTMLElement(currentNode) && ['html', 'body'].indexOf(getNodeName(currentNode)) < 0) {\r\n      var css = getComputedStyle$1(currentNode); // This is non-exhaustive but covers the most common CSS properties that\r\n      // create a containing block.\r\n      // https://developer.mozilla.org/en-US/docs/Web/CSS/Containing_block#identifying_the_containing_block\r\n\r\n      if (css.transform !== 'none' || css.perspective !== 'none' || css.contain === 'paint' || ['transform', 'perspective'].indexOf(css.willChange) !== -1 || isFirefox && css.willChange === 'filter' || isFirefox && css.filter && css.filter !== 'none') {\r\n        return currentNode;\r\n      } else {\r\n        currentNode = currentNode.parentNode;\r\n      }\r\n    }\r\n\r\n    return null;\r\n  } // Gets the closest ancestor positioned element. Handles some edge cases,\r\n  // such as table ancestors and cross browser bugs.\r\n\r\n\r\n  function getOffsetParent(element) {\r\n    var window = getWindow(element);\r\n    var offsetParent = getTrueOffsetParent(element);\r\n\r\n    while (offsetParent && isTableElement(offsetParent) && getComputedStyle$1(offsetParent).position === 'static') {\r\n      offsetParent = getTrueOffsetParent(offsetParent);\r\n    }\r\n\r\n    if (offsetParent && (getNodeName(offsetParent) === 'html' || getNodeName(offsetParent) === 'body' && getComputedStyle$1(offsetParent).position === 'static')) {\r\n      return window;\r\n    }\r\n\r\n    return offsetParent || getContainingBlock(element) || window;\r\n  }\r\n\r\n  function getMainAxisFromPlacement(placement) {\r\n    return ['top', 'bottom'].indexOf(placement) >= 0 ? 'x' : 'y';\r\n  }\r\n\r\n  function within(min$1, value, max$1) {\r\n    return max(min$1, min(value, max$1));\r\n  }\r\n  function withinMaxClamp(min, value, max) {\r\n    var v = within(min, value, max);\r\n    return v > max ? max : v;\r\n  }\r\n\r\n  function getFreshSideObject() {\r\n    return {\r\n      top: 0,\r\n      right: 0,\r\n      bottom: 0,\r\n      left: 0\r\n    };\r\n  }\r\n\r\n  function mergePaddingObject(paddingObject) {\r\n    return Object.assign({}, getFreshSideObject(), paddingObject);\r\n  }\r\n\r\n  function expandToHashMap(value, keys) {\r\n    return keys.reduce(function (hashMap, key) {\r\n      hashMap[key] = value;\r\n      return hashMap;\r\n    }, {});\r\n  }\r\n\r\n  var toPaddingObject = function toPaddingObject(padding, state) {\r\n    padding = typeof padding === 'function' ? padding(Object.assign({}, state.rects, {\r\n      placement: state.placement\r\n    })) : padding;\r\n    return mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\r\n  };\r\n\r\n  function arrow(_ref) {\r\n    var _state$modifiersData$;\r\n\r\n    var state = _ref.state,\r\n        name = _ref.name,\r\n        options = _ref.options;\r\n    var arrowElement = state.elements.arrow;\r\n    var popperOffsets = state.modifiersData.popperOffsets;\r\n    var basePlacement = getBasePlacement(state.placement);\r\n    var axis = getMainAxisFromPlacement(basePlacement);\r\n    var isVertical = [left, right].indexOf(basePlacement) >= 0;\r\n    var len = isVertical ? 'height' : 'width';\r\n\r\n    if (!arrowElement || !popperOffsets) {\r\n      return;\r\n    }\r\n\r\n    var paddingObject = toPaddingObject(options.padding, state);\r\n    var arrowRect = getLayoutRect(arrowElement);\r\n    var minProp = axis === 'y' ? top : left;\r\n    var maxProp = axis === 'y' ? bottom : right;\r\n    var endDiff = state.rects.reference[len] + state.rects.reference[axis] - popperOffsets[axis] - state.rects.popper[len];\r\n    var startDiff = popperOffsets[axis] - state.rects.reference[axis];\r\n    var arrowOffsetParent = getOffsetParent(arrowElement);\r\n    var clientSize = arrowOffsetParent ? axis === 'y' ? arrowOffsetParent.clientHeight || 0 : arrowOffsetParent.clientWidth || 0 : 0;\r\n    var centerToReference = endDiff / 2 - startDiff / 2; // Make sure the arrow doesn't overflow the popper if the center point is\r\n    // outside of the popper bounds\r\n\r\n    var min = paddingObject[minProp];\r\n    var max = clientSize - arrowRect[len] - paddingObject[maxProp];\r\n    var center = clientSize / 2 - arrowRect[len] / 2 + centerToReference;\r\n    var offset = within(min, center, max); // Prevents breaking syntax highlighting...\r\n\r\n    var axisProp = axis;\r\n    state.modifiersData[name] = (_state$modifiersData$ = {}, _state$modifiersData$[axisProp] = offset, _state$modifiersData$.centerOffset = offset - center, _state$modifiersData$);\r\n  }\r\n\r\n  function effect$1(_ref2) {\r\n    var state = _ref2.state,\r\n        options = _ref2.options;\r\n    var _options$element = options.element,\r\n        arrowElement = _options$element === void 0 ? '[data-popper-arrow]' : _options$element;\r\n\r\n    if (arrowElement == null) {\r\n      return;\r\n    } // CSS selector\r\n\r\n\r\n    if (typeof arrowElement === 'string') {\r\n      arrowElement = state.elements.popper.querySelector(arrowElement);\r\n\r\n      if (!arrowElement) {\r\n        return;\r\n      }\r\n    }\r\n\r\n    if (!contains(state.elements.popper, arrowElement)) {\r\n      return;\r\n    }\r\n\r\n    state.elements.arrow = arrowElement;\r\n  } // eslint-disable-next-line import/no-unused-modules\r\n\r\n\r\n  const arrow$1 = {\r\n    name: 'arrow',\r\n    enabled: true,\r\n    phase: 'main',\r\n    fn: arrow,\r\n    effect: effect$1,\r\n    requires: ['popperOffsets'],\r\n    requiresIfExists: ['preventOverflow']\r\n  };\r\n\r\n  function getVariation(placement) {\r\n    return placement.split('-')[1];\r\n  }\r\n\r\n  var unsetSides = {\r\n    top: 'auto',\r\n    right: 'auto',\r\n    bottom: 'auto',\r\n    left: 'auto'\r\n  }; // Round the offsets to the nearest suitable subpixel based on the DPR.\r\n  // Zooming can change the DPR, but it seems to report a value that will\r\n  // cleanly divide the values into the appropriate subpixels.\r\n\r\n  function roundOffsetsByDPR(_ref, win) {\r\n    var x = _ref.x,\r\n        y = _ref.y;\r\n    var dpr = win.devicePixelRatio || 1;\r\n    return {\r\n      x: round(x * dpr) / dpr || 0,\r\n      y: round(y * dpr) / dpr || 0\r\n    };\r\n  }\r\n\r\n  function mapToStyles(_ref2) {\r\n    var _Object$assign2;\r\n\r\n    var popper = _ref2.popper,\r\n        popperRect = _ref2.popperRect,\r\n        placement = _ref2.placement,\r\n        variation = _ref2.variation,\r\n        offsets = _ref2.offsets,\r\n        position = _ref2.position,\r\n        gpuAcceleration = _ref2.gpuAcceleration,\r\n        adaptive = _ref2.adaptive,\r\n        roundOffsets = _ref2.roundOffsets,\r\n        isFixed = _ref2.isFixed;\r\n    var _offsets$x = offsets.x,\r\n        x = _offsets$x === void 0 ? 0 : _offsets$x,\r\n        _offsets$y = offsets.y,\r\n        y = _offsets$y === void 0 ? 0 : _offsets$y;\r\n\r\n    var _ref3 = typeof roundOffsets === 'function' ? roundOffsets({\r\n      x: x,\r\n      y: y\r\n    }) : {\r\n      x: x,\r\n      y: y\r\n    };\r\n\r\n    x = _ref3.x;\r\n    y = _ref3.y;\r\n    var hasX = offsets.hasOwnProperty('x');\r\n    var hasY = offsets.hasOwnProperty('y');\r\n    var sideX = left;\r\n    var sideY = top;\r\n    var win = window;\r\n\r\n    if (adaptive) {\r\n      var offsetParent = getOffsetParent(popper);\r\n      var heightProp = 'clientHeight';\r\n      var widthProp = 'clientWidth';\r\n\r\n      if (offsetParent === getWindow(popper)) {\r\n        offsetParent = getDocumentElement(popper);\r\n\r\n        if (getComputedStyle$1(offsetParent).position !== 'static' && position === 'absolute') {\r\n          heightProp = 'scrollHeight';\r\n          widthProp = 'scrollWidth';\r\n        }\r\n      } // $FlowFixMe[incompatible-cast]: force type refinement, we compare offsetParent with window above, but Flow doesn't detect it\r\n\r\n\r\n      offsetParent = offsetParent;\r\n\r\n      if (placement === top || (placement === left || placement === right) && variation === end) {\r\n        sideY = bottom;\r\n        var offsetY = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.height : // $FlowFixMe[prop-missing]\r\n        offsetParent[heightProp];\r\n        y -= offsetY - popperRect.height;\r\n        y *= gpuAcceleration ? 1 : -1;\r\n      }\r\n\r\n      if (placement === left || (placement === top || placement === bottom) && variation === end) {\r\n        sideX = right;\r\n        var offsetX = isFixed && offsetParent === win && win.visualViewport ? win.visualViewport.width : // $FlowFixMe[prop-missing]\r\n        offsetParent[widthProp];\r\n        x -= offsetX - popperRect.width;\r\n        x *= gpuAcceleration ? 1 : -1;\r\n      }\r\n    }\r\n\r\n    var commonStyles = Object.assign({\r\n      position: position\r\n    }, adaptive && unsetSides);\r\n\r\n    var _ref4 = roundOffsets === true ? roundOffsetsByDPR({\r\n      x: x,\r\n      y: y\r\n    }, getWindow(popper)) : {\r\n      x: x,\r\n      y: y\r\n    };\r\n\r\n    x = _ref4.x;\r\n    y = _ref4.y;\r\n\r\n    if (gpuAcceleration) {\r\n      var _Object$assign;\r\n\r\n      return Object.assign({}, commonStyles, (_Object$assign = {}, _Object$assign[sideY] = hasY ? '0' : '', _Object$assign[sideX] = hasX ? '0' : '', _Object$assign.transform = (win.devicePixelRatio || 1) <= 1 ? \"translate(\" + x + \"px, \" + y + \"px)\" : \"translate3d(\" + x + \"px, \" + y + \"px, 0)\", _Object$assign));\r\n    }\r\n\r\n    return Object.assign({}, commonStyles, (_Object$assign2 = {}, _Object$assign2[sideY] = hasY ? y + \"px\" : '', _Object$assign2[sideX] = hasX ? x + \"px\" : '', _Object$assign2.transform = '', _Object$assign2));\r\n  }\r\n\r\n  function computeStyles(_ref5) {\r\n    var state = _ref5.state,\r\n        options = _ref5.options;\r\n    var _options$gpuAccelerat = options.gpuAcceleration,\r\n        gpuAcceleration = _options$gpuAccelerat === void 0 ? true : _options$gpuAccelerat,\r\n        _options$adaptive = options.adaptive,\r\n        adaptive = _options$adaptive === void 0 ? true : _options$adaptive,\r\n        _options$roundOffsets = options.roundOffsets,\r\n        roundOffsets = _options$roundOffsets === void 0 ? true : _options$roundOffsets;\r\n    var commonStyles = {\r\n      placement: getBasePlacement(state.placement),\r\n      variation: getVariation(state.placement),\r\n      popper: state.elements.popper,\r\n      popperRect: state.rects.popper,\r\n      gpuAcceleration: gpuAcceleration,\r\n      isFixed: state.options.strategy === 'fixed'\r\n    };\r\n\r\n    if (state.modifiersData.popperOffsets != null) {\r\n      state.styles.popper = Object.assign({}, state.styles.popper, mapToStyles(Object.assign({}, commonStyles, {\r\n        offsets: state.modifiersData.popperOffsets,\r\n        position: state.options.strategy,\r\n        adaptive: adaptive,\r\n        roundOffsets: roundOffsets\r\n      })));\r\n    }\r\n\r\n    if (state.modifiersData.arrow != null) {\r\n      state.styles.arrow = Object.assign({}, state.styles.arrow, mapToStyles(Object.assign({}, commonStyles, {\r\n        offsets: state.modifiersData.arrow,\r\n        position: 'absolute',\r\n        adaptive: false,\r\n        roundOffsets: roundOffsets\r\n      })));\r\n    }\r\n\r\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\r\n      'data-popper-placement': state.placement\r\n    });\r\n  } // eslint-disable-next-line import/no-unused-modules\r\n\r\n\r\n  const computeStyles$1 = {\r\n    name: 'computeStyles',\r\n    enabled: true,\r\n    phase: 'beforeWrite',\r\n    fn: computeStyles,\r\n    data: {}\r\n  };\r\n\r\n  var passive = {\r\n    passive: true\r\n  };\r\n\r\n  function effect(_ref) {\r\n    var state = _ref.state,\r\n        instance = _ref.instance,\r\n        options = _ref.options;\r\n    var _options$scroll = options.scroll,\r\n        scroll = _options$scroll === void 0 ? true : _options$scroll,\r\n        _options$resize = options.resize,\r\n        resize = _options$resize === void 0 ? true : _options$resize;\r\n    var window = getWindow(state.elements.popper);\r\n    var scrollParents = [].concat(state.scrollParents.reference, state.scrollParents.popper);\r\n\r\n    if (scroll) {\r\n      scrollParents.forEach(function (scrollParent) {\r\n        scrollParent.addEventListener('scroll', instance.update, passive);\r\n      });\r\n    }\r\n\r\n    if (resize) {\r\n      window.addEventListener('resize', instance.update, passive);\r\n    }\r\n\r\n    return function () {\r\n      if (scroll) {\r\n        scrollParents.forEach(function (scrollParent) {\r\n          scrollParent.removeEventListener('scroll', instance.update, passive);\r\n        });\r\n      }\r\n\r\n      if (resize) {\r\n        window.removeEventListener('resize', instance.update, passive);\r\n      }\r\n    };\r\n  } // eslint-disable-next-line import/no-unused-modules\r\n\r\n\r\n  const eventListeners = {\r\n    name: 'eventListeners',\r\n    enabled: true,\r\n    phase: 'write',\r\n    fn: function fn() {},\r\n    effect: effect,\r\n    data: {}\r\n  };\r\n\r\n  var hash$1 = {\r\n    left: 'right',\r\n    right: 'left',\r\n    bottom: 'top',\r\n    top: 'bottom'\r\n  };\r\n  function getOppositePlacement(placement) {\r\n    return placement.replace(/left|right|bottom|top/g, function (matched) {\r\n      return hash$1[matched];\r\n    });\r\n  }\r\n\r\n  var hash = {\r\n    start: 'end',\r\n    end: 'start'\r\n  };\r\n  function getOppositeVariationPlacement(placement) {\r\n    return placement.replace(/start|end/g, function (matched) {\r\n      return hash[matched];\r\n    });\r\n  }\r\n\r\n  function getWindowScroll(node) {\r\n    var win = getWindow(node);\r\n    var scrollLeft = win.pageXOffset;\r\n    var scrollTop = win.pageYOffset;\r\n    return {\r\n      scrollLeft: scrollLeft,\r\n      scrollTop: scrollTop\r\n    };\r\n  }\r\n\r\n  function getWindowScrollBarX(element) {\r\n    // If <html> has a CSS width greater than the viewport, then this will be\r\n    // incorrect for RTL.\r\n    // Popper 1 is broken in this case and never had a bug report so let's assume\r\n    // it's not an issue. I don't think anyone ever specifies width on <html>\r\n    // anyway.\r\n    // Browsers where the left scrollbar doesn't cause an issue report `0` for\r\n    // this (e.g. Edge 2019, IE11, Safari)\r\n    return getBoundingClientRect(getDocumentElement(element)).left + getWindowScroll(element).scrollLeft;\r\n  }\r\n\r\n  function getViewportRect(element, strategy) {\r\n    var win = getWindow(element);\r\n    var html = getDocumentElement(element);\r\n    var visualViewport = win.visualViewport;\r\n    var width = html.clientWidth;\r\n    var height = html.clientHeight;\r\n    var x = 0;\r\n    var y = 0;\r\n\r\n    if (visualViewport) {\r\n      width = visualViewport.width;\r\n      height = visualViewport.height;\r\n      var layoutViewport = isLayoutViewport();\r\n\r\n      if (layoutViewport || !layoutViewport && strategy === 'fixed') {\r\n        x = visualViewport.offsetLeft;\r\n        y = visualViewport.offsetTop;\r\n      }\r\n    }\r\n\r\n    return {\r\n      width: width,\r\n      height: height,\r\n      x: x + getWindowScrollBarX(element),\r\n      y: y\r\n    };\r\n  }\r\n\r\n  // of the `<html>` and `<body>` rect bounds if horizontally scrollable\r\n\r\n  function getDocumentRect(element) {\r\n    var _element$ownerDocumen;\r\n\r\n    var html = getDocumentElement(element);\r\n    var winScroll = getWindowScroll(element);\r\n    var body = (_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body;\r\n    var width = max(html.scrollWidth, html.clientWidth, body ? body.scrollWidth : 0, body ? body.clientWidth : 0);\r\n    var height = max(html.scrollHeight, html.clientHeight, body ? body.scrollHeight : 0, body ? body.clientHeight : 0);\r\n    var x = -winScroll.scrollLeft + getWindowScrollBarX(element);\r\n    var y = -winScroll.scrollTop;\r\n\r\n    if (getComputedStyle$1(body || html).direction === 'rtl') {\r\n      x += max(html.clientWidth, body ? body.clientWidth : 0) - width;\r\n    }\r\n\r\n    return {\r\n      width: width,\r\n      height: height,\r\n      x: x,\r\n      y: y\r\n    };\r\n  }\r\n\r\n  function isScrollParent(element) {\r\n    // Firefox wants us to check `-x` and `-y` variations as well\r\n    var _getComputedStyle = getComputedStyle$1(element),\r\n        overflow = _getComputedStyle.overflow,\r\n        overflowX = _getComputedStyle.overflowX,\r\n        overflowY = _getComputedStyle.overflowY;\r\n\r\n    return /auto|scroll|overlay|hidden/.test(overflow + overflowY + overflowX);\r\n  }\r\n\r\n  function getScrollParent(node) {\r\n    if (['html', 'body', '#document'].indexOf(getNodeName(node)) >= 0) {\r\n      // $FlowFixMe[incompatible-return]: assume body is always available\r\n      return node.ownerDocument.body;\r\n    }\r\n\r\n    if (isHTMLElement(node) && isScrollParent(node)) {\r\n      return node;\r\n    }\r\n\r\n    return getScrollParent(getParentNode(node));\r\n  }\r\n\r\n  /*\r\n  given a DOM element, return the list of all scroll parents, up the list of ancesors\r\n  until we get to the top window object. This list is what we attach scroll listeners\r\n  to, because if any of these parent elements scroll, we'll need to re-calculate the\r\n  reference element's position.\r\n  */\r\n\r\n  function listScrollParents(element, list) {\r\n    var _element$ownerDocumen;\r\n\r\n    if (list === void 0) {\r\n      list = [];\r\n    }\r\n\r\n    var scrollParent = getScrollParent(element);\r\n    var isBody = scrollParent === ((_element$ownerDocumen = element.ownerDocument) == null ? void 0 : _element$ownerDocumen.body);\r\n    var win = getWindow(scrollParent);\r\n    var target = isBody ? [win].concat(win.visualViewport || [], isScrollParent(scrollParent) ? scrollParent : []) : scrollParent;\r\n    var updatedList = list.concat(target);\r\n    return isBody ? updatedList : // $FlowFixMe[incompatible-call]: isBody tells us target will be an HTMLElement here\r\n    updatedList.concat(listScrollParents(getParentNode(target)));\r\n  }\r\n\r\n  function rectToClientRect(rect) {\r\n    return Object.assign({}, rect, {\r\n      left: rect.x,\r\n      top: rect.y,\r\n      right: rect.x + rect.width,\r\n      bottom: rect.y + rect.height\r\n    });\r\n  }\r\n\r\n  function getInnerBoundingClientRect(element, strategy) {\r\n    var rect = getBoundingClientRect(element, false, strategy === 'fixed');\r\n    rect.top = rect.top + element.clientTop;\r\n    rect.left = rect.left + element.clientLeft;\r\n    rect.bottom = rect.top + element.clientHeight;\r\n    rect.right = rect.left + element.clientWidth;\r\n    rect.width = element.clientWidth;\r\n    rect.height = element.clientHeight;\r\n    rect.x = rect.left;\r\n    rect.y = rect.top;\r\n    return rect;\r\n  }\r\n\r\n  function getClientRectFromMixedType(element, clippingParent, strategy) {\r\n    return clippingParent === viewport ? rectToClientRect(getViewportRect(element, strategy)) : isElement(clippingParent) ? getInnerBoundingClientRect(clippingParent, strategy) : rectToClientRect(getDocumentRect(getDocumentElement(element)));\r\n  } // A \"clipping parent\" is an overflowable container with the characteristic of\r\n  // clipping (or hiding) overflowing elements with a position different from\r\n  // `initial`\r\n\r\n\r\n  function getClippingParents(element) {\r\n    var clippingParents = listScrollParents(getParentNode(element));\r\n    var canEscapeClipping = ['absolute', 'fixed'].indexOf(getComputedStyle$1(element).position) >= 0;\r\n    var clipperElement = canEscapeClipping && isHTMLElement(element) ? getOffsetParent(element) : element;\r\n\r\n    if (!isElement(clipperElement)) {\r\n      return [];\r\n    } // $FlowFixMe[incompatible-return]: https://github.com/facebook/flow/issues/1414\r\n\r\n\r\n    return clippingParents.filter(function (clippingParent) {\r\n      return isElement(clippingParent) && contains(clippingParent, clipperElement) && getNodeName(clippingParent) !== 'body';\r\n    });\r\n  } // Gets the maximum area that the element is visible in due to any number of\r\n  // clipping parents\r\n\r\n\r\n  function getClippingRect(element, boundary, rootBoundary, strategy) {\r\n    var mainClippingParents = boundary === 'clippingParents' ? getClippingParents(element) : [].concat(boundary);\r\n    var clippingParents = [].concat(mainClippingParents, [rootBoundary]);\r\n    var firstClippingParent = clippingParents[0];\r\n    var clippingRect = clippingParents.reduce(function (accRect, clippingParent) {\r\n      var rect = getClientRectFromMixedType(element, clippingParent, strategy);\r\n      accRect.top = max(rect.top, accRect.top);\r\n      accRect.right = min(rect.right, accRect.right);\r\n      accRect.bottom = min(rect.bottom, accRect.bottom);\r\n      accRect.left = max(rect.left, accRect.left);\r\n      return accRect;\r\n    }, getClientRectFromMixedType(element, firstClippingParent, strategy));\r\n    clippingRect.width = clippingRect.right - clippingRect.left;\r\n    clippingRect.height = clippingRect.bottom - clippingRect.top;\r\n    clippingRect.x = clippingRect.left;\r\n    clippingRect.y = clippingRect.top;\r\n    return clippingRect;\r\n  }\r\n\r\n  function computeOffsets(_ref) {\r\n    var reference = _ref.reference,\r\n        element = _ref.element,\r\n        placement = _ref.placement;\r\n    var basePlacement = placement ? getBasePlacement(placement) : null;\r\n    var variation = placement ? getVariation(placement) : null;\r\n    var commonX = reference.x + reference.width / 2 - element.width / 2;\r\n    var commonY = reference.y + reference.height / 2 - element.height / 2;\r\n    var offsets;\r\n\r\n    switch (basePlacement) {\r\n      case top:\r\n        offsets = {\r\n          x: commonX,\r\n          y: reference.y - element.height\r\n        };\r\n        break;\r\n\r\n      case bottom:\r\n        offsets = {\r\n          x: commonX,\r\n          y: reference.y + reference.height\r\n        };\r\n        break;\r\n\r\n      case right:\r\n        offsets = {\r\n          x: reference.x + reference.width,\r\n          y: commonY\r\n        };\r\n        break;\r\n\r\n      case left:\r\n        offsets = {\r\n          x: reference.x - element.width,\r\n          y: commonY\r\n        };\r\n        break;\r\n\r\n      default:\r\n        offsets = {\r\n          x: reference.x,\r\n          y: reference.y\r\n        };\r\n    }\r\n\r\n    var mainAxis = basePlacement ? getMainAxisFromPlacement(basePlacement) : null;\r\n\r\n    if (mainAxis != null) {\r\n      var len = mainAxis === 'y' ? 'height' : 'width';\r\n\r\n      switch (variation) {\r\n        case start:\r\n          offsets[mainAxis] = offsets[mainAxis] - (reference[len] / 2 - element[len] / 2);\r\n          break;\r\n\r\n        case end:\r\n          offsets[mainAxis] = offsets[mainAxis] + (reference[len] / 2 - element[len] / 2);\r\n          break;\r\n      }\r\n    }\r\n\r\n    return offsets;\r\n  }\r\n\r\n  function detectOverflow(state, options) {\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n\r\n    var _options = options,\r\n        _options$placement = _options.placement,\r\n        placement = _options$placement === void 0 ? state.placement : _options$placement,\r\n        _options$strategy = _options.strategy,\r\n        strategy = _options$strategy === void 0 ? state.strategy : _options$strategy,\r\n        _options$boundary = _options.boundary,\r\n        boundary = _options$boundary === void 0 ? clippingParents : _options$boundary,\r\n        _options$rootBoundary = _options.rootBoundary,\r\n        rootBoundary = _options$rootBoundary === void 0 ? viewport : _options$rootBoundary,\r\n        _options$elementConte = _options.elementContext,\r\n        elementContext = _options$elementConte === void 0 ? popper : _options$elementConte,\r\n        _options$altBoundary = _options.altBoundary,\r\n        altBoundary = _options$altBoundary === void 0 ? false : _options$altBoundary,\r\n        _options$padding = _options.padding,\r\n        padding = _options$padding === void 0 ? 0 : _options$padding;\r\n    var paddingObject = mergePaddingObject(typeof padding !== 'number' ? padding : expandToHashMap(padding, basePlacements));\r\n    var altContext = elementContext === popper ? reference : popper;\r\n    var popperRect = state.rects.popper;\r\n    var element = state.elements[altBoundary ? altContext : elementContext];\r\n    var clippingClientRect = getClippingRect(isElement(element) ? element : element.contextElement || getDocumentElement(state.elements.popper), boundary, rootBoundary, strategy);\r\n    var referenceClientRect = getBoundingClientRect(state.elements.reference);\r\n    var popperOffsets = computeOffsets({\r\n      reference: referenceClientRect,\r\n      element: popperRect,\r\n      placement: placement\r\n    });\r\n    var popperClientRect = rectToClientRect(Object.assign({}, popperRect, popperOffsets));\r\n    var elementClientRect = elementContext === popper ? popperClientRect : referenceClientRect; // positive = overflowing the clipping rect\r\n    // 0 or negative = within the clipping rect\r\n\r\n    var overflowOffsets = {\r\n      top: clippingClientRect.top - elementClientRect.top + paddingObject.top,\r\n      bottom: elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom,\r\n      left: clippingClientRect.left - elementClientRect.left + paddingObject.left,\r\n      right: elementClientRect.right - clippingClientRect.right + paddingObject.right\r\n    };\r\n    var offsetData = state.modifiersData.offset; // Offsets can be applied only to the popper element\r\n\r\n    if (elementContext === popper && offsetData) {\r\n      var offset = offsetData[placement];\r\n      Object.keys(overflowOffsets).forEach(function (key) {\r\n        var multiply = [right, bottom].indexOf(key) >= 0 ? 1 : -1;\r\n        var axis = [top, bottom].indexOf(key) >= 0 ? 'y' : 'x';\r\n        overflowOffsets[key] += offset[axis] * multiply;\r\n      });\r\n    }\r\n\r\n    return overflowOffsets;\r\n  }\r\n\r\n  function computeAutoPlacement(state, options) {\r\n    if (options === void 0) {\r\n      options = {};\r\n    }\r\n\r\n    var _options = options,\r\n        placement = _options.placement,\r\n        boundary = _options.boundary,\r\n        rootBoundary = _options.rootBoundary,\r\n        padding = _options.padding,\r\n        flipVariations = _options.flipVariations,\r\n        _options$allowedAutoP = _options.allowedAutoPlacements,\r\n        allowedAutoPlacements = _options$allowedAutoP === void 0 ? placements : _options$allowedAutoP;\r\n    var variation = getVariation(placement);\r\n    var placements$1 = variation ? flipVariations ? variationPlacements : variationPlacements.filter(function (placement) {\r\n      return getVariation(placement) === variation;\r\n    }) : basePlacements;\r\n    var allowedPlacements = placements$1.filter(function (placement) {\r\n      return allowedAutoPlacements.indexOf(placement) >= 0;\r\n    });\r\n\r\n    if (allowedPlacements.length === 0) {\r\n      allowedPlacements = placements$1;\r\n    } // $FlowFixMe[incompatible-type]: Flow seems to have problems with two array unions...\r\n\r\n\r\n    var overflows = allowedPlacements.reduce(function (acc, placement) {\r\n      acc[placement] = detectOverflow(state, {\r\n        placement: placement,\r\n        boundary: boundary,\r\n        rootBoundary: rootBoundary,\r\n        padding: padding\r\n      })[getBasePlacement(placement)];\r\n      return acc;\r\n    }, {});\r\n    return Object.keys(overflows).sort(function (a, b) {\r\n      return overflows[a] - overflows[b];\r\n    });\r\n  }\r\n\r\n  function getExpandedFallbackPlacements(placement) {\r\n    if (getBasePlacement(placement) === auto) {\r\n      return [];\r\n    }\r\n\r\n    var oppositePlacement = getOppositePlacement(placement);\r\n    return [getOppositeVariationPlacement(placement), oppositePlacement, getOppositeVariationPlacement(oppositePlacement)];\r\n  }\r\n\r\n  function flip(_ref) {\r\n    var state = _ref.state,\r\n        options = _ref.options,\r\n        name = _ref.name;\r\n\r\n    if (state.modifiersData[name]._skip) {\r\n      return;\r\n    }\r\n\r\n    var _options$mainAxis = options.mainAxis,\r\n        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\r\n        _options$altAxis = options.altAxis,\r\n        checkAltAxis = _options$altAxis === void 0 ? true : _options$altAxis,\r\n        specifiedFallbackPlacements = options.fallbackPlacements,\r\n        padding = options.padding,\r\n        boundary = options.boundary,\r\n        rootBoundary = options.rootBoundary,\r\n        altBoundary = options.altBoundary,\r\n        _options$flipVariatio = options.flipVariations,\r\n        flipVariations = _options$flipVariatio === void 0 ? true : _options$flipVariatio,\r\n        allowedAutoPlacements = options.allowedAutoPlacements;\r\n    var preferredPlacement = state.options.placement;\r\n    var basePlacement = getBasePlacement(preferredPlacement);\r\n    var isBasePlacement = basePlacement === preferredPlacement;\r\n    var fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipVariations ? [getOppositePlacement(preferredPlacement)] : getExpandedFallbackPlacements(preferredPlacement));\r\n    var placements = [preferredPlacement].concat(fallbackPlacements).reduce(function (acc, placement) {\r\n      return acc.concat(getBasePlacement(placement) === auto ? computeAutoPlacement(state, {\r\n        placement: placement,\r\n        boundary: boundary,\r\n        rootBoundary: rootBoundary,\r\n        padding: padding,\r\n        flipVariations: flipVariations,\r\n        allowedAutoPlacements: allowedAutoPlacements\r\n      }) : placement);\r\n    }, []);\r\n    var referenceRect = state.rects.reference;\r\n    var popperRect = state.rects.popper;\r\n    var checksMap = new Map();\r\n    var makeFallbackChecks = true;\r\n    var firstFittingPlacement = placements[0];\r\n\r\n    for (var i = 0; i < placements.length; i++) {\r\n      var placement = placements[i];\r\n\r\n      var _basePlacement = getBasePlacement(placement);\r\n\r\n      var isStartVariation = getVariation(placement) === start;\r\n      var isVertical = [top, bottom].indexOf(_basePlacement) >= 0;\r\n      var len = isVertical ? 'width' : 'height';\r\n      var overflow = detectOverflow(state, {\r\n        placement: placement,\r\n        boundary: boundary,\r\n        rootBoundary: rootBoundary,\r\n        altBoundary: altBoundary,\r\n        padding: padding\r\n      });\r\n      var mainVariationSide = isVertical ? isStartVariation ? right : left : isStartVariation ? bottom : top;\r\n\r\n      if (referenceRect[len] > popperRect[len]) {\r\n        mainVariationSide = getOppositePlacement(mainVariationSide);\r\n      }\r\n\r\n      var altVariationSide = getOppositePlacement(mainVariationSide);\r\n      var checks = [];\r\n\r\n      if (checkMainAxis) {\r\n        checks.push(overflow[_basePlacement] <= 0);\r\n      }\r\n\r\n      if (checkAltAxis) {\r\n        checks.push(overflow[mainVariationSide] <= 0, overflow[altVariationSide] <= 0);\r\n      }\r\n\r\n      if (checks.every(function (check) {\r\n        return check;\r\n      })) {\r\n        firstFittingPlacement = placement;\r\n        makeFallbackChecks = false;\r\n        break;\r\n      }\r\n\r\n      checksMap.set(placement, checks);\r\n    }\r\n\r\n    if (makeFallbackChecks) {\r\n      // `2` may be desired in some cases  research later\r\n      var numberOfChecks = flipVariations ? 3 : 1;\r\n\r\n      var _loop = function _loop(_i) {\r\n        var fittingPlacement = placements.find(function (placement) {\r\n          var checks = checksMap.get(placement);\r\n\r\n          if (checks) {\r\n            return checks.slice(0, _i).every(function (check) {\r\n              return check;\r\n            });\r\n          }\r\n        });\r\n\r\n        if (fittingPlacement) {\r\n          firstFittingPlacement = fittingPlacement;\r\n          return \"break\";\r\n        }\r\n      };\r\n\r\n      for (var _i = numberOfChecks; _i > 0; _i--) {\r\n        var _ret = _loop(_i);\r\n\r\n        if (_ret === \"break\") break;\r\n      }\r\n    }\r\n\r\n    if (state.placement !== firstFittingPlacement) {\r\n      state.modifiersData[name]._skip = true;\r\n      state.placement = firstFittingPlacement;\r\n      state.reset = true;\r\n    }\r\n  } // eslint-disable-next-line import/no-unused-modules\r\n\r\n\r\n  const flip$1 = {\r\n    name: 'flip',\r\n    enabled: true,\r\n    phase: 'main',\r\n    fn: flip,\r\n    requiresIfExists: ['offset'],\r\n    data: {\r\n      _skip: false\r\n    }\r\n  };\r\n\r\n  function getSideOffsets(overflow, rect, preventedOffsets) {\r\n    if (preventedOffsets === void 0) {\r\n      preventedOffsets = {\r\n        x: 0,\r\n        y: 0\r\n      };\r\n    }\r\n\r\n    return {\r\n      top: overflow.top - rect.height - preventedOffsets.y,\r\n      right: overflow.right - rect.width + preventedOffsets.x,\r\n      bottom: overflow.bottom - rect.height + preventedOffsets.y,\r\n      left: overflow.left - rect.width - preventedOffsets.x\r\n    };\r\n  }\r\n\r\n  function isAnySideFullyClipped(overflow) {\r\n    return [top, right, bottom, left].some(function (side) {\r\n      return overflow[side] >= 0;\r\n    });\r\n  }\r\n\r\n  function hide(_ref) {\r\n    var state = _ref.state,\r\n        name = _ref.name;\r\n    var referenceRect = state.rects.reference;\r\n    var popperRect = state.rects.popper;\r\n    var preventedOffsets = state.modifiersData.preventOverflow;\r\n    var referenceOverflow = detectOverflow(state, {\r\n      elementContext: 'reference'\r\n    });\r\n    var popperAltOverflow = detectOverflow(state, {\r\n      altBoundary: true\r\n    });\r\n    var referenceClippingOffsets = getSideOffsets(referenceOverflow, referenceRect);\r\n    var popperEscapeOffsets = getSideOffsets(popperAltOverflow, popperRect, preventedOffsets);\r\n    var isReferenceHidden = isAnySideFullyClipped(referenceClippingOffsets);\r\n    var hasPopperEscaped = isAnySideFullyClipped(popperEscapeOffsets);\r\n    state.modifiersData[name] = {\r\n      referenceClippingOffsets: referenceClippingOffsets,\r\n      popperEscapeOffsets: popperEscapeOffsets,\r\n      isReferenceHidden: isReferenceHidden,\r\n      hasPopperEscaped: hasPopperEscaped\r\n    };\r\n    state.attributes.popper = Object.assign({}, state.attributes.popper, {\r\n      'data-popper-reference-hidden': isReferenceHidden,\r\n      'data-popper-escaped': hasPopperEscaped\r\n    });\r\n  } // eslint-disable-next-line import/no-unused-modules\r\n\r\n\r\n  const hide$1 = {\r\n    name: 'hide',\r\n    enabled: true,\r\n    phase: 'main',\r\n    requiresIfExists: ['preventOverflow'],\r\n    fn: hide\r\n  };\r\n\r\n  function distanceAndSkiddingToXY(placement, rects, offset) {\r\n    var basePlacement = getBasePlacement(placement);\r\n    var invertDistance = [left, top].indexOf(basePlacement) >= 0 ? -1 : 1;\r\n\r\n    var _ref = typeof offset === 'function' ? offset(Object.assign({}, rects, {\r\n      placement: placement\r\n    })) : offset,\r\n        skidding = _ref[0],\r\n        distance = _ref[1];\r\n\r\n    skidding = skidding || 0;\r\n    distance = (distance || 0) * invertDistance;\r\n    return [left, right].indexOf(basePlacement) >= 0 ? {\r\n      x: distance,\r\n      y: skidding\r\n    } : {\r\n      x: skidding,\r\n      y: distance\r\n    };\r\n  }\r\n\r\n  function offset(_ref2) {\r\n    var state = _ref2.state,\r\n        options = _ref2.options,\r\n        name = _ref2.name;\r\n    var _options$offset = options.offset,\r\n        offset = _options$offset === void 0 ? [0, 0] : _options$offset;\r\n    var data = placements.reduce(function (acc, placement) {\r\n      acc[placement] = distanceAndSkiddingToXY(placement, state.rects, offset);\r\n      return acc;\r\n    }, {});\r\n    var _data$state$placement = data[state.placement],\r\n        x = _data$state$placement.x,\r\n        y = _data$state$placement.y;\r\n\r\n    if (state.modifiersData.popperOffsets != null) {\r\n      state.modifiersData.popperOffsets.x += x;\r\n      state.modifiersData.popperOffsets.y += y;\r\n    }\r\n\r\n    state.modifiersData[name] = data;\r\n  } // eslint-disable-next-line import/no-unused-modules\r\n\r\n\r\n  const offset$1 = {\r\n    name: 'offset',\r\n    enabled: true,\r\n    phase: 'main',\r\n    requires: ['popperOffsets'],\r\n    fn: offset\r\n  };\r\n\r\n  function popperOffsets(_ref) {\r\n    var state = _ref.state,\r\n        name = _ref.name;\r\n    // Offsets are the actual position the popper needs to have to be\r\n    // properly positioned near its reference element\r\n    // This is the most basic placement, and will be adjusted by\r\n    // the modifiers in the next step\r\n    state.modifiersData[name] = computeOffsets({\r\n      reference: state.rects.reference,\r\n      element: state.rects.popper,\r\n      placement: state.placement\r\n    });\r\n  } // eslint-disable-next-line import/no-unused-modules\r\n\r\n\r\n  const popperOffsets$1 = {\r\n    name: 'popperOffsets',\r\n    enabled: true,\r\n    phase: 'read',\r\n    fn: popperOffsets,\r\n    data: {}\r\n  };\r\n\r\n  function getAltAxis(axis) {\r\n    return axis === 'x' ? 'y' : 'x';\r\n  }\r\n\r\n  function preventOverflow(_ref) {\r\n    var state = _ref.state,\r\n        options = _ref.options,\r\n        name = _ref.name;\r\n    var _options$mainAxis = options.mainAxis,\r\n        checkMainAxis = _options$mainAxis === void 0 ? true : _options$mainAxis,\r\n        _options$altAxis = options.altAxis,\r\n        checkAltAxis = _options$altAxis === void 0 ? false : _options$altAxis,\r\n        boundary = options.boundary,\r\n        rootBoundary = options.rootBoundary,\r\n        altBoundary = options.altBoundary,\r\n        padding = options.padding,\r\n        _options$tether = options.tether,\r\n        tether = _options$tether === void 0 ? true : _options$tether,\r\n        _options$tetherOffset = options.tetherOffset,\r\n        tetherOffset = _options$tetherOffset === void 0 ? 0 : _options$tetherOffset;\r\n    var overflow = detectOverflow(state, {\r\n      boundary: boundary,\r\n      rootBoundary: rootBoundary,\r\n      padding: padding,\r\n      altBoundary: altBoundary\r\n    });\r\n    var basePlacement = getBasePlacement(state.placement);\r\n    var variation = getVariation(state.placement);\r\n    var isBasePlacement = !variation;\r\n    var mainAxis = getMainAxisFromPlacement(basePlacement);\r\n    var altAxis = getAltAxis(mainAxis);\r\n    var popperOffsets = state.modifiersData.popperOffsets;\r\n    var referenceRect = state.rects.reference;\r\n    var popperRect = state.rects.popper;\r\n    var tetherOffsetValue = typeof tetherOffset === 'function' ? tetherOffset(Object.assign({}, state.rects, {\r\n      placement: state.placement\r\n    })) : tetherOffset;\r\n    var normalizedTetherOffsetValue = typeof tetherOffsetValue === 'number' ? {\r\n      mainAxis: tetherOffsetValue,\r\n      altAxis: tetherOffsetValue\r\n    } : Object.assign({\r\n      mainAxis: 0,\r\n      altAxis: 0\r\n    }, tetherOffsetValue);\r\n    var offsetModifierState = state.modifiersData.offset ? state.modifiersData.offset[state.placement] : null;\r\n    var data = {\r\n      x: 0,\r\n      y: 0\r\n    };\r\n\r\n    if (!popperOffsets) {\r\n      return;\r\n    }\r\n\r\n    if (checkMainAxis) {\r\n      var _offsetModifierState$;\r\n\r\n      var mainSide = mainAxis === 'y' ? top : left;\r\n      var altSide = mainAxis === 'y' ? bottom : right;\r\n      var len = mainAxis === 'y' ? 'height' : 'width';\r\n      var offset = popperOffsets[mainAxis];\r\n      var min$1 = offset + overflow[mainSide];\r\n      var max$1 = offset - overflow[altSide];\r\n      var additive = tether ? -popperRect[len] / 2 : 0;\r\n      var minLen = variation === start ? referenceRect[len] : popperRect[len];\r\n      var maxLen = variation === start ? -popperRect[len] : -referenceRect[len]; // We need to include the arrow in the calculation so the arrow doesn't go\r\n      // outside the reference bounds\r\n\r\n      var arrowElement = state.elements.arrow;\r\n      var arrowRect = tether && arrowElement ? getLayoutRect(arrowElement) : {\r\n        width: 0,\r\n        height: 0\r\n      };\r\n      var arrowPaddingObject = state.modifiersData['arrow#persistent'] ? state.modifiersData['arrow#persistent'].padding : getFreshSideObject();\r\n      var arrowPaddingMin = arrowPaddingObject[mainSide];\r\n      var arrowPaddingMax = arrowPaddingObject[altSide]; // If the reference length is smaller than the arrow length, we don't want\r\n      // to include its full size in the calculation. If the reference is small\r\n      // and near the edge of a boundary, the popper can overflow even if the\r\n      // reference is not overflowing as well (e.g. virtual elements with no\r\n      // width or height)\r\n\r\n      var arrowLen = within(0, referenceRect[len], arrowRect[len]);\r\n      var minOffset = isBasePlacement ? referenceRect[len] / 2 - additive - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis : minLen - arrowLen - arrowPaddingMin - normalizedTetherOffsetValue.mainAxis;\r\n      var maxOffset = isBasePlacement ? -referenceRect[len] / 2 + additive + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis : maxLen + arrowLen + arrowPaddingMax + normalizedTetherOffsetValue.mainAxis;\r\n      var arrowOffsetParent = state.elements.arrow && getOffsetParent(state.elements.arrow);\r\n      var clientOffset = arrowOffsetParent ? mainAxis === 'y' ? arrowOffsetParent.clientTop || 0 : arrowOffsetParent.clientLeft || 0 : 0;\r\n      var offsetModifierValue = (_offsetModifierState$ = offsetModifierState == null ? void 0 : offsetModifierState[mainAxis]) != null ? _offsetModifierState$ : 0;\r\n      var tetherMin = offset + minOffset - offsetModifierValue - clientOffset;\r\n      var tetherMax = offset + maxOffset - offsetModifierValue;\r\n      var preventedOffset = within(tether ? min(min$1, tetherMin) : min$1, offset, tether ? max(max$1, tetherMax) : max$1);\r\n      popperOffsets[mainAxis] = preventedOffset;\r\n      data[mainAxis] = preventedOffset - offset;\r\n    }\r\n\r\n    if (checkAltAxis) {\r\n      var _offsetModifierState$2;\r\n\r\n      var _mainSide = mainAxis === 'x' ? top : left;\r\n\r\n      var _altSide = mainAxis === 'x' ? bottom : right;\r\n\r\n      var _offset = popperOffsets[altAxis];\r\n\r\n      var _len = altAxis === 'y' ? 'height' : 'width';\r\n\r\n      var _min = _offset + overflow[_mainSide];\r\n\r\n      var _max = _offset - overflow[_altSide];\r\n\r\n      var isOriginSide = [top, left].indexOf(basePlacement) !== -1;\r\n\r\n      var _offsetModifierValue = (_offsetModifierState$2 = offsetModifierState == null ? void 0 : offsetModifierState[altAxis]) != null ? _offsetModifierState$2 : 0;\r\n\r\n      var _tetherMin = isOriginSide ? _min : _offset - referenceRect[_len] - popperRect[_len] - _offsetModifierValue + normalizedTetherOffsetValue.altAxis;\r\n\r\n      var _tetherMax = isOriginSide ? _offset + referenceRect[_len] + popperRect[_len] - _offsetModifierValue - normalizedTetherOffsetValue.altAxis : _max;\r\n\r\n      var _preventedOffset = tether && isOriginSide ? withinMaxClamp(_tetherMin, _offset, _tetherMax) : within(tether ? _tetherMin : _min, _offset, tether ? _tetherMax : _max);\r\n\r\n      popperOffsets[altAxis] = _preventedOffset;\r\n      data[altAxis] = _preventedOffset - _offset;\r\n    }\r\n\r\n    state.modifiersData[name] = data;\r\n  } // eslint-disable-next-line import/no-unused-modules\r\n\r\n\r\n  const preventOverflow$1 = {\r\n    name: 'preventOverflow',\r\n    enabled: true,\r\n    phase: 'main',\r\n    fn: preventOverflow,\r\n    requiresIfExists: ['offset']\r\n  };\r\n\r\n  function getHTMLElementScroll(element) {\r\n    return {\r\n      scrollLeft: element.scrollLeft,\r\n      scrollTop: element.scrollTop\r\n    };\r\n  }\r\n\r\n  function getNodeScroll(node) {\r\n    if (node === getWindow(node) || !isHTMLElement(node)) {\r\n      return getWindowScroll(node);\r\n    } else {\r\n      return getHTMLElementScroll(node);\r\n    }\r\n  }\r\n\r\n  function isElementScaled(element) {\r\n    var rect = element.getBoundingClientRect();\r\n    var scaleX = round(rect.width) / element.offsetWidth || 1;\r\n    var scaleY = round(rect.height) / element.offsetHeight || 1;\r\n    return scaleX !== 1 || scaleY !== 1;\r\n  } // Returns the composite rect of an element relative to its offsetParent.\r\n  // Composite means it takes into account transforms as well as layout.\r\n\r\n\r\n  function getCompositeRect(elementOrVirtualElement, offsetParent, isFixed) {\r\n    if (isFixed === void 0) {\r\n      isFixed = false;\r\n    }\r\n\r\n    var isOffsetParentAnElement = isHTMLElement(offsetParent);\r\n    var offsetParentIsScaled = isHTMLElement(offsetParent) && isElementScaled(offsetParent);\r\n    var documentElement = getDocumentElement(offsetParent);\r\n    var rect = getBoundingClientRect(elementOrVirtualElement, offsetParentIsScaled, isFixed);\r\n    var scroll = {\r\n      scrollLeft: 0,\r\n      scrollTop: 0\r\n    };\r\n    var offsets = {\r\n      x: 0,\r\n      y: 0\r\n    };\r\n\r\n    if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {\r\n      if (getNodeName(offsetParent) !== 'body' || // https://github.com/popperjs/popper-core/issues/1078\r\n      isScrollParent(documentElement)) {\r\n        scroll = getNodeScroll(offsetParent);\r\n      }\r\n\r\n      if (isHTMLElement(offsetParent)) {\r\n        offsets = getBoundingClientRect(offsetParent, true);\r\n        offsets.x += offsetParent.clientLeft;\r\n        offsets.y += offsetParent.clientTop;\r\n      } else if (documentElement) {\r\n        offsets.x = getWindowScrollBarX(documentElement);\r\n      }\r\n    }\r\n\r\n    return {\r\n      x: rect.left + scroll.scrollLeft - offsets.x,\r\n      y: rect.top + scroll.scrollTop - offsets.y,\r\n      width: rect.width,\r\n      height: rect.height\r\n    };\r\n  }\r\n\r\n  function order(modifiers) {\r\n    var map = new Map();\r\n    var visited = new Set();\r\n    var result = [];\r\n    modifiers.forEach(function (modifier) {\r\n      map.set(modifier.name, modifier);\r\n    }); // On visiting object, check for its dependencies and visit them recursively\r\n\r\n    function sort(modifier) {\r\n      visited.add(modifier.name);\r\n      var requires = [].concat(modifier.requires || [], modifier.requiresIfExists || []);\r\n      requires.forEach(function (dep) {\r\n        if (!visited.has(dep)) {\r\n          var depModifier = map.get(dep);\r\n\r\n          if (depModifier) {\r\n            sort(depModifier);\r\n          }\r\n        }\r\n      });\r\n      result.push(modifier);\r\n    }\r\n\r\n    modifiers.forEach(function (modifier) {\r\n      if (!visited.has(modifier.name)) {\r\n        // check for visited object\r\n        sort(modifier);\r\n      }\r\n    });\r\n    return result;\r\n  }\r\n\r\n  function orderModifiers(modifiers) {\r\n    // order based on dependencies\r\n    var orderedModifiers = order(modifiers); // order based on phase\r\n\r\n    return modifierPhases.reduce(function (acc, phase) {\r\n      return acc.concat(orderedModifiers.filter(function (modifier) {\r\n        return modifier.phase === phase;\r\n      }));\r\n    }, []);\r\n  }\r\n\r\n  function debounce(fn) {\r\n    var pending;\r\n    return function () {\r\n      if (!pending) {\r\n        pending = new Promise(function (resolve) {\r\n          Promise.resolve().then(function () {\r\n            pending = undefined;\r\n            resolve(fn());\r\n          });\r\n        });\r\n      }\r\n\r\n      return pending;\r\n    };\r\n  }\r\n\r\n  function mergeByName(modifiers) {\r\n    var merged = modifiers.reduce(function (merged, current) {\r\n      var existing = merged[current.name];\r\n      merged[current.name] = existing ? Object.assign({}, existing, current, {\r\n        options: Object.assign({}, existing.options, current.options),\r\n        data: Object.assign({}, existing.data, current.data)\r\n      }) : current;\r\n      return merged;\r\n    }, {}); // IE11 does not support Object.values\r\n\r\n    return Object.keys(merged).map(function (key) {\r\n      return merged[key];\r\n    });\r\n  }\r\n\r\n  var DEFAULT_OPTIONS = {\r\n    placement: 'bottom',\r\n    modifiers: [],\r\n    strategy: 'absolute'\r\n  };\r\n\r\n  function areValidElements() {\r\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\r\n      args[_key] = arguments[_key];\r\n    }\r\n\r\n    return !args.some(function (element) {\r\n      return !(element && typeof element.getBoundingClientRect === 'function');\r\n    });\r\n  }\r\n\r\n  function popperGenerator(generatorOptions) {\r\n    if (generatorOptions === void 0) {\r\n      generatorOptions = {};\r\n    }\r\n\r\n    var _generatorOptions = generatorOptions,\r\n        _generatorOptions$def = _generatorOptions.defaultModifiers,\r\n        defaultModifiers = _generatorOptions$def === void 0 ? [] : _generatorOptions$def,\r\n        _generatorOptions$def2 = _generatorOptions.defaultOptions,\r\n        defaultOptions = _generatorOptions$def2 === void 0 ? DEFAULT_OPTIONS : _generatorOptions$def2;\r\n    return function createPopper(reference, popper, options) {\r\n      if (options === void 0) {\r\n        options = defaultOptions;\r\n      }\r\n\r\n      var state = {\r\n        placement: 'bottom',\r\n        orderedModifiers: [],\r\n        options: Object.assign({}, DEFAULT_OPTIONS, defaultOptions),\r\n        modifiersData: {},\r\n        elements: {\r\n          reference: reference,\r\n          popper: popper\r\n        },\r\n        attributes: {},\r\n        styles: {}\r\n      };\r\n      var effectCleanupFns = [];\r\n      var isDestroyed = false;\r\n      var instance = {\r\n        state: state,\r\n        setOptions: function setOptions(setOptionsAction) {\r\n          var options = typeof setOptionsAction === 'function' ? setOptionsAction(state.options) : setOptionsAction;\r\n          cleanupModifierEffects();\r\n          state.options = Object.assign({}, defaultOptions, state.options, options);\r\n          state.scrollParents = {\r\n            reference: isElement(reference) ? listScrollParents(reference) : reference.contextElement ? listScrollParents(reference.contextElement) : [],\r\n            popper: listScrollParents(popper)\r\n          }; // Orders the modifiers based on their dependencies and `phase`\r\n          // properties\r\n\r\n          var orderedModifiers = orderModifiers(mergeByName([].concat(defaultModifiers, state.options.modifiers))); // Strip out disabled modifiers\r\n\r\n          state.orderedModifiers = orderedModifiers.filter(function (m) {\r\n            return m.enabled;\r\n          });\r\n          runModifierEffects();\r\n          return instance.update();\r\n        },\r\n        // Sync update  it will always be executed, even if not necessary. This\r\n        // is useful for low frequency updates where sync behavior simplifies the\r\n        // logic.\r\n        // For high frequency updates (e.g. `resize` and `scroll` events), always\r\n        // prefer the async Popper#update method\r\n        forceUpdate: function forceUpdate() {\r\n          if (isDestroyed) {\r\n            return;\r\n          }\r\n\r\n          var _state$elements = state.elements,\r\n              reference = _state$elements.reference,\r\n              popper = _state$elements.popper; // Don't proceed if `reference` or `popper` are not valid elements\r\n          // anymore\r\n\r\n          if (!areValidElements(reference, popper)) {\r\n            return;\r\n          } // Store the reference and popper rects to be read by modifiers\r\n\r\n\r\n          state.rects = {\r\n            reference: getCompositeRect(reference, getOffsetParent(popper), state.options.strategy === 'fixed'),\r\n            popper: getLayoutRect(popper)\r\n          }; // Modifiers have the ability to reset the current update cycle. The\r\n          // most common use case for this is the `flip` modifier changing the\r\n          // placement, which then needs to re-run all the modifiers, because the\r\n          // logic was previously ran for the previous placement and is therefore\r\n          // stale/incorrect\r\n\r\n          state.reset = false;\r\n          state.placement = state.options.placement; // On each update cycle, the `modifiersData` property for each modifier\r\n          // is filled with the initial data specified by the modifier. This means\r\n          // it doesn't persist and is fresh on each update.\r\n          // To ensure persistent data, use `${name}#persistent`\r\n\r\n          state.orderedModifiers.forEach(function (modifier) {\r\n            return state.modifiersData[modifier.name] = Object.assign({}, modifier.data);\r\n          });\r\n\r\n          for (var index = 0; index < state.orderedModifiers.length; index++) {\r\n            if (state.reset === true) {\r\n              state.reset = false;\r\n              index = -1;\r\n              continue;\r\n            }\r\n\r\n            var _state$orderedModifie = state.orderedModifiers[index],\r\n                fn = _state$orderedModifie.fn,\r\n                _state$orderedModifie2 = _state$orderedModifie.options,\r\n                _options = _state$orderedModifie2 === void 0 ? {} : _state$orderedModifie2,\r\n                name = _state$orderedModifie.name;\r\n\r\n            if (typeof fn === 'function') {\r\n              state = fn({\r\n                state: state,\r\n                options: _options,\r\n                name: name,\r\n                instance: instance\r\n              }) || state;\r\n            }\r\n          }\r\n        },\r\n        // Async and optimistically optimized update  it will not be executed if\r\n        // not necessary (debounced to run at most once-per-tick)\r\n        update: debounce(function () {\r\n          return new Promise(function (resolve) {\r\n            instance.forceUpdate();\r\n            resolve(state);\r\n          });\r\n        }),\r\n        destroy: function destroy() {\r\n          cleanupModifierEffects();\r\n          isDestroyed = true;\r\n        }\r\n      };\r\n\r\n      if (!areValidElements(reference, popper)) {\r\n        return instance;\r\n      }\r\n\r\n      instance.setOptions(options).then(function (state) {\r\n        if (!isDestroyed && options.onFirstUpdate) {\r\n          options.onFirstUpdate(state);\r\n        }\r\n      }); // Modifiers have the ability to execute arbitrary code before the first\r\n      // update cycle runs. They will be executed in the same order as the update\r\n      // cycle. This is useful when a modifier adds some persistent data that\r\n      // other modifiers need to use, but the modifier is run after the dependent\r\n      // one.\r\n\r\n      function runModifierEffects() {\r\n        state.orderedModifiers.forEach(function (_ref) {\r\n          var name = _ref.name,\r\n              _ref$options = _ref.options,\r\n              options = _ref$options === void 0 ? {} : _ref$options,\r\n              effect = _ref.effect;\r\n\r\n          if (typeof effect === 'function') {\r\n            var cleanupFn = effect({\r\n              state: state,\r\n              name: name,\r\n              instance: instance,\r\n              options: options\r\n            });\r\n\r\n            var noopFn = function noopFn() {};\r\n\r\n            effectCleanupFns.push(cleanupFn || noopFn);\r\n          }\r\n        });\r\n      }\r\n\r\n      function cleanupModifierEffects() {\r\n        effectCleanupFns.forEach(function (fn) {\r\n          return fn();\r\n        });\r\n        effectCleanupFns = [];\r\n      }\r\n\r\n      return instance;\r\n    };\r\n  }\r\n  var createPopper$2 = /*#__PURE__*/popperGenerator(); // eslint-disable-next-line import/no-unused-modules\r\n\r\n  var defaultModifiers$1 = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1];\r\n  var createPopper$1 = /*#__PURE__*/popperGenerator({\r\n    defaultModifiers: defaultModifiers$1\r\n  }); // eslint-disable-next-line import/no-unused-modules\r\n\r\n  var defaultModifiers = [eventListeners, popperOffsets$1, computeStyles$1, applyStyles$1, offset$1, flip$1, preventOverflow$1, arrow$1, hide$1];\r\n  var createPopper = /*#__PURE__*/popperGenerator({\r\n    defaultModifiers: defaultModifiers\r\n  }); // eslint-disable-next-line import/no-unused-modules\r\n\r\n  const Popper = /*#__PURE__*/Object.freeze(/*#__PURE__*/Object.defineProperty({\r\n    __proto__: null,\r\n    afterMain,\r\n    afterRead,\r\n    afterWrite,\r\n    applyStyles: applyStyles$1,\r\n    arrow: arrow$1,\r\n    auto,\r\n    basePlacements,\r\n    beforeMain,\r\n    beforeRead,\r\n    beforeWrite,\r\n    bottom,\r\n    clippingParents,\r\n    computeStyles: computeStyles$1,\r\n    createPopper,\r\n    createPopperBase: createPopper$2,\r\n    createPopperLite: createPopper$1,\r\n    detectOverflow,\r\n    end,\r\n    eventListeners,\r\n    flip: flip$1,\r\n    hide: hide$1,\r\n    left,\r\n    main,\r\n    modifierPhases,\r\n    offset: offset$1,\r\n    placements,\r\n    popper,\r\n    popperGenerator,\r\n    popperOffsets: popperOffsets$1,\r\n    preventOverflow: preventOverflow$1,\r\n    read,\r\n    reference,\r\n    right,\r\n    start,\r\n    top,\r\n    variationPlacements,\r\n    viewport,\r\n    write\r\n  }, Symbol.toStringTag, { value: 'Module' }));\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap dropdown.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$a = 'dropdown';\r\n  const DATA_KEY$6 = 'bs.dropdown';\r\n  const EVENT_KEY$6 = `.${DATA_KEY$6}`;\r\n  const DATA_API_KEY$3 = '.data-api';\r\n  const ESCAPE_KEY$2 = 'Escape';\r\n  const TAB_KEY$1 = 'Tab';\r\n  const ARROW_UP_KEY$1 = 'ArrowUp';\r\n  const ARROW_DOWN_KEY$1 = 'ArrowDown';\r\n  const RIGHT_MOUSE_BUTTON = 2; // MouseEvent.button value for the secondary button, usually the right button\r\n\r\n  const EVENT_HIDE$5 = `hide${EVENT_KEY$6}`;\r\n  const EVENT_HIDDEN$5 = `hidden${EVENT_KEY$6}`;\r\n  const EVENT_SHOW$5 = `show${EVENT_KEY$6}`;\r\n  const EVENT_SHOWN$5 = `shown${EVENT_KEY$6}`;\r\n  const EVENT_CLICK_DATA_API$3 = `click${EVENT_KEY$6}${DATA_API_KEY$3}`;\r\n  const EVENT_KEYDOWN_DATA_API = `keydown${EVENT_KEY$6}${DATA_API_KEY$3}`;\r\n  const EVENT_KEYUP_DATA_API = `keyup${EVENT_KEY$6}${DATA_API_KEY$3}`;\r\n  const CLASS_NAME_SHOW$6 = 'show';\r\n  const CLASS_NAME_DROPUP = 'dropup';\r\n  const CLASS_NAME_DROPEND = 'dropend';\r\n  const CLASS_NAME_DROPSTART = 'dropstart';\r\n  const CLASS_NAME_DROPUP_CENTER = 'dropup-center';\r\n  const CLASS_NAME_DROPDOWN_CENTER = 'dropdown-center';\r\n  const SELECTOR_DATA_TOGGLE$3 = '[data-bs-toggle=\"dropdown\"]:not(.disabled):not(:disabled)';\r\n  const SELECTOR_DATA_TOGGLE_SHOWN = `${SELECTOR_DATA_TOGGLE$3}.${CLASS_NAME_SHOW$6}`;\r\n  const SELECTOR_MENU = '.dropdown-menu';\r\n  const SELECTOR_NAVBAR = '.navbar';\r\n  const SELECTOR_NAVBAR_NAV = '.navbar-nav';\r\n  const SELECTOR_VISIBLE_ITEMS = '.dropdown-menu .dropdown-item:not(.disabled):not(:disabled)';\r\n  const PLACEMENT_TOP = isRTL() ? 'top-end' : 'top-start';\r\n  const PLACEMENT_TOPEND = isRTL() ? 'top-start' : 'top-end';\r\n  const PLACEMENT_BOTTOM = isRTL() ? 'bottom-end' : 'bottom-start';\r\n  const PLACEMENT_BOTTOMEND = isRTL() ? 'bottom-start' : 'bottom-end';\r\n  const PLACEMENT_RIGHT = isRTL() ? 'left-start' : 'right-start';\r\n  const PLACEMENT_LEFT = isRTL() ? 'right-start' : 'left-start';\r\n  const PLACEMENT_TOPCENTER = 'top';\r\n  const PLACEMENT_BOTTOMCENTER = 'bottom';\r\n  const Default$9 = {\r\n    autoClose: true,\r\n    boundary: 'clippingParents',\r\n    display: 'dynamic',\r\n    offset: [0, 2],\r\n    popperConfig: null,\r\n    reference: 'toggle'\r\n  };\r\n  const DefaultType$9 = {\r\n    autoClose: '(boolean|string)',\r\n    boundary: '(string|element)',\r\n    display: 'string',\r\n    offset: '(array|string|function)',\r\n    popperConfig: '(null|object|function)',\r\n    reference: '(string|element|object)'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Dropdown extends BaseComponent {\r\n    constructor(element, config) {\r\n      super(element, config);\r\n      this._popper = null;\r\n      this._parent = this._element.parentNode; // dropdown wrapper\r\n      // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/\r\n      this._menu = SelectorEngine.next(this._element, SELECTOR_MENU)[0] || SelectorEngine.prev(this._element, SELECTOR_MENU)[0] || SelectorEngine.findOne(SELECTOR_MENU, this._parent);\r\n      this._inNavbar = this._detectNavbar();\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$9;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$9;\r\n    }\r\n    static get NAME() {\r\n      return NAME$a;\r\n    }\r\n\r\n    // Public\r\n    toggle() {\r\n      return this._isShown() ? this.hide() : this.show();\r\n    }\r\n    show() {\r\n      if (isDisabled(this._element) || this._isShown()) {\r\n        return;\r\n      }\r\n      const relatedTarget = {\r\n        relatedTarget: this._element\r\n      };\r\n      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$5, relatedTarget);\r\n      if (showEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      this._createPopper();\r\n\r\n      // If this is a touch-enabled device we add extra\r\n      // empty mouseover listeners to the body's immediate children;\r\n      // only needed because of broken event delegation on iOS\r\n      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\r\n      if ('ontouchstart' in document.documentElement && !this._parent.closest(SELECTOR_NAVBAR_NAV)) {\r\n        for (const element of [].concat(...document.body.children)) {\r\n          EventHandler.on(element, 'mouseover', noop);\r\n        }\r\n      }\r\n      this._element.focus();\r\n      this._element.setAttribute('aria-expanded', true);\r\n      this._menu.classList.add(CLASS_NAME_SHOW$6);\r\n      this._element.classList.add(CLASS_NAME_SHOW$6);\r\n      EventHandler.trigger(this._element, EVENT_SHOWN$5, relatedTarget);\r\n    }\r\n    hide() {\r\n      if (isDisabled(this._element) || !this._isShown()) {\r\n        return;\r\n      }\r\n      const relatedTarget = {\r\n        relatedTarget: this._element\r\n      };\r\n      this._completeHide(relatedTarget);\r\n    }\r\n    dispose() {\r\n      if (this._popper) {\r\n        this._popper.destroy();\r\n      }\r\n      super.dispose();\r\n    }\r\n    update() {\r\n      this._inNavbar = this._detectNavbar();\r\n      if (this._popper) {\r\n        this._popper.update();\r\n      }\r\n    }\r\n\r\n    // Private\r\n    _completeHide(relatedTarget) {\r\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$5, relatedTarget);\r\n      if (hideEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n\r\n      // If this is a touch-enabled device we remove the extra\r\n      // empty mouseover listeners we added for iOS support\r\n      if ('ontouchstart' in document.documentElement) {\r\n        for (const element of [].concat(...document.body.children)) {\r\n          EventHandler.off(element, 'mouseover', noop);\r\n        }\r\n      }\r\n      if (this._popper) {\r\n        this._popper.destroy();\r\n      }\r\n      this._menu.classList.remove(CLASS_NAME_SHOW$6);\r\n      this._element.classList.remove(CLASS_NAME_SHOW$6);\r\n      this._element.setAttribute('aria-expanded', 'false');\r\n      Manipulator.removeDataAttribute(this._menu, 'popper');\r\n      EventHandler.trigger(this._element, EVENT_HIDDEN$5, relatedTarget);\r\n\r\n      // Explicitly return focus to the trigger element\r\n      this._element.focus();\r\n    }\r\n    _getConfig(config) {\r\n      config = super._getConfig(config);\r\n      if (typeof config.reference === 'object' && !isElement$1(config.reference) && typeof config.reference.getBoundingClientRect !== 'function') {\r\n        // Popper virtual elements require a getBoundingClientRect method\r\n        throw new TypeError(`${NAME$a.toUpperCase()}: Option \"reference\" provided type \"object\" without a required \"getBoundingClientRect\" method.`);\r\n      }\r\n      return config;\r\n    }\r\n    _createPopper() {\r\n      if (typeof Popper === 'undefined') {\r\n        throw new TypeError('Bootstrap\\'s dropdowns require Popper (https://popper.js.org/docs/v2/)');\r\n      }\r\n      let referenceElement = this._element;\r\n      if (this._config.reference === 'parent') {\r\n        referenceElement = this._parent;\r\n      } else if (isElement$1(this._config.reference)) {\r\n        referenceElement = getElement(this._config.reference);\r\n      } else if (typeof this._config.reference === 'object') {\r\n        referenceElement = this._config.reference;\r\n      }\r\n      const popperConfig = this._getPopperConfig();\r\n      this._popper = createPopper(referenceElement, this._menu, popperConfig);\r\n    }\r\n    _isShown() {\r\n      return this._menu.classList.contains(CLASS_NAME_SHOW$6);\r\n    }\r\n    _getPlacement() {\r\n      const parentDropdown = this._parent;\r\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPEND)) {\r\n        return PLACEMENT_RIGHT;\r\n      }\r\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPSTART)) {\r\n        return PLACEMENT_LEFT;\r\n      }\r\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP_CENTER)) {\r\n        return PLACEMENT_TOPCENTER;\r\n      }\r\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPDOWN_CENTER)) {\r\n        return PLACEMENT_BOTTOMCENTER;\r\n      }\r\n\r\n      // We need to trim the value because custom properties can also include spaces\r\n      const isEnd = getComputedStyle(this._menu).getPropertyValue('--bs-position').trim() === 'end';\r\n      if (parentDropdown.classList.contains(CLASS_NAME_DROPUP)) {\r\n        return isEnd ? PLACEMENT_TOPEND : PLACEMENT_TOP;\r\n      }\r\n      return isEnd ? PLACEMENT_BOTTOMEND : PLACEMENT_BOTTOM;\r\n    }\r\n    _detectNavbar() {\r\n      return this._element.closest(SELECTOR_NAVBAR) !== null;\r\n    }\r\n    _getOffset() {\r\n      const {\r\n        offset\r\n      } = this._config;\r\n      if (typeof offset === 'string') {\r\n        return offset.split(',').map(value => Number.parseInt(value, 10));\r\n      }\r\n      if (typeof offset === 'function') {\r\n        return popperData => offset(popperData, this._element);\r\n      }\r\n      return offset;\r\n    }\r\n    _getPopperConfig() {\r\n      const defaultBsPopperConfig = {\r\n        placement: this._getPlacement(),\r\n        modifiers: [{\r\n          name: 'preventOverflow',\r\n          options: {\r\n            boundary: this._config.boundary\r\n          }\r\n        }, {\r\n          name: 'offset',\r\n          options: {\r\n            offset: this._getOffset()\r\n          }\r\n        }]\r\n      };\r\n\r\n      // Disable Popper if we have a static display or Dropdown is in Navbar\r\n      if (this._inNavbar || this._config.display === 'static') {\r\n        Manipulator.setDataAttribute(this._menu, 'popper', 'static'); // TODO: v6 remove\r\n        defaultBsPopperConfig.modifiers = [{\r\n          name: 'applyStyles',\r\n          enabled: false\r\n        }];\r\n      }\r\n      return {\r\n        ...defaultBsPopperConfig,\r\n        ...execute(this._config.popperConfig, [undefined, defaultBsPopperConfig])\r\n      };\r\n    }\r\n    _selectMenuItem({\r\n      key,\r\n      target\r\n    }) {\r\n      const items = SelectorEngine.find(SELECTOR_VISIBLE_ITEMS, this._menu).filter(element => isVisible(element));\r\n      if (!items.length) {\r\n        return;\r\n      }\r\n\r\n      // if target isn't included in items (e.g. when expanding the dropdown)\r\n      // allow cycling to get the last item in case key equals ARROW_UP_KEY\r\n      getNextActiveElement(items, target, key === ARROW_DOWN_KEY$1, !items.includes(target)).focus();\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = Dropdown.getOrCreateInstance(this, config);\r\n        if (typeof config !== 'string') {\r\n          return;\r\n        }\r\n        if (typeof data[config] === 'undefined') {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n        data[config]();\r\n      });\r\n    }\r\n    static clearMenus(event) {\r\n      if (event.button === RIGHT_MOUSE_BUTTON || event.type === 'keyup' && event.key !== TAB_KEY$1) {\r\n        return;\r\n      }\r\n      const openToggles = SelectorEngine.find(SELECTOR_DATA_TOGGLE_SHOWN);\r\n      for (const toggle of openToggles) {\r\n        const context = Dropdown.getInstance(toggle);\r\n        if (!context || context._config.autoClose === false) {\r\n          continue;\r\n        }\r\n        const composedPath = event.composedPath();\r\n        const isMenuTarget = composedPath.includes(context._menu);\r\n        if (composedPath.includes(context._element) || context._config.autoClose === 'inside' && !isMenuTarget || context._config.autoClose === 'outside' && isMenuTarget) {\r\n          continue;\r\n        }\r\n\r\n        // Tab navigation through the dropdown menu or events from contained inputs shouldn't close the menu\r\n        if (context._menu.contains(event.target) && (event.type === 'keyup' && event.key === TAB_KEY$1 || /input|select|option|textarea|form/i.test(event.target.tagName))) {\r\n          continue;\r\n        }\r\n        const relatedTarget = {\r\n          relatedTarget: context._element\r\n        };\r\n        if (event.type === 'click') {\r\n          relatedTarget.clickEvent = event;\r\n        }\r\n        context._completeHide(relatedTarget);\r\n      }\r\n    }\r\n    static dataApiKeydownHandler(event) {\r\n      // If not an UP | DOWN | ESCAPE key => not a dropdown command\r\n      // If input/textarea && if key is other than ESCAPE => not a dropdown command\r\n\r\n      const isInput = /input|textarea/i.test(event.target.tagName);\r\n      const isEscapeEvent = event.key === ESCAPE_KEY$2;\r\n      const isUpOrDownEvent = [ARROW_UP_KEY$1, ARROW_DOWN_KEY$1].includes(event.key);\r\n      if (!isUpOrDownEvent && !isEscapeEvent) {\r\n        return;\r\n      }\r\n      if (isInput && !isEscapeEvent) {\r\n        return;\r\n      }\r\n      event.preventDefault();\r\n\r\n      // TODO: v6 revert #37011 & change markup https://getbootstrap.com/docs/5.3/forms/input-group/\r\n      const getToggleButton = this.matches(SELECTOR_DATA_TOGGLE$3) ? this : SelectorEngine.prev(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.next(this, SELECTOR_DATA_TOGGLE$3)[0] || SelectorEngine.findOne(SELECTOR_DATA_TOGGLE$3, event.delegateTarget.parentNode);\r\n      const instance = Dropdown.getOrCreateInstance(getToggleButton);\r\n      if (isUpOrDownEvent) {\r\n        event.stopPropagation();\r\n        instance.show();\r\n        instance._selectMenuItem(event);\r\n        return;\r\n      }\r\n      if (instance._isShown()) {\r\n        // else is escape and we check if it is shown\r\n        event.stopPropagation();\r\n        instance.hide();\r\n        getToggleButton.focus();\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_DATA_TOGGLE$3, Dropdown.dataApiKeydownHandler);\r\n  EventHandler.on(document, EVENT_KEYDOWN_DATA_API, SELECTOR_MENU, Dropdown.dataApiKeydownHandler);\r\n  EventHandler.on(document, EVENT_CLICK_DATA_API$3, Dropdown.clearMenus);\r\n  EventHandler.on(document, EVENT_KEYUP_DATA_API, Dropdown.clearMenus);\r\n  EventHandler.on(document, EVENT_CLICK_DATA_API$3, SELECTOR_DATA_TOGGLE$3, function (event) {\r\n    event.preventDefault();\r\n    Dropdown.getOrCreateInstance(this).toggle();\r\n  });\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Dropdown);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap util/backdrop.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$9 = 'backdrop';\r\n  const CLASS_NAME_FADE$4 = 'fade';\r\n  const CLASS_NAME_SHOW$5 = 'show';\r\n  const EVENT_MOUSEDOWN = `mousedown.bs.${NAME$9}`;\r\n  const Default$8 = {\r\n    className: 'modal-backdrop',\r\n    clickCallback: null,\r\n    isAnimated: false,\r\n    isVisible: true,\r\n    // if false, we use the backdrop helper without adding any element to the dom\r\n    rootElement: 'body' // give the choice to place backdrop under different elements\r\n  };\r\n  const DefaultType$8 = {\r\n    className: 'string',\r\n    clickCallback: '(function|null)',\r\n    isAnimated: 'boolean',\r\n    isVisible: 'boolean',\r\n    rootElement: '(element|string)'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Backdrop extends Config {\r\n    constructor(config) {\r\n      super();\r\n      this._config = this._getConfig(config);\r\n      this._isAppended = false;\r\n      this._element = null;\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$8;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$8;\r\n    }\r\n    static get NAME() {\r\n      return NAME$9;\r\n    }\r\n\r\n    // Public\r\n    show(callback) {\r\n      if (!this._config.isVisible) {\r\n        execute(callback);\r\n        return;\r\n      }\r\n      this._append();\r\n      const element = this._getElement();\r\n      if (this._config.isAnimated) {\r\n        reflow(element);\r\n      }\r\n      element.classList.add(CLASS_NAME_SHOW$5);\r\n      this._emulateAnimation(() => {\r\n        execute(callback);\r\n      });\r\n    }\r\n    hide(callback) {\r\n      if (!this._config.isVisible) {\r\n        execute(callback);\r\n        return;\r\n      }\r\n      this._getElement().classList.remove(CLASS_NAME_SHOW$5);\r\n      this._emulateAnimation(() => {\r\n        this.dispose();\r\n        execute(callback);\r\n      });\r\n    }\r\n    dispose() {\r\n      if (!this._isAppended) {\r\n        return;\r\n      }\r\n      EventHandler.off(this._element, EVENT_MOUSEDOWN);\r\n      this._element.remove();\r\n      this._isAppended = false;\r\n    }\r\n\r\n    // Private\r\n    _getElement() {\r\n      if (!this._element) {\r\n        const backdrop = document.createElement('div');\r\n        backdrop.className = this._config.className;\r\n        if (this._config.isAnimated) {\r\n          backdrop.classList.add(CLASS_NAME_FADE$4);\r\n        }\r\n        this._element = backdrop;\r\n      }\r\n      return this._element;\r\n    }\r\n    _configAfterMerge(config) {\r\n      // use getElement() with the default \"body\" to get a fresh Element on each instantiation\r\n      config.rootElement = getElement(config.rootElement);\r\n      return config;\r\n    }\r\n    _append() {\r\n      if (this._isAppended) {\r\n        return;\r\n      }\r\n      const element = this._getElement();\r\n      this._config.rootElement.append(element);\r\n      EventHandler.on(element, EVENT_MOUSEDOWN, () => {\r\n        execute(this._config.clickCallback);\r\n      });\r\n      this._isAppended = true;\r\n    }\r\n    _emulateAnimation(callback) {\r\n      executeAfterTransition(callback, this._getElement(), this._config.isAnimated);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap util/focustrap.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$8 = 'focustrap';\r\n  const DATA_KEY$5 = 'bs.focustrap';\r\n  const EVENT_KEY$5 = `.${DATA_KEY$5}`;\r\n  const EVENT_FOCUSIN$2 = `focusin${EVENT_KEY$5}`;\r\n  const EVENT_KEYDOWN_TAB = `keydown.tab${EVENT_KEY$5}`;\r\n  const TAB_KEY = 'Tab';\r\n  const TAB_NAV_FORWARD = 'forward';\r\n  const TAB_NAV_BACKWARD = 'backward';\r\n  const Default$7 = {\r\n    autofocus: true,\r\n    trapElement: null // The element to trap focus inside of\r\n  };\r\n  const DefaultType$7 = {\r\n    autofocus: 'boolean',\r\n    trapElement: 'element'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class FocusTrap extends Config {\r\n    constructor(config) {\r\n      super();\r\n      this._config = this._getConfig(config);\r\n      this._isActive = false;\r\n      this._lastTabNavDirection = null;\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$7;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$7;\r\n    }\r\n    static get NAME() {\r\n      return NAME$8;\r\n    }\r\n\r\n    // Public\r\n    activate() {\r\n      if (this._isActive) {\r\n        return;\r\n      }\r\n      if (this._config.autofocus) {\r\n        this._config.trapElement.focus();\r\n      }\r\n      EventHandler.off(document, EVENT_KEY$5); // guard against infinite focus loop\r\n      EventHandler.on(document, EVENT_FOCUSIN$2, event => this._handleFocusin(event));\r\n      EventHandler.on(document, EVENT_KEYDOWN_TAB, event => this._handleKeydown(event));\r\n      this._isActive = true;\r\n    }\r\n    deactivate() {\r\n      if (!this._isActive) {\r\n        return;\r\n      }\r\n      this._isActive = false;\r\n      EventHandler.off(document, EVENT_KEY$5);\r\n    }\r\n\r\n    // Private\r\n    _handleFocusin(event) {\r\n      const {\r\n        trapElement\r\n      } = this._config;\r\n      if (event.target === document || event.target === trapElement || trapElement.contains(event.target)) {\r\n        return;\r\n      }\r\n      const elements = SelectorEngine.focusableChildren(trapElement);\r\n      if (elements.length === 0) {\r\n        trapElement.focus();\r\n      } else if (this._lastTabNavDirection === TAB_NAV_BACKWARD) {\r\n        elements[elements.length - 1].focus();\r\n      } else {\r\n        elements[0].focus();\r\n      }\r\n    }\r\n    _handleKeydown(event) {\r\n      if (event.key !== TAB_KEY) {\r\n        return;\r\n      }\r\n      this._lastTabNavDirection = event.shiftKey ? TAB_NAV_BACKWARD : TAB_NAV_FORWARD;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap util/scrollBar.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const SELECTOR_FIXED_CONTENT = '.fixed-top, .fixed-bottom, .is-fixed, .sticky-top';\r\n  const SELECTOR_STICKY_CONTENT = '.sticky-top';\r\n  const PROPERTY_PADDING = 'padding-right';\r\n  const PROPERTY_MARGIN = 'margin-right';\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class ScrollBarHelper {\r\n    constructor() {\r\n      this._element = document.body;\r\n    }\r\n\r\n    // Public\r\n    getWidth() {\r\n      // https://developer.mozilla.org/en-US/docs/Web/API/Window/innerWidth#usage_notes\r\n      const documentWidth = document.documentElement.clientWidth;\r\n      return Math.abs(window.innerWidth - documentWidth);\r\n    }\r\n    hide() {\r\n      const width = this.getWidth();\r\n      this._disableOverFlow();\r\n      // give padding to element to balance the hidden scrollbar width\r\n      this._setElementAttributes(this._element, PROPERTY_PADDING, calculatedValue => calculatedValue + width);\r\n      // trick: We adjust positive paddingRight and negative marginRight to sticky-top elements to keep showing fullwidth\r\n      this._setElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING, calculatedValue => calculatedValue + width);\r\n      this._setElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN, calculatedValue => calculatedValue - width);\r\n    }\r\n    reset() {\r\n      this._resetElementAttributes(this._element, 'overflow');\r\n      this._resetElementAttributes(this._element, PROPERTY_PADDING);\r\n      this._resetElementAttributes(SELECTOR_FIXED_CONTENT, PROPERTY_PADDING);\r\n      this._resetElementAttributes(SELECTOR_STICKY_CONTENT, PROPERTY_MARGIN);\r\n    }\r\n    isOverflowing() {\r\n      return this.getWidth() > 0;\r\n    }\r\n\r\n    // Private\r\n    _disableOverFlow() {\r\n      this._saveInitialAttribute(this._element, 'overflow');\r\n      this._element.style.overflow = 'hidden';\r\n    }\r\n    _setElementAttributes(selector, styleProperty, callback) {\r\n      const scrollbarWidth = this.getWidth();\r\n      const manipulationCallBack = element => {\r\n        if (element !== this._element && window.innerWidth > element.clientWidth + scrollbarWidth) {\r\n          return;\r\n        }\r\n        this._saveInitialAttribute(element, styleProperty);\r\n        const calculatedValue = window.getComputedStyle(element).getPropertyValue(styleProperty);\r\n        element.style.setProperty(styleProperty, `${callback(Number.parseFloat(calculatedValue))}px`);\r\n      };\r\n      this._applyManipulationCallback(selector, manipulationCallBack);\r\n    }\r\n    _saveInitialAttribute(element, styleProperty) {\r\n      const actualValue = element.style.getPropertyValue(styleProperty);\r\n      if (actualValue) {\r\n        Manipulator.setDataAttribute(element, styleProperty, actualValue);\r\n      }\r\n    }\r\n    _resetElementAttributes(selector, styleProperty) {\r\n      const manipulationCallBack = element => {\r\n        const value = Manipulator.getDataAttribute(element, styleProperty);\r\n        // We only want to remove the property if the value is `null`; the value can also be zero\r\n        if (value === null) {\r\n          element.style.removeProperty(styleProperty);\r\n          return;\r\n        }\r\n        Manipulator.removeDataAttribute(element, styleProperty);\r\n        element.style.setProperty(styleProperty, value);\r\n      };\r\n      this._applyManipulationCallback(selector, manipulationCallBack);\r\n    }\r\n    _applyManipulationCallback(selector, callBack) {\r\n      if (isElement$1(selector)) {\r\n        callBack(selector);\r\n        return;\r\n      }\r\n      for (const sel of SelectorEngine.find(selector, this._element)) {\r\n        callBack(sel);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap modal.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$7 = 'modal';\r\n  const DATA_KEY$4 = 'bs.modal';\r\n  const EVENT_KEY$4 = `.${DATA_KEY$4}`;\r\n  const DATA_API_KEY$2 = '.data-api';\r\n  const ESCAPE_KEY$1 = 'Escape';\r\n  const EVENT_HIDE$4 = `hide${EVENT_KEY$4}`;\r\n  const EVENT_HIDE_PREVENTED$1 = `hidePrevented${EVENT_KEY$4}`;\r\n  const EVENT_HIDDEN$4 = `hidden${EVENT_KEY$4}`;\r\n  const EVENT_SHOW$4 = `show${EVENT_KEY$4}`;\r\n  const EVENT_SHOWN$4 = `shown${EVENT_KEY$4}`;\r\n  const EVENT_RESIZE$1 = `resize${EVENT_KEY$4}`;\r\n  const EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY$4}`;\r\n  const EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY$4}`;\r\n  const EVENT_KEYDOWN_DISMISS$1 = `keydown.dismiss${EVENT_KEY$4}`;\r\n  const EVENT_CLICK_DATA_API$2 = `click${EVENT_KEY$4}${DATA_API_KEY$2}`;\r\n  const CLASS_NAME_OPEN = 'modal-open';\r\n  const CLASS_NAME_FADE$3 = 'fade';\r\n  const CLASS_NAME_SHOW$4 = 'show';\r\n  const CLASS_NAME_STATIC = 'modal-static';\r\n  const OPEN_SELECTOR$1 = '.modal.show';\r\n  const SELECTOR_DIALOG = '.modal-dialog';\r\n  const SELECTOR_MODAL_BODY = '.modal-body';\r\n  const SELECTOR_DATA_TOGGLE$2 = '[data-bs-toggle=\"modal\"]';\r\n  const Default$6 = {\r\n    backdrop: true,\r\n    focus: true,\r\n    keyboard: true\r\n  };\r\n  const DefaultType$6 = {\r\n    backdrop: '(boolean|string)',\r\n    focus: 'boolean',\r\n    keyboard: 'boolean'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Modal extends BaseComponent {\r\n    constructor(element, config) {\r\n      super(element, config);\r\n      this._dialog = SelectorEngine.findOne(SELECTOR_DIALOG, this._element);\r\n      this._backdrop = this._initializeBackDrop();\r\n      this._focustrap = this._initializeFocusTrap();\r\n      this._isShown = false;\r\n      this._isTransitioning = false;\r\n      this._scrollBar = new ScrollBarHelper();\r\n      this._addEventListeners();\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$6;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$6;\r\n    }\r\n    static get NAME() {\r\n      return NAME$7;\r\n    }\r\n\r\n    // Public\r\n    toggle(relatedTarget) {\r\n      return this._isShown ? this.hide() : this.show(relatedTarget);\r\n    }\r\n    show(relatedTarget) {\r\n      if (this._isShown || this._isTransitioning) {\r\n        return;\r\n      }\r\n      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$4, {\r\n        relatedTarget\r\n      });\r\n      if (showEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      this._isShown = true;\r\n      this._isTransitioning = true;\r\n      this._scrollBar.hide();\r\n      document.body.classList.add(CLASS_NAME_OPEN);\r\n      this._adjustDialog();\r\n      this._backdrop.show(() => this._showElement(relatedTarget));\r\n    }\r\n    hide() {\r\n      if (!this._isShown || this._isTransitioning) {\r\n        return;\r\n      }\r\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$4);\r\n      if (hideEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      this._isShown = false;\r\n      this._isTransitioning = true;\r\n      this._focustrap.deactivate();\r\n      this._element.classList.remove(CLASS_NAME_SHOW$4);\r\n      this._queueCallback(() => this._hideModal(), this._element, this._isAnimated());\r\n    }\r\n    dispose() {\r\n      EventHandler.off(window, EVENT_KEY$4);\r\n      EventHandler.off(this._dialog, EVENT_KEY$4);\r\n      this._backdrop.dispose();\r\n      this._focustrap.deactivate();\r\n      super.dispose();\r\n    }\r\n    handleUpdate() {\r\n      this._adjustDialog();\r\n    }\r\n\r\n    // Private\r\n    _initializeBackDrop() {\r\n      return new Backdrop({\r\n        isVisible: Boolean(this._config.backdrop),\r\n        // 'static' option will be translated to true, and booleans will keep their value,\r\n        isAnimated: this._isAnimated()\r\n      });\r\n    }\r\n    _initializeFocusTrap() {\r\n      return new FocusTrap({\r\n        trapElement: this._element\r\n      });\r\n    }\r\n    _showElement(relatedTarget) {\r\n      // try to append dynamic modal\r\n      if (!document.body.contains(this._element)) {\r\n        document.body.append(this._element);\r\n      }\r\n      this._element.style.display = 'block';\r\n      this._element.removeAttribute('aria-hidden');\r\n      this._element.setAttribute('aria-modal', true);\r\n      this._element.setAttribute('role', 'dialog');\r\n      this._element.scrollTop = 0;\r\n      const modalBody = SelectorEngine.findOne(SELECTOR_MODAL_BODY, this._dialog);\r\n      if (modalBody) {\r\n        modalBody.scrollTop = 0;\r\n      }\r\n      reflow(this._element);\r\n      this._element.classList.add(CLASS_NAME_SHOW$4);\r\n      const transitionComplete = () => {\r\n        if (this._config.focus) {\r\n          this._focustrap.activate();\r\n        }\r\n        this._isTransitioning = false;\r\n        EventHandler.trigger(this._element, EVENT_SHOWN$4, {\r\n          relatedTarget\r\n        });\r\n      };\r\n      this._queueCallback(transitionComplete, this._dialog, this._isAnimated());\r\n    }\r\n    _addEventListeners() {\r\n      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS$1, event => {\r\n        if (event.key !== ESCAPE_KEY$1) {\r\n          return;\r\n        }\r\n        if (this._config.keyboard) {\r\n          this.hide();\r\n          return;\r\n        }\r\n        this._triggerBackdropTransition();\r\n      });\r\n      EventHandler.on(window, EVENT_RESIZE$1, () => {\r\n        if (this._isShown && !this._isTransitioning) {\r\n          this._adjustDialog();\r\n        }\r\n      });\r\n      EventHandler.on(this._element, EVENT_MOUSEDOWN_DISMISS, event => {\r\n        // a bad trick to segregate clicks that may start inside dialog but end outside, and avoid listen to scrollbar clicks\r\n        EventHandler.one(this._element, EVENT_CLICK_DISMISS, event2 => {\r\n          if (this._element !== event.target || this._element !== event2.target) {\r\n            return;\r\n          }\r\n          if (this._config.backdrop === 'static') {\r\n            this._triggerBackdropTransition();\r\n            return;\r\n          }\r\n          if (this._config.backdrop) {\r\n            this.hide();\r\n          }\r\n        });\r\n      });\r\n    }\r\n    _hideModal() {\r\n      this._element.style.display = 'none';\r\n      this._element.setAttribute('aria-hidden', true);\r\n      this._element.removeAttribute('aria-modal');\r\n      this._element.removeAttribute('role');\r\n      this._isTransitioning = false;\r\n      this._backdrop.hide(() => {\r\n        document.body.classList.remove(CLASS_NAME_OPEN);\r\n        this._resetAdjustments();\r\n        this._scrollBar.reset();\r\n        EventHandler.trigger(this._element, EVENT_HIDDEN$4);\r\n      });\r\n    }\r\n    _isAnimated() {\r\n      return this._element.classList.contains(CLASS_NAME_FADE$3);\r\n    }\r\n    _triggerBackdropTransition() {\r\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED$1);\r\n      if (hideEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\r\n      const initialOverflowY = this._element.style.overflowY;\r\n      // return if the following background transition hasn't yet completed\r\n      if (initialOverflowY === 'hidden' || this._element.classList.contains(CLASS_NAME_STATIC)) {\r\n        return;\r\n      }\r\n      if (!isModalOverflowing) {\r\n        this._element.style.overflowY = 'hidden';\r\n      }\r\n      this._element.classList.add(CLASS_NAME_STATIC);\r\n      this._queueCallback(() => {\r\n        this._element.classList.remove(CLASS_NAME_STATIC);\r\n        this._queueCallback(() => {\r\n          this._element.style.overflowY = initialOverflowY;\r\n        }, this._dialog);\r\n      }, this._dialog);\r\n      this._element.focus();\r\n    }\r\n\r\n    /**\r\n     * The following methods are used to handle overflowing modals\r\n     */\r\n\r\n    _adjustDialog() {\r\n      const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;\r\n      const scrollbarWidth = this._scrollBar.getWidth();\r\n      const isBodyOverflowing = scrollbarWidth > 0;\r\n      if (isBodyOverflowing && !isModalOverflowing) {\r\n        const property = isRTL() ? 'paddingLeft' : 'paddingRight';\r\n        this._element.style[property] = `${scrollbarWidth}px`;\r\n      }\r\n      if (!isBodyOverflowing && isModalOverflowing) {\r\n        const property = isRTL() ? 'paddingRight' : 'paddingLeft';\r\n        this._element.style[property] = `${scrollbarWidth}px`;\r\n      }\r\n    }\r\n    _resetAdjustments() {\r\n      this._element.style.paddingLeft = '';\r\n      this._element.style.paddingRight = '';\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config, relatedTarget) {\r\n      return this.each(function () {\r\n        const data = Modal.getOrCreateInstance(this, config);\r\n        if (typeof config !== 'string') {\r\n          return;\r\n        }\r\n        if (typeof data[config] === 'undefined') {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n        data[config](relatedTarget);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  EventHandler.on(document, EVENT_CLICK_DATA_API$2, SELECTOR_DATA_TOGGLE$2, function (event) {\r\n    const target = SelectorEngine.getElementFromSelector(this);\r\n    if (['A', 'AREA'].includes(this.tagName)) {\r\n      event.preventDefault();\r\n    }\r\n    EventHandler.one(target, EVENT_SHOW$4, showEvent => {\r\n      if (showEvent.defaultPrevented) {\r\n        // only register focus restorer if modal will actually get shown\r\n        return;\r\n      }\r\n      EventHandler.one(target, EVENT_HIDDEN$4, () => {\r\n        if (isVisible(this)) {\r\n          this.focus();\r\n        }\r\n      });\r\n    });\r\n\r\n    // avoid conflict when clicking modal toggler while another one is open\r\n    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR$1);\r\n    if (alreadyOpen) {\r\n      Modal.getInstance(alreadyOpen).hide();\r\n    }\r\n    const data = Modal.getOrCreateInstance(target);\r\n    data.toggle(this);\r\n  });\r\n  enableDismissTrigger(Modal);\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Modal);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap offcanvas.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$6 = 'offcanvas';\r\n  const DATA_KEY$3 = 'bs.offcanvas';\r\n  const EVENT_KEY$3 = `.${DATA_KEY$3}`;\r\n  const DATA_API_KEY$1 = '.data-api';\r\n  const EVENT_LOAD_DATA_API$2 = `load${EVENT_KEY$3}${DATA_API_KEY$1}`;\r\n  const ESCAPE_KEY = 'Escape';\r\n  const CLASS_NAME_SHOW$3 = 'show';\r\n  const CLASS_NAME_SHOWING$1 = 'showing';\r\n  const CLASS_NAME_HIDING = 'hiding';\r\n  const CLASS_NAME_BACKDROP = 'offcanvas-backdrop';\r\n  const OPEN_SELECTOR = '.offcanvas.show';\r\n  const EVENT_SHOW$3 = `show${EVENT_KEY$3}`;\r\n  const EVENT_SHOWN$3 = `shown${EVENT_KEY$3}`;\r\n  const EVENT_HIDE$3 = `hide${EVENT_KEY$3}`;\r\n  const EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY$3}`;\r\n  const EVENT_HIDDEN$3 = `hidden${EVENT_KEY$3}`;\r\n  const EVENT_RESIZE = `resize${EVENT_KEY$3}`;\r\n  const EVENT_CLICK_DATA_API$1 = `click${EVENT_KEY$3}${DATA_API_KEY$1}`;\r\n  const EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY$3}`;\r\n  const SELECTOR_DATA_TOGGLE$1 = '[data-bs-toggle=\"offcanvas\"]';\r\n  const Default$5 = {\r\n    backdrop: true,\r\n    keyboard: true,\r\n    scroll: false\r\n  };\r\n  const DefaultType$5 = {\r\n    backdrop: '(boolean|string)',\r\n    keyboard: 'boolean',\r\n    scroll: 'boolean'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Offcanvas extends BaseComponent {\r\n    constructor(element, config) {\r\n      super(element, config);\r\n      this._isShown = false;\r\n      this._backdrop = this._initializeBackDrop();\r\n      this._focustrap = this._initializeFocusTrap();\r\n      this._addEventListeners();\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$5;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$5;\r\n    }\r\n    static get NAME() {\r\n      return NAME$6;\r\n    }\r\n\r\n    // Public\r\n    toggle(relatedTarget) {\r\n      return this._isShown ? this.hide() : this.show(relatedTarget);\r\n    }\r\n    show(relatedTarget) {\r\n      if (this._isShown) {\r\n        return;\r\n      }\r\n      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW$3, {\r\n        relatedTarget\r\n      });\r\n      if (showEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      this._isShown = true;\r\n      this._backdrop.show();\r\n      if (!this._config.scroll) {\r\n        new ScrollBarHelper().hide();\r\n      }\r\n      this._element.setAttribute('aria-modal', true);\r\n      this._element.setAttribute('role', 'dialog');\r\n      this._element.classList.add(CLASS_NAME_SHOWING$1);\r\n      const completeCallBack = () => {\r\n        if (!this._config.scroll || this._config.backdrop) {\r\n          this._focustrap.activate();\r\n        }\r\n        this._element.classList.add(CLASS_NAME_SHOW$3);\r\n        this._element.classList.remove(CLASS_NAME_SHOWING$1);\r\n        EventHandler.trigger(this._element, EVENT_SHOWN$3, {\r\n          relatedTarget\r\n        });\r\n      };\r\n      this._queueCallback(completeCallBack, this._element, true);\r\n    }\r\n    hide() {\r\n      if (!this._isShown) {\r\n        return;\r\n      }\r\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE$3);\r\n      if (hideEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      this._focustrap.deactivate();\r\n      this._element.blur();\r\n      this._isShown = false;\r\n      this._element.classList.add(CLASS_NAME_HIDING);\r\n      this._backdrop.hide();\r\n      const completeCallback = () => {\r\n        this._element.classList.remove(CLASS_NAME_SHOW$3, CLASS_NAME_HIDING);\r\n        this._element.removeAttribute('aria-modal');\r\n        this._element.removeAttribute('role');\r\n        if (!this._config.scroll) {\r\n          new ScrollBarHelper().reset();\r\n        }\r\n        EventHandler.trigger(this._element, EVENT_HIDDEN$3);\r\n      };\r\n      this._queueCallback(completeCallback, this._element, true);\r\n    }\r\n    dispose() {\r\n      this._backdrop.dispose();\r\n      this._focustrap.deactivate();\r\n      super.dispose();\r\n    }\r\n\r\n    // Private\r\n    _initializeBackDrop() {\r\n      const clickCallback = () => {\r\n        if (this._config.backdrop === 'static') {\r\n          EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\r\n          return;\r\n        }\r\n        this.hide();\r\n      };\r\n\r\n      // 'static' option will be translated to true, and booleans will keep their value\r\n      const isVisible = Boolean(this._config.backdrop);\r\n      return new Backdrop({\r\n        className: CLASS_NAME_BACKDROP,\r\n        isVisible,\r\n        isAnimated: true,\r\n        rootElement: this._element.parentNode,\r\n        clickCallback: isVisible ? clickCallback : null\r\n      });\r\n    }\r\n    _initializeFocusTrap() {\r\n      return new FocusTrap({\r\n        trapElement: this._element\r\n      });\r\n    }\r\n    _addEventListeners() {\r\n      EventHandler.on(this._element, EVENT_KEYDOWN_DISMISS, event => {\r\n        if (event.key !== ESCAPE_KEY) {\r\n          return;\r\n        }\r\n        if (this._config.keyboard) {\r\n          this.hide();\r\n          return;\r\n        }\r\n        EventHandler.trigger(this._element, EVENT_HIDE_PREVENTED);\r\n      });\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = Offcanvas.getOrCreateInstance(this, config);\r\n        if (typeof config !== 'string') {\r\n          return;\r\n        }\r\n        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n        data[config](this);\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  EventHandler.on(document, EVENT_CLICK_DATA_API$1, SELECTOR_DATA_TOGGLE$1, function (event) {\r\n    const target = SelectorEngine.getElementFromSelector(this);\r\n    if (['A', 'AREA'].includes(this.tagName)) {\r\n      event.preventDefault();\r\n    }\r\n    if (isDisabled(this)) {\r\n      return;\r\n    }\r\n    EventHandler.one(target, EVENT_HIDDEN$3, () => {\r\n      // focus on trigger when it is closed\r\n      if (isVisible(this)) {\r\n        this.focus();\r\n      }\r\n    });\r\n\r\n    // avoid conflict when clicking a toggler of an offcanvas, while another is open\r\n    const alreadyOpen = SelectorEngine.findOne(OPEN_SELECTOR);\r\n    if (alreadyOpen && alreadyOpen !== target) {\r\n      Offcanvas.getInstance(alreadyOpen).hide();\r\n    }\r\n    const data = Offcanvas.getOrCreateInstance(target);\r\n    data.toggle(this);\r\n  });\r\n  EventHandler.on(window, EVENT_LOAD_DATA_API$2, () => {\r\n    for (const selector of SelectorEngine.find(OPEN_SELECTOR)) {\r\n      Offcanvas.getOrCreateInstance(selector).show();\r\n    }\r\n  });\r\n  EventHandler.on(window, EVENT_RESIZE, () => {\r\n    for (const element of SelectorEngine.find('[aria-modal][class*=show][class*=offcanvas-]')) {\r\n      if (getComputedStyle(element).position !== 'fixed') {\r\n        Offcanvas.getOrCreateInstance(element).hide();\r\n      }\r\n    }\r\n  });\r\n  enableDismissTrigger(Offcanvas);\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Offcanvas);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap util/sanitizer.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n  // js-docs-start allow-list\r\n  const ARIA_ATTRIBUTE_PATTERN = /^aria-[\\w-]*$/i;\r\n  const DefaultAllowlist = {\r\n    // Global attributes allowed on any supplied element below.\r\n    '*': ['class', 'dir', 'id', 'lang', 'role', ARIA_ATTRIBUTE_PATTERN],\r\n    a: ['target', 'href', 'title', 'rel'],\r\n    area: [],\r\n    b: [],\r\n    br: [],\r\n    col: [],\r\n    code: [],\r\n    dd: [],\r\n    div: [],\r\n    dl: [],\r\n    dt: [],\r\n    em: [],\r\n    hr: [],\r\n    h1: [],\r\n    h2: [],\r\n    h3: [],\r\n    h4: [],\r\n    h5: [],\r\n    h6: [],\r\n    i: [],\r\n    img: ['src', 'srcset', 'alt', 'title', 'width', 'height'],\r\n    li: [],\r\n    ol: [],\r\n    p: [],\r\n    pre: [],\r\n    s: [],\r\n    small: [],\r\n    span: [],\r\n    sub: [],\r\n    sup: [],\r\n    strong: [],\r\n    u: [],\r\n    ul: []\r\n  };\r\n  // js-docs-end allow-list\r\n\r\n  const uriAttributes = new Set(['background', 'cite', 'href', 'itemtype', 'longdesc', 'poster', 'src', 'xlink:href']);\r\n\r\n  /**\r\n   * A pattern that recognizes URLs that are safe wrt. XSS in URL navigation\r\n   * contexts.\r\n   *\r\n   * Shout-out to Angular https://github.com/angular/angular/blob/15.2.8/packages/core/src/sanitization/url_sanitizer.ts#L38\r\n   */\r\n  const SAFE_URL_PATTERN = /^(?!javascript:)(?:[a-z0-9+.-]+:|[^&:/?#]*(?:[/?#]|$))/i;\r\n  const allowedAttribute = (attribute, allowedAttributeList) => {\r\n    const attributeName = attribute.nodeName.toLowerCase();\r\n    if (allowedAttributeList.includes(attributeName)) {\r\n      if (uriAttributes.has(attributeName)) {\r\n        return Boolean(SAFE_URL_PATTERN.test(attribute.nodeValue));\r\n      }\r\n      return true;\r\n    }\r\n\r\n    // Check if a regular expression validates the attribute.\r\n    return allowedAttributeList.filter(attributeRegex => attributeRegex instanceof RegExp).some(regex => regex.test(attributeName));\r\n  };\r\n  function sanitizeHtml(unsafeHtml, allowList, sanitizeFunction) {\r\n    if (!unsafeHtml.length) {\r\n      return unsafeHtml;\r\n    }\r\n    if (sanitizeFunction && typeof sanitizeFunction === 'function') {\r\n      return sanitizeFunction(unsafeHtml);\r\n    }\r\n    const domParser = new window.DOMParser();\r\n    const createdDocument = domParser.parseFromString(unsafeHtml, 'text/html');\r\n    const elements = [].concat(...createdDocument.body.querySelectorAll('*'));\r\n    for (const element of elements) {\r\n      const elementName = element.nodeName.toLowerCase();\r\n      if (!Object.keys(allowList).includes(elementName)) {\r\n        element.remove();\r\n        continue;\r\n      }\r\n      const attributeList = [].concat(...element.attributes);\r\n      const allowedAttributes = [].concat(allowList['*'] || [], allowList[elementName] || []);\r\n      for (const attribute of attributeList) {\r\n        if (!allowedAttribute(attribute, allowedAttributes)) {\r\n          element.removeAttribute(attribute.nodeName);\r\n        }\r\n      }\r\n    }\r\n    return createdDocument.body.innerHTML;\r\n  }\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap util/template-factory.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$5 = 'TemplateFactory';\r\n  const Default$4 = {\r\n    allowList: DefaultAllowlist,\r\n    content: {},\r\n    // { selector : text ,  selector2 : text2 , }\r\n    extraClass: '',\r\n    html: false,\r\n    sanitize: true,\r\n    sanitizeFn: null,\r\n    template: '<div></div>'\r\n  };\r\n  const DefaultType$4 = {\r\n    allowList: 'object',\r\n    content: 'object',\r\n    extraClass: '(string|function)',\r\n    html: 'boolean',\r\n    sanitize: 'boolean',\r\n    sanitizeFn: '(null|function)',\r\n    template: 'string'\r\n  };\r\n  const DefaultContentType = {\r\n    entry: '(string|element|function|null)',\r\n    selector: '(string|element)'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class TemplateFactory extends Config {\r\n    constructor(config) {\r\n      super();\r\n      this._config = this._getConfig(config);\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$4;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$4;\r\n    }\r\n    static get NAME() {\r\n      return NAME$5;\r\n    }\r\n\r\n    // Public\r\n    getContent() {\r\n      return Object.values(this._config.content).map(config => this._resolvePossibleFunction(config)).filter(Boolean);\r\n    }\r\n    hasContent() {\r\n      return this.getContent().length > 0;\r\n    }\r\n    changeContent(content) {\r\n      this._checkContent(content);\r\n      this._config.content = {\r\n        ...this._config.content,\r\n        ...content\r\n      };\r\n      return this;\r\n    }\r\n    toHtml() {\r\n      const templateWrapper = document.createElement('div');\r\n      templateWrapper.innerHTML = this._maybeSanitize(this._config.template);\r\n      for (const [selector, text] of Object.entries(this._config.content)) {\r\n        this._setContent(templateWrapper, text, selector);\r\n      }\r\n      const template = templateWrapper.children[0];\r\n      const extraClass = this._resolvePossibleFunction(this._config.extraClass);\r\n      if (extraClass) {\r\n        template.classList.add(...extraClass.split(' '));\r\n      }\r\n      return template;\r\n    }\r\n\r\n    // Private\r\n    _typeCheckConfig(config) {\r\n      super._typeCheckConfig(config);\r\n      this._checkContent(config.content);\r\n    }\r\n    _checkContent(arg) {\r\n      for (const [selector, content] of Object.entries(arg)) {\r\n        super._typeCheckConfig({\r\n          selector,\r\n          entry: content\r\n        }, DefaultContentType);\r\n      }\r\n    }\r\n    _setContent(template, content, selector) {\r\n      const templateElement = SelectorEngine.findOne(selector, template);\r\n      if (!templateElement) {\r\n        return;\r\n      }\r\n      content = this._resolvePossibleFunction(content);\r\n      if (!content) {\r\n        templateElement.remove();\r\n        return;\r\n      }\r\n      if (isElement$1(content)) {\r\n        this._putElementInTemplate(getElement(content), templateElement);\r\n        return;\r\n      }\r\n      if (this._config.html) {\r\n        templateElement.innerHTML = this._maybeSanitize(content);\r\n        return;\r\n      }\r\n      templateElement.textContent = content;\r\n    }\r\n    _maybeSanitize(arg) {\r\n      return this._config.sanitize ? sanitizeHtml(arg, this._config.allowList, this._config.sanitizeFn) : arg;\r\n    }\r\n    _resolvePossibleFunction(arg) {\r\n      return execute(arg, [undefined, this]);\r\n    }\r\n    _putElementInTemplate(element, templateElement) {\r\n      if (this._config.html) {\r\n        templateElement.innerHTML = '';\r\n        templateElement.append(element);\r\n        return;\r\n      }\r\n      templateElement.textContent = element.textContent;\r\n    }\r\n  }\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap tooltip.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$4 = 'tooltip';\r\n  const DISALLOWED_ATTRIBUTES = new Set(['sanitize', 'allowList', 'sanitizeFn']);\r\n  const CLASS_NAME_FADE$2 = 'fade';\r\n  const CLASS_NAME_MODAL = 'modal';\r\n  const CLASS_NAME_SHOW$2 = 'show';\r\n  const SELECTOR_TOOLTIP_INNER = '.tooltip-inner';\r\n  const SELECTOR_MODAL = `.${CLASS_NAME_MODAL}`;\r\n  const EVENT_MODAL_HIDE = 'hide.bs.modal';\r\n  const TRIGGER_HOVER = 'hover';\r\n  const TRIGGER_FOCUS = 'focus';\r\n  const TRIGGER_CLICK = 'click';\r\n  const TRIGGER_MANUAL = 'manual';\r\n  const EVENT_HIDE$2 = 'hide';\r\n  const EVENT_HIDDEN$2 = 'hidden';\r\n  const EVENT_SHOW$2 = 'show';\r\n  const EVENT_SHOWN$2 = 'shown';\r\n  const EVENT_INSERTED = 'inserted';\r\n  const EVENT_CLICK$1 = 'click';\r\n  const EVENT_FOCUSIN$1 = 'focusin';\r\n  const EVENT_FOCUSOUT$1 = 'focusout';\r\n  const EVENT_MOUSEENTER = 'mouseenter';\r\n  const EVENT_MOUSELEAVE = 'mouseleave';\r\n  const AttachmentMap = {\r\n    AUTO: 'auto',\r\n    TOP: 'top',\r\n    RIGHT: isRTL() ? 'left' : 'right',\r\n    BOTTOM: 'bottom',\r\n    LEFT: isRTL() ? 'right' : 'left'\r\n  };\r\n  const Default$3 = {\r\n    allowList: DefaultAllowlist,\r\n    animation: true,\r\n    boundary: 'clippingParents',\r\n    container: false,\r\n    customClass: '',\r\n    delay: 0,\r\n    fallbackPlacements: ['top', 'right', 'bottom', 'left'],\r\n    html: false,\r\n    offset: [0, 6],\r\n    placement: 'top',\r\n    popperConfig: null,\r\n    sanitize: true,\r\n    sanitizeFn: null,\r\n    selector: false,\r\n    template: '<div class=\"tooltip\" role=\"tooltip\">' + '<div class=\"tooltip-arrow\"></div>' + '<div class=\"tooltip-inner\"></div>' + '</div>',\r\n    title: '',\r\n    trigger: 'hover focus'\r\n  };\r\n  const DefaultType$3 = {\r\n    allowList: 'object',\r\n    animation: 'boolean',\r\n    boundary: '(string|element)',\r\n    container: '(string|element|boolean)',\r\n    customClass: '(string|function)',\r\n    delay: '(number|object)',\r\n    fallbackPlacements: 'array',\r\n    html: 'boolean',\r\n    offset: '(array|string|function)',\r\n    placement: '(string|function)',\r\n    popperConfig: '(null|object|function)',\r\n    sanitize: 'boolean',\r\n    sanitizeFn: '(null|function)',\r\n    selector: '(string|boolean)',\r\n    template: 'string',\r\n    title: '(string|element|function)',\r\n    trigger: 'string'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Tooltip extends BaseComponent {\r\n    constructor(element, config) {\r\n      if (typeof Popper === 'undefined') {\r\n        throw new TypeError('Bootstrap\\'s tooltips require Popper (https://popper.js.org/docs/v2/)');\r\n      }\r\n      super(element, config);\r\n\r\n      // Private\r\n      this._isEnabled = true;\r\n      this._timeout = 0;\r\n      this._isHovered = null;\r\n      this._activeTrigger = {};\r\n      this._popper = null;\r\n      this._templateFactory = null;\r\n      this._newContent = null;\r\n\r\n      // Protected\r\n      this.tip = null;\r\n      this._setListeners();\r\n      if (!this._config.selector) {\r\n        this._fixTitle();\r\n      }\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$3;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$3;\r\n    }\r\n    static get NAME() {\r\n      return NAME$4;\r\n    }\r\n\r\n    // Public\r\n    enable() {\r\n      this._isEnabled = true;\r\n    }\r\n    disable() {\r\n      this._isEnabled = false;\r\n    }\r\n    toggleEnabled() {\r\n      this._isEnabled = !this._isEnabled;\r\n    }\r\n    toggle() {\r\n      if (!this._isEnabled) {\r\n        return;\r\n      }\r\n      if (this._isShown()) {\r\n        this._leave();\r\n        return;\r\n      }\r\n      this._enter();\r\n    }\r\n    dispose() {\r\n      clearTimeout(this._timeout);\r\n      EventHandler.off(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\r\n      if (this._element.getAttribute('data-bs-original-title')) {\r\n        this._element.setAttribute('title', this._element.getAttribute('data-bs-original-title'));\r\n      }\r\n      this._disposePopper();\r\n      super.dispose();\r\n    }\r\n    show() {\r\n      if (this._element.style.display === 'none') {\r\n        throw new Error('Please use show on visible elements');\r\n      }\r\n      if (!(this._isWithContent() && this._isEnabled)) {\r\n        return;\r\n      }\r\n      const showEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOW$2));\r\n      const shadowRoot = findShadowRoot(this._element);\r\n      const isInTheDom = (shadowRoot || this._element.ownerDocument.documentElement).contains(this._element);\r\n      if (showEvent.defaultPrevented || !isInTheDom) {\r\n        return;\r\n      }\r\n\r\n      // TODO: v6 remove this or make it optional\r\n      this._disposePopper();\r\n      const tip = this._getTipElement();\r\n      this._element.setAttribute('aria-describedby', tip.getAttribute('id'));\r\n      const {\r\n        container\r\n      } = this._config;\r\n      if (!this._element.ownerDocument.documentElement.contains(this.tip)) {\r\n        container.append(tip);\r\n        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_INSERTED));\r\n      }\r\n      this._popper = this._createPopper(tip);\r\n      tip.classList.add(CLASS_NAME_SHOW$2);\r\n\r\n      // If this is a touch-enabled device we add extra\r\n      // empty mouseover listeners to the body's immediate children;\r\n      // only needed because of broken event delegation on iOS\r\n      // https://www.quirksmode.org/blog/archives/2014/02/mouse_event_bub.html\r\n      if ('ontouchstart' in document.documentElement) {\r\n        for (const element of [].concat(...document.body.children)) {\r\n          EventHandler.on(element, 'mouseover', noop);\r\n        }\r\n      }\r\n      const complete = () => {\r\n        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_SHOWN$2));\r\n        if (this._isHovered === false) {\r\n          this._leave();\r\n        }\r\n        this._isHovered = false;\r\n      };\r\n      this._queueCallback(complete, this.tip, this._isAnimated());\r\n    }\r\n    hide() {\r\n      if (!this._isShown()) {\r\n        return;\r\n      }\r\n      const hideEvent = EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDE$2));\r\n      if (hideEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      const tip = this._getTipElement();\r\n      tip.classList.remove(CLASS_NAME_SHOW$2);\r\n\r\n      // If this is a touch-enabled device we remove the extra\r\n      // empty mouseover listeners we added for iOS support\r\n      if ('ontouchstart' in document.documentElement) {\r\n        for (const element of [].concat(...document.body.children)) {\r\n          EventHandler.off(element, 'mouseover', noop);\r\n        }\r\n      }\r\n      this._activeTrigger[TRIGGER_CLICK] = false;\r\n      this._activeTrigger[TRIGGER_FOCUS] = false;\r\n      this._activeTrigger[TRIGGER_HOVER] = false;\r\n      this._isHovered = null; // it is a trick to support manual triggering\r\n\r\n      const complete = () => {\r\n        if (this._isWithActiveTrigger()) {\r\n          return;\r\n        }\r\n        if (!this._isHovered) {\r\n          this._disposePopper();\r\n        }\r\n        this._element.removeAttribute('aria-describedby');\r\n        EventHandler.trigger(this._element, this.constructor.eventName(EVENT_HIDDEN$2));\r\n      };\r\n      this._queueCallback(complete, this.tip, this._isAnimated());\r\n    }\r\n    update() {\r\n      if (this._popper) {\r\n        this._popper.update();\r\n      }\r\n    }\r\n\r\n    // Protected\r\n    _isWithContent() {\r\n      return Boolean(this._getTitle());\r\n    }\r\n    _getTipElement() {\r\n      if (!this.tip) {\r\n        this.tip = this._createTipElement(this._newContent || this._getContentForTemplate());\r\n      }\r\n      return this.tip;\r\n    }\r\n    _createTipElement(content) {\r\n      const tip = this._getTemplateFactory(content).toHtml();\r\n\r\n      // TODO: remove this check in v6\r\n      if (!tip) {\r\n        return null;\r\n      }\r\n      tip.classList.remove(CLASS_NAME_FADE$2, CLASS_NAME_SHOW$2);\r\n      // TODO: v6 the following can be achieved with CSS only\r\n      tip.classList.add(`bs-${this.constructor.NAME}-auto`);\r\n      const tipId = getUID(this.constructor.NAME).toString();\r\n      tip.setAttribute('id', tipId);\r\n      if (this._isAnimated()) {\r\n        tip.classList.add(CLASS_NAME_FADE$2);\r\n      }\r\n      return tip;\r\n    }\r\n    setContent(content) {\r\n      this._newContent = content;\r\n      if (this._isShown()) {\r\n        this._disposePopper();\r\n        this.show();\r\n      }\r\n    }\r\n    _getTemplateFactory(content) {\r\n      if (this._templateFactory) {\r\n        this._templateFactory.changeContent(content);\r\n      } else {\r\n        this._templateFactory = new TemplateFactory({\r\n          ...this._config,\r\n          // the `content` var has to be after `this._config`\r\n          // to override config.content in case of popover\r\n          content,\r\n          extraClass: this._resolvePossibleFunction(this._config.customClass)\r\n        });\r\n      }\r\n      return this._templateFactory;\r\n    }\r\n    _getContentForTemplate() {\r\n      return {\r\n        [SELECTOR_TOOLTIP_INNER]: this._getTitle()\r\n      };\r\n    }\r\n    _getTitle() {\r\n      return this._resolvePossibleFunction(this._config.title) || this._element.getAttribute('data-bs-original-title');\r\n    }\r\n\r\n    // Private\r\n    _initializeOnDelegatedTarget(event) {\r\n      return this.constructor.getOrCreateInstance(event.delegateTarget, this._getDelegateConfig());\r\n    }\r\n    _isAnimated() {\r\n      return this._config.animation || this.tip && this.tip.classList.contains(CLASS_NAME_FADE$2);\r\n    }\r\n    _isShown() {\r\n      return this.tip && this.tip.classList.contains(CLASS_NAME_SHOW$2);\r\n    }\r\n    _createPopper(tip) {\r\n      const placement = execute(this._config.placement, [this, tip, this._element]);\r\n      const attachment = AttachmentMap[placement.toUpperCase()];\r\n      return createPopper(this._element, tip, this._getPopperConfig(attachment));\r\n    }\r\n    _getOffset() {\r\n      const {\r\n        offset\r\n      } = this._config;\r\n      if (typeof offset === 'string') {\r\n        return offset.split(',').map(value => Number.parseInt(value, 10));\r\n      }\r\n      if (typeof offset === 'function') {\r\n        return popperData => offset(popperData, this._element);\r\n      }\r\n      return offset;\r\n    }\r\n    _resolvePossibleFunction(arg) {\r\n      return execute(arg, [this._element, this._element]);\r\n    }\r\n    _getPopperConfig(attachment) {\r\n      const defaultBsPopperConfig = {\r\n        placement: attachment,\r\n        modifiers: [{\r\n          name: 'flip',\r\n          options: {\r\n            fallbackPlacements: this._config.fallbackPlacements\r\n          }\r\n        }, {\r\n          name: 'offset',\r\n          options: {\r\n            offset: this._getOffset()\r\n          }\r\n        }, {\r\n          name: 'preventOverflow',\r\n          options: {\r\n            boundary: this._config.boundary\r\n          }\r\n        }, {\r\n          name: 'arrow',\r\n          options: {\r\n            element: `.${this.constructor.NAME}-arrow`\r\n          }\r\n        }, {\r\n          name: 'preSetPlacement',\r\n          enabled: true,\r\n          phase: 'beforeMain',\r\n          fn: data => {\r\n            // Pre-set Popper's placement attribute in order to read the arrow sizes properly.\r\n            // Otherwise, Popper mixes up the width and height dimensions since the initial arrow style is for top placement\r\n            this._getTipElement().setAttribute('data-popper-placement', data.state.placement);\r\n          }\r\n        }]\r\n      };\r\n      return {\r\n        ...defaultBsPopperConfig,\r\n        ...execute(this._config.popperConfig, [undefined, defaultBsPopperConfig])\r\n      };\r\n    }\r\n    _setListeners() {\r\n      const triggers = this._config.trigger.split(' ');\r\n      for (const trigger of triggers) {\r\n        if (trigger === 'click') {\r\n          EventHandler.on(this._element, this.constructor.eventName(EVENT_CLICK$1), this._config.selector, event => {\r\n            const context = this._initializeOnDelegatedTarget(event);\r\n            context._activeTrigger[TRIGGER_CLICK] = !(context._isShown() && context._activeTrigger[TRIGGER_CLICK]);\r\n            context.toggle();\r\n          });\r\n        } else if (trigger !== TRIGGER_MANUAL) {\r\n          const eventIn = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSEENTER) : this.constructor.eventName(EVENT_FOCUSIN$1);\r\n          const eventOut = trigger === TRIGGER_HOVER ? this.constructor.eventName(EVENT_MOUSELEAVE) : this.constructor.eventName(EVENT_FOCUSOUT$1);\r\n          EventHandler.on(this._element, eventIn, this._config.selector, event => {\r\n            const context = this._initializeOnDelegatedTarget(event);\r\n            context._activeTrigger[event.type === 'focusin' ? TRIGGER_FOCUS : TRIGGER_HOVER] = true;\r\n            context._enter();\r\n          });\r\n          EventHandler.on(this._element, eventOut, this._config.selector, event => {\r\n            const context = this._initializeOnDelegatedTarget(event);\r\n            context._activeTrigger[event.type === 'focusout' ? TRIGGER_FOCUS : TRIGGER_HOVER] = context._element.contains(event.relatedTarget);\r\n            context._leave();\r\n          });\r\n        }\r\n      }\r\n      this._hideModalHandler = () => {\r\n        if (this._element) {\r\n          this.hide();\r\n        }\r\n      };\r\n      EventHandler.on(this._element.closest(SELECTOR_MODAL), EVENT_MODAL_HIDE, this._hideModalHandler);\r\n    }\r\n    _fixTitle() {\r\n      const title = this._element.getAttribute('title');\r\n      if (!title) {\r\n        return;\r\n      }\r\n      if (!this._element.getAttribute('aria-label') && !this._element.textContent.trim()) {\r\n        this._element.setAttribute('aria-label', title);\r\n      }\r\n      this._element.setAttribute('data-bs-original-title', title); // DO NOT USE IT. Is only for backwards compatibility\r\n      this._element.removeAttribute('title');\r\n    }\r\n    _enter() {\r\n      if (this._isShown() || this._isHovered) {\r\n        this._isHovered = true;\r\n        return;\r\n      }\r\n      this._isHovered = true;\r\n      this._setTimeout(() => {\r\n        if (this._isHovered) {\r\n          this.show();\r\n        }\r\n      }, this._config.delay.show);\r\n    }\r\n    _leave() {\r\n      if (this._isWithActiveTrigger()) {\r\n        return;\r\n      }\r\n      this._isHovered = false;\r\n      this._setTimeout(() => {\r\n        if (!this._isHovered) {\r\n          this.hide();\r\n        }\r\n      }, this._config.delay.hide);\r\n    }\r\n    _setTimeout(handler, timeout) {\r\n      clearTimeout(this._timeout);\r\n      this._timeout = setTimeout(handler, timeout);\r\n    }\r\n    _isWithActiveTrigger() {\r\n      return Object.values(this._activeTrigger).includes(true);\r\n    }\r\n    _getConfig(config) {\r\n      const dataAttributes = Manipulator.getDataAttributes(this._element);\r\n      for (const dataAttribute of Object.keys(dataAttributes)) {\r\n        if (DISALLOWED_ATTRIBUTES.has(dataAttribute)) {\r\n          delete dataAttributes[dataAttribute];\r\n        }\r\n      }\r\n      config = {\r\n        ...dataAttributes,\r\n        ...(typeof config === 'object' && config ? config : {})\r\n      };\r\n      config = this._mergeConfigObj(config);\r\n      config = this._configAfterMerge(config);\r\n      this._typeCheckConfig(config);\r\n      return config;\r\n    }\r\n    _configAfterMerge(config) {\r\n      config.container = config.container === false ? document.body : getElement(config.container);\r\n      if (typeof config.delay === 'number') {\r\n        config.delay = {\r\n          show: config.delay,\r\n          hide: config.delay\r\n        };\r\n      }\r\n      if (typeof config.title === 'number') {\r\n        config.title = config.title.toString();\r\n      }\r\n      if (typeof config.content === 'number') {\r\n        config.content = config.content.toString();\r\n      }\r\n      return config;\r\n    }\r\n    _getDelegateConfig() {\r\n      const config = {};\r\n      for (const [key, value] of Object.entries(this._config)) {\r\n        if (this.constructor.Default[key] !== value) {\r\n          config[key] = value;\r\n        }\r\n      }\r\n      config.selector = false;\r\n      config.trigger = 'manual';\r\n\r\n      // In the future can be replaced with:\r\n      // const keysWithDifferentValues = Object.entries(this._config).filter(entry => this.constructor.Default[entry[0]] !== this._config[entry[0]])\r\n      // `Object.fromEntries(keysWithDifferentValues)`\r\n      return config;\r\n    }\r\n    _disposePopper() {\r\n      if (this._popper) {\r\n        this._popper.destroy();\r\n        this._popper = null;\r\n      }\r\n      if (this.tip) {\r\n        this.tip.remove();\r\n        this.tip = null;\r\n      }\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = Tooltip.getOrCreateInstance(this, config);\r\n        if (typeof config !== 'string') {\r\n          return;\r\n        }\r\n        if (typeof data[config] === 'undefined') {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n        data[config]();\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Tooltip);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap popover.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$3 = 'popover';\r\n  const SELECTOR_TITLE = '.popover-header';\r\n  const SELECTOR_CONTENT = '.popover-body';\r\n  const Default$2 = {\r\n    ...Tooltip.Default,\r\n    content: '',\r\n    offset: [0, 8],\r\n    placement: 'right',\r\n    template: '<div class=\"popover\" role=\"tooltip\">' + '<div class=\"popover-arrow\"></div>' + '<h3 class=\"popover-header\"></h3>' + '<div class=\"popover-body\"></div>' + '</div>',\r\n    trigger: 'click'\r\n  };\r\n  const DefaultType$2 = {\r\n    ...Tooltip.DefaultType,\r\n    content: '(null|string|element|function)'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Popover extends Tooltip {\r\n    // Getters\r\n    static get Default() {\r\n      return Default$2;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$2;\r\n    }\r\n    static get NAME() {\r\n      return NAME$3;\r\n    }\r\n\r\n    // Overrides\r\n    _isWithContent() {\r\n      return this._getTitle() || this._getContent();\r\n    }\r\n\r\n    // Private\r\n    _getContentForTemplate() {\r\n      return {\r\n        [SELECTOR_TITLE]: this._getTitle(),\r\n        [SELECTOR_CONTENT]: this._getContent()\r\n      };\r\n    }\r\n    _getContent() {\r\n      return this._resolvePossibleFunction(this._config.content);\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = Popover.getOrCreateInstance(this, config);\r\n        if (typeof config !== 'string') {\r\n          return;\r\n        }\r\n        if (typeof data[config] === 'undefined') {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n        data[config]();\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Popover);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap scrollspy.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$2 = 'scrollspy';\r\n  const DATA_KEY$2 = 'bs.scrollspy';\r\n  const EVENT_KEY$2 = `.${DATA_KEY$2}`;\r\n  const DATA_API_KEY = '.data-api';\r\n  const EVENT_ACTIVATE = `activate${EVENT_KEY$2}`;\r\n  const EVENT_CLICK = `click${EVENT_KEY$2}`;\r\n  const EVENT_LOAD_DATA_API$1 = `load${EVENT_KEY$2}${DATA_API_KEY}`;\r\n  const CLASS_NAME_DROPDOWN_ITEM = 'dropdown-item';\r\n  const CLASS_NAME_ACTIVE$1 = 'active';\r\n  const SELECTOR_DATA_SPY = '[data-bs-spy=\"scroll\"]';\r\n  const SELECTOR_TARGET_LINKS = '[href]';\r\n  const SELECTOR_NAV_LIST_GROUP = '.nav, .list-group';\r\n  const SELECTOR_NAV_LINKS = '.nav-link';\r\n  const SELECTOR_NAV_ITEMS = '.nav-item';\r\n  const SELECTOR_LIST_ITEMS = '.list-group-item';\r\n  const SELECTOR_LINK_ITEMS = `${SELECTOR_NAV_LINKS}, ${SELECTOR_NAV_ITEMS} > ${SELECTOR_NAV_LINKS}, ${SELECTOR_LIST_ITEMS}`;\r\n  const SELECTOR_DROPDOWN = '.dropdown';\r\n  const SELECTOR_DROPDOWN_TOGGLE$1 = '.dropdown-toggle';\r\n  const Default$1 = {\r\n    offset: null,\r\n    // TODO: v6 @deprecated, keep it for backwards compatibility reasons\r\n    rootMargin: '0px 0px -25%',\r\n    smoothScroll: false,\r\n    target: null,\r\n    threshold: [0.1, 0.5, 1]\r\n  };\r\n  const DefaultType$1 = {\r\n    offset: '(number|null)',\r\n    // TODO v6 @deprecated, keep it for backwards compatibility reasons\r\n    rootMargin: 'string',\r\n    smoothScroll: 'boolean',\r\n    target: 'element',\r\n    threshold: 'array'\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class ScrollSpy extends BaseComponent {\r\n    constructor(element, config) {\r\n      super(element, config);\r\n\r\n      // this._element is the observablesContainer and config.target the menu links wrapper\r\n      this._targetLinks = new Map();\r\n      this._observableSections = new Map();\r\n      this._rootElement = getComputedStyle(this._element).overflowY === 'visible' ? null : this._element;\r\n      this._activeTarget = null;\r\n      this._observer = null;\r\n      this._previousScrollData = {\r\n        visibleEntryTop: 0,\r\n        parentScrollTop: 0\r\n      };\r\n      this.refresh(); // initialize\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default$1;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType$1;\r\n    }\r\n    static get NAME() {\r\n      return NAME$2;\r\n    }\r\n\r\n    // Public\r\n    refresh() {\r\n      this._initializeTargetsAndObservables();\r\n      this._maybeEnableSmoothScroll();\r\n      if (this._observer) {\r\n        this._observer.disconnect();\r\n      } else {\r\n        this._observer = this._getNewObserver();\r\n      }\r\n      for (const section of this._observableSections.values()) {\r\n        this._observer.observe(section);\r\n      }\r\n    }\r\n    dispose() {\r\n      this._observer.disconnect();\r\n      super.dispose();\r\n    }\r\n\r\n    // Private\r\n    _configAfterMerge(config) {\r\n      // TODO: on v6 target should be given explicitly & remove the {target: 'ss-target'} case\r\n      config.target = getElement(config.target) || document.body;\r\n\r\n      // TODO: v6 Only for backwards compatibility reasons. Use rootMargin only\r\n      config.rootMargin = config.offset ? `${config.offset}px 0px -30%` : config.rootMargin;\r\n      if (typeof config.threshold === 'string') {\r\n        config.threshold = config.threshold.split(',').map(value => Number.parseFloat(value));\r\n      }\r\n      return config;\r\n    }\r\n    _maybeEnableSmoothScroll() {\r\n      if (!this._config.smoothScroll) {\r\n        return;\r\n      }\r\n\r\n      // unregister any previous listeners\r\n      EventHandler.off(this._config.target, EVENT_CLICK);\r\n      EventHandler.on(this._config.target, EVENT_CLICK, SELECTOR_TARGET_LINKS, event => {\r\n        const observableSection = this._observableSections.get(event.target.hash);\r\n        if (observableSection) {\r\n          event.preventDefault();\r\n          const root = this._rootElement || window;\r\n          const height = observableSection.offsetTop - this._element.offsetTop;\r\n          if (root.scrollTo) {\r\n            root.scrollTo({\r\n              top: height,\r\n              behavior: 'smooth'\r\n            });\r\n            return;\r\n          }\r\n\r\n          // Chrome 60 doesn't support `scrollTo`\r\n          root.scrollTop = height;\r\n        }\r\n      });\r\n    }\r\n    _getNewObserver() {\r\n      const options = {\r\n        root: this._rootElement,\r\n        threshold: this._config.threshold,\r\n        rootMargin: this._config.rootMargin\r\n      };\r\n      return new IntersectionObserver(entries => this._observerCallback(entries), options);\r\n    }\r\n\r\n    // The logic of selection\r\n    _observerCallback(entries) {\r\n      const targetElement = entry => this._targetLinks.get(`#${entry.target.id}`);\r\n      const activate = entry => {\r\n        this._previousScrollData.visibleEntryTop = entry.target.offsetTop;\r\n        this._process(targetElement(entry));\r\n      };\r\n      const parentScrollTop = (this._rootElement || document.documentElement).scrollTop;\r\n      const userScrollsDown = parentScrollTop >= this._previousScrollData.parentScrollTop;\r\n      this._previousScrollData.parentScrollTop = parentScrollTop;\r\n      for (const entry of entries) {\r\n        if (!entry.isIntersecting) {\r\n          this._activeTarget = null;\r\n          this._clearActiveClass(targetElement(entry));\r\n          continue;\r\n        }\r\n        const entryIsLowerThanPrevious = entry.target.offsetTop >= this._previousScrollData.visibleEntryTop;\r\n        // if we are scrolling down, pick the bigger offsetTop\r\n        if (userScrollsDown && entryIsLowerThanPrevious) {\r\n          activate(entry);\r\n          // if parent isn't scrolled, let's keep the first visible item, breaking the iteration\r\n          if (!parentScrollTop) {\r\n            return;\r\n          }\r\n          continue;\r\n        }\r\n\r\n        // if we are scrolling up, pick the smallest offsetTop\r\n        if (!userScrollsDown && !entryIsLowerThanPrevious) {\r\n          activate(entry);\r\n        }\r\n      }\r\n    }\r\n    _initializeTargetsAndObservables() {\r\n      this._targetLinks = new Map();\r\n      this._observableSections = new Map();\r\n      const targetLinks = SelectorEngine.find(SELECTOR_TARGET_LINKS, this._config.target);\r\n      for (const anchor of targetLinks) {\r\n        // ensure that the anchor has an id and is not disabled\r\n        if (!anchor.hash || isDisabled(anchor)) {\r\n          continue;\r\n        }\r\n        const observableSection = SelectorEngine.findOne(decodeURI(anchor.hash), this._element);\r\n\r\n        // ensure that the observableSection exists & is visible\r\n        if (isVisible(observableSection)) {\r\n          this._targetLinks.set(decodeURI(anchor.hash), anchor);\r\n          this._observableSections.set(anchor.hash, observableSection);\r\n        }\r\n      }\r\n    }\r\n    _process(target) {\r\n      if (this._activeTarget === target) {\r\n        return;\r\n      }\r\n      this._clearActiveClass(this._config.target);\r\n      this._activeTarget = target;\r\n      target.classList.add(CLASS_NAME_ACTIVE$1);\r\n      this._activateParents(target);\r\n      EventHandler.trigger(this._element, EVENT_ACTIVATE, {\r\n        relatedTarget: target\r\n      });\r\n    }\r\n    _activateParents(target) {\r\n      // Activate dropdown parents\r\n      if (target.classList.contains(CLASS_NAME_DROPDOWN_ITEM)) {\r\n        SelectorEngine.findOne(SELECTOR_DROPDOWN_TOGGLE$1, target.closest(SELECTOR_DROPDOWN)).classList.add(CLASS_NAME_ACTIVE$1);\r\n        return;\r\n      }\r\n      for (const listGroup of SelectorEngine.parents(target, SELECTOR_NAV_LIST_GROUP)) {\r\n        // Set triggered links parents as active\r\n        // With both <ul> and <nav> markup a parent is the previous sibling of any nav ancestor\r\n        for (const item of SelectorEngine.prev(listGroup, SELECTOR_LINK_ITEMS)) {\r\n          item.classList.add(CLASS_NAME_ACTIVE$1);\r\n        }\r\n      }\r\n    }\r\n    _clearActiveClass(parent) {\r\n      parent.classList.remove(CLASS_NAME_ACTIVE$1);\r\n      const activeNodes = SelectorEngine.find(`${SELECTOR_TARGET_LINKS}.${CLASS_NAME_ACTIVE$1}`, parent);\r\n      for (const node of activeNodes) {\r\n        node.classList.remove(CLASS_NAME_ACTIVE$1);\r\n      }\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = ScrollSpy.getOrCreateInstance(this, config);\r\n        if (typeof config !== 'string') {\r\n          return;\r\n        }\r\n        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n        data[config]();\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  EventHandler.on(window, EVENT_LOAD_DATA_API$1, () => {\r\n    for (const spy of SelectorEngine.find(SELECTOR_DATA_SPY)) {\r\n      ScrollSpy.getOrCreateInstance(spy);\r\n    }\r\n  });\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(ScrollSpy);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap tab.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME$1 = 'tab';\r\n  const DATA_KEY$1 = 'bs.tab';\r\n  const EVENT_KEY$1 = `.${DATA_KEY$1}`;\r\n  const EVENT_HIDE$1 = `hide${EVENT_KEY$1}`;\r\n  const EVENT_HIDDEN$1 = `hidden${EVENT_KEY$1}`;\r\n  const EVENT_SHOW$1 = `show${EVENT_KEY$1}`;\r\n  const EVENT_SHOWN$1 = `shown${EVENT_KEY$1}`;\r\n  const EVENT_CLICK_DATA_API = `click${EVENT_KEY$1}`;\r\n  const EVENT_KEYDOWN = `keydown${EVENT_KEY$1}`;\r\n  const EVENT_LOAD_DATA_API = `load${EVENT_KEY$1}`;\r\n  const ARROW_LEFT_KEY = 'ArrowLeft';\r\n  const ARROW_RIGHT_KEY = 'ArrowRight';\r\n  const ARROW_UP_KEY = 'ArrowUp';\r\n  const ARROW_DOWN_KEY = 'ArrowDown';\r\n  const HOME_KEY = 'Home';\r\n  const END_KEY = 'End';\r\n  const CLASS_NAME_ACTIVE = 'active';\r\n  const CLASS_NAME_FADE$1 = 'fade';\r\n  const CLASS_NAME_SHOW$1 = 'show';\r\n  const CLASS_DROPDOWN = 'dropdown';\r\n  const SELECTOR_DROPDOWN_TOGGLE = '.dropdown-toggle';\r\n  const SELECTOR_DROPDOWN_MENU = '.dropdown-menu';\r\n  const NOT_SELECTOR_DROPDOWN_TOGGLE = `:not(${SELECTOR_DROPDOWN_TOGGLE})`;\r\n  const SELECTOR_TAB_PANEL = '.list-group, .nav, [role=\"tablist\"]';\r\n  const SELECTOR_OUTER = '.nav-item, .list-group-item';\r\n  const SELECTOR_INNER = `.nav-link${NOT_SELECTOR_DROPDOWN_TOGGLE}, .list-group-item${NOT_SELECTOR_DROPDOWN_TOGGLE}, [role=\"tab\"]${NOT_SELECTOR_DROPDOWN_TOGGLE}`;\r\n  const SELECTOR_DATA_TOGGLE = '[data-bs-toggle=\"tab\"], [data-bs-toggle=\"pill\"], [data-bs-toggle=\"list\"]'; // TODO: could only be `tab` in v6\r\n  const SELECTOR_INNER_ELEM = `${SELECTOR_INNER}, ${SELECTOR_DATA_TOGGLE}`;\r\n  const SELECTOR_DATA_TOGGLE_ACTIVE = `.${CLASS_NAME_ACTIVE}[data-bs-toggle=\"tab\"], .${CLASS_NAME_ACTIVE}[data-bs-toggle=\"pill\"], .${CLASS_NAME_ACTIVE}[data-bs-toggle=\"list\"]`;\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Tab extends BaseComponent {\r\n    constructor(element) {\r\n      super(element);\r\n      this._parent = this._element.closest(SELECTOR_TAB_PANEL);\r\n      if (!this._parent) {\r\n        return;\r\n        // TODO: should throw exception in v6\r\n        // throw new TypeError(`${element.outerHTML} has not a valid parent ${SELECTOR_INNER_ELEM}`)\r\n      }\r\n\r\n      // Set up initial aria attributes\r\n      this._setInitialAttributes(this._parent, this._getChildren());\r\n      EventHandler.on(this._element, EVENT_KEYDOWN, event => this._keydown(event));\r\n    }\r\n\r\n    // Getters\r\n    static get NAME() {\r\n      return NAME$1;\r\n    }\r\n\r\n    // Public\r\n    show() {\r\n      // Shows this elem and deactivate the active sibling if exists\r\n      const innerElem = this._element;\r\n      if (this._elemIsActive(innerElem)) {\r\n        return;\r\n      }\r\n\r\n      // Search for active tab on same parent to deactivate it\r\n      const active = this._getActiveElem();\r\n      const hideEvent = active ? EventHandler.trigger(active, EVENT_HIDE$1, {\r\n        relatedTarget: innerElem\r\n      }) : null;\r\n      const showEvent = EventHandler.trigger(innerElem, EVENT_SHOW$1, {\r\n        relatedTarget: active\r\n      });\r\n      if (showEvent.defaultPrevented || hideEvent && hideEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      this._deactivate(active, innerElem);\r\n      this._activate(innerElem, active);\r\n    }\r\n\r\n    // Private\r\n    _activate(element, relatedElem) {\r\n      if (!element) {\r\n        return;\r\n      }\r\n      element.classList.add(CLASS_NAME_ACTIVE);\r\n      this._activate(SelectorEngine.getElementFromSelector(element)); // Search and activate/show the proper section\r\n\r\n      const complete = () => {\r\n        if (element.getAttribute('role') !== 'tab') {\r\n          element.classList.add(CLASS_NAME_SHOW$1);\r\n          return;\r\n        }\r\n        element.removeAttribute('tabindex');\r\n        element.setAttribute('aria-selected', true);\r\n        this._toggleDropDown(element, true);\r\n        EventHandler.trigger(element, EVENT_SHOWN$1, {\r\n          relatedTarget: relatedElem\r\n        });\r\n      };\r\n      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\r\n    }\r\n    _deactivate(element, relatedElem) {\r\n      if (!element) {\r\n        return;\r\n      }\r\n      element.classList.remove(CLASS_NAME_ACTIVE);\r\n      element.blur();\r\n      this._deactivate(SelectorEngine.getElementFromSelector(element)); // Search and deactivate the shown section too\r\n\r\n      const complete = () => {\r\n        if (element.getAttribute('role') !== 'tab') {\r\n          element.classList.remove(CLASS_NAME_SHOW$1);\r\n          return;\r\n        }\r\n        element.setAttribute('aria-selected', false);\r\n        element.setAttribute('tabindex', '-1');\r\n        this._toggleDropDown(element, false);\r\n        EventHandler.trigger(element, EVENT_HIDDEN$1, {\r\n          relatedTarget: relatedElem\r\n        });\r\n      };\r\n      this._queueCallback(complete, element, element.classList.contains(CLASS_NAME_FADE$1));\r\n    }\r\n    _keydown(event) {\r\n      if (![ARROW_LEFT_KEY, ARROW_RIGHT_KEY, ARROW_UP_KEY, ARROW_DOWN_KEY, HOME_KEY, END_KEY].includes(event.key)) {\r\n        return;\r\n      }\r\n      event.stopPropagation(); // stopPropagation/preventDefault both added to support up/down keys without scrolling the page\r\n      event.preventDefault();\r\n      const children = this._getChildren().filter(element => !isDisabled(element));\r\n      let nextActiveElement;\r\n      if ([HOME_KEY, END_KEY].includes(event.key)) {\r\n        nextActiveElement = children[event.key === HOME_KEY ? 0 : children.length - 1];\r\n      } else {\r\n        const isNext = [ARROW_RIGHT_KEY, ARROW_DOWN_KEY].includes(event.key);\r\n        nextActiveElement = getNextActiveElement(children, event.target, isNext, true);\r\n      }\r\n      if (nextActiveElement) {\r\n        nextActiveElement.focus({\r\n          preventScroll: true\r\n        });\r\n        Tab.getOrCreateInstance(nextActiveElement).show();\r\n      }\r\n    }\r\n    _getChildren() {\r\n      // collection of inner elements\r\n      return SelectorEngine.find(SELECTOR_INNER_ELEM, this._parent);\r\n    }\r\n    _getActiveElem() {\r\n      return this._getChildren().find(child => this._elemIsActive(child)) || null;\r\n    }\r\n    _setInitialAttributes(parent, children) {\r\n      this._setAttributeIfNotExists(parent, 'role', 'tablist');\r\n      for (const child of children) {\r\n        this._setInitialAttributesOnChild(child);\r\n      }\r\n    }\r\n    _setInitialAttributesOnChild(child) {\r\n      child = this._getInnerElement(child);\r\n      const isActive = this._elemIsActive(child);\r\n      const outerElem = this._getOuterElement(child);\r\n      child.setAttribute('aria-selected', isActive);\r\n      if (outerElem !== child) {\r\n        this._setAttributeIfNotExists(outerElem, 'role', 'presentation');\r\n      }\r\n      if (!isActive) {\r\n        child.setAttribute('tabindex', '-1');\r\n      }\r\n      this._setAttributeIfNotExists(child, 'role', 'tab');\r\n\r\n      // set attributes to the related panel too\r\n      this._setInitialAttributesOnTargetPanel(child);\r\n    }\r\n    _setInitialAttributesOnTargetPanel(child) {\r\n      const target = SelectorEngine.getElementFromSelector(child);\r\n      if (!target) {\r\n        return;\r\n      }\r\n      this._setAttributeIfNotExists(target, 'role', 'tabpanel');\r\n      if (child.id) {\r\n        this._setAttributeIfNotExists(target, 'aria-labelledby', `${child.id}`);\r\n      }\r\n    }\r\n    _toggleDropDown(element, open) {\r\n      const outerElem = this._getOuterElement(element);\r\n      if (!outerElem.classList.contains(CLASS_DROPDOWN)) {\r\n        return;\r\n      }\r\n      const toggle = (selector, className) => {\r\n        const element = SelectorEngine.findOne(selector, outerElem);\r\n        if (element) {\r\n          element.classList.toggle(className, open);\r\n        }\r\n      };\r\n      toggle(SELECTOR_DROPDOWN_TOGGLE, CLASS_NAME_ACTIVE);\r\n      toggle(SELECTOR_DROPDOWN_MENU, CLASS_NAME_SHOW$1);\r\n      outerElem.setAttribute('aria-expanded', open);\r\n    }\r\n    _setAttributeIfNotExists(element, attribute, value) {\r\n      if (!element.hasAttribute(attribute)) {\r\n        element.setAttribute(attribute, value);\r\n      }\r\n    }\r\n    _elemIsActive(elem) {\r\n      return elem.classList.contains(CLASS_NAME_ACTIVE);\r\n    }\r\n\r\n    // Try to get the inner element (usually the .nav-link)\r\n    _getInnerElement(elem) {\r\n      return elem.matches(SELECTOR_INNER_ELEM) ? elem : SelectorEngine.findOne(SELECTOR_INNER_ELEM, elem);\r\n    }\r\n\r\n    // Try to get the outer element (usually the .nav-item)\r\n    _getOuterElement(elem) {\r\n      return elem.closest(SELECTOR_OUTER) || elem;\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = Tab.getOrCreateInstance(this);\r\n        if (typeof config !== 'string') {\r\n          return;\r\n        }\r\n        if (data[config] === undefined || config.startsWith('_') || config === 'constructor') {\r\n          throw new TypeError(`No method named \"${config}\"`);\r\n        }\r\n        data[config]();\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  EventHandler.on(document, EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function (event) {\r\n    if (['A', 'AREA'].includes(this.tagName)) {\r\n      event.preventDefault();\r\n    }\r\n    if (isDisabled(this)) {\r\n      return;\r\n    }\r\n    Tab.getOrCreateInstance(this).show();\r\n  });\r\n\r\n  /**\r\n   * Initialize on focus\r\n   */\r\n  EventHandler.on(window, EVENT_LOAD_DATA_API, () => {\r\n    for (const element of SelectorEngine.find(SELECTOR_DATA_TOGGLE_ACTIVE)) {\r\n      Tab.getOrCreateInstance(element);\r\n    }\r\n  });\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Tab);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap toast.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n\r\n  /**\r\n   * Constants\r\n   */\r\n\r\n  const NAME = 'toast';\r\n  const DATA_KEY = 'bs.toast';\r\n  const EVENT_KEY = `.${DATA_KEY}`;\r\n  const EVENT_MOUSEOVER = `mouseover${EVENT_KEY}`;\r\n  const EVENT_MOUSEOUT = `mouseout${EVENT_KEY}`;\r\n  const EVENT_FOCUSIN = `focusin${EVENT_KEY}`;\r\n  const EVENT_FOCUSOUT = `focusout${EVENT_KEY}`;\r\n  const EVENT_HIDE = `hide${EVENT_KEY}`;\r\n  const EVENT_HIDDEN = `hidden${EVENT_KEY}`;\r\n  const EVENT_SHOW = `show${EVENT_KEY}`;\r\n  const EVENT_SHOWN = `shown${EVENT_KEY}`;\r\n  const CLASS_NAME_FADE = 'fade';\r\n  const CLASS_NAME_HIDE = 'hide'; // @deprecated - kept here only for backwards compatibility\r\n  const CLASS_NAME_SHOW = 'show';\r\n  const CLASS_NAME_SHOWING = 'showing';\r\n  const DefaultType = {\r\n    animation: 'boolean',\r\n    autohide: 'boolean',\r\n    delay: 'number'\r\n  };\r\n  const Default = {\r\n    animation: true,\r\n    autohide: true,\r\n    delay: 5000\r\n  };\r\n\r\n  /**\r\n   * Class definition\r\n   */\r\n\r\n  class Toast extends BaseComponent {\r\n    constructor(element, config) {\r\n      super(element, config);\r\n      this._timeout = null;\r\n      this._hasMouseInteraction = false;\r\n      this._hasKeyboardInteraction = false;\r\n      this._setListeners();\r\n    }\r\n\r\n    // Getters\r\n    static get Default() {\r\n      return Default;\r\n    }\r\n    static get DefaultType() {\r\n      return DefaultType;\r\n    }\r\n    static get NAME() {\r\n      return NAME;\r\n    }\r\n\r\n    // Public\r\n    show() {\r\n      const showEvent = EventHandler.trigger(this._element, EVENT_SHOW);\r\n      if (showEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      this._clearTimeout();\r\n      if (this._config.animation) {\r\n        this._element.classList.add(CLASS_NAME_FADE);\r\n      }\r\n      const complete = () => {\r\n        this._element.classList.remove(CLASS_NAME_SHOWING);\r\n        EventHandler.trigger(this._element, EVENT_SHOWN);\r\n        this._maybeScheduleHide();\r\n      };\r\n      this._element.classList.remove(CLASS_NAME_HIDE); // @deprecated\r\n      reflow(this._element);\r\n      this._element.classList.add(CLASS_NAME_SHOW, CLASS_NAME_SHOWING);\r\n      this._queueCallback(complete, this._element, this._config.animation);\r\n    }\r\n    hide() {\r\n      if (!this.isShown()) {\r\n        return;\r\n      }\r\n      const hideEvent = EventHandler.trigger(this._element, EVENT_HIDE);\r\n      if (hideEvent.defaultPrevented) {\r\n        return;\r\n      }\r\n      const complete = () => {\r\n        this._element.classList.add(CLASS_NAME_HIDE); // @deprecated\r\n        this._element.classList.remove(CLASS_NAME_SHOWING, CLASS_NAME_SHOW);\r\n        EventHandler.trigger(this._element, EVENT_HIDDEN);\r\n      };\r\n      this._element.classList.add(CLASS_NAME_SHOWING);\r\n      this._queueCallback(complete, this._element, this._config.animation);\r\n    }\r\n    dispose() {\r\n      this._clearTimeout();\r\n      if (this.isShown()) {\r\n        this._element.classList.remove(CLASS_NAME_SHOW);\r\n      }\r\n      super.dispose();\r\n    }\r\n    isShown() {\r\n      return this._element.classList.contains(CLASS_NAME_SHOW);\r\n    }\r\n\r\n    // Private\r\n    _maybeScheduleHide() {\r\n      if (!this._config.autohide) {\r\n        return;\r\n      }\r\n      if (this._hasMouseInteraction || this._hasKeyboardInteraction) {\r\n        return;\r\n      }\r\n      this._timeout = setTimeout(() => {\r\n        this.hide();\r\n      }, this._config.delay);\r\n    }\r\n    _onInteraction(event, isInteracting) {\r\n      switch (event.type) {\r\n        case 'mouseover':\r\n        case 'mouseout':\r\n          {\r\n            this._hasMouseInteraction = isInteracting;\r\n            break;\r\n          }\r\n        case 'focusin':\r\n        case 'focusout':\r\n          {\r\n            this._hasKeyboardInteraction = isInteracting;\r\n            break;\r\n          }\r\n      }\r\n      if (isInteracting) {\r\n        this._clearTimeout();\r\n        return;\r\n      }\r\n      const nextElement = event.relatedTarget;\r\n      if (this._element === nextElement || this._element.contains(nextElement)) {\r\n        return;\r\n      }\r\n      this._maybeScheduleHide();\r\n    }\r\n    _setListeners() {\r\n      EventHandler.on(this._element, EVENT_MOUSEOVER, event => this._onInteraction(event, true));\r\n      EventHandler.on(this._element, EVENT_MOUSEOUT, event => this._onInteraction(event, false));\r\n      EventHandler.on(this._element, EVENT_FOCUSIN, event => this._onInteraction(event, true));\r\n      EventHandler.on(this._element, EVENT_FOCUSOUT, event => this._onInteraction(event, false));\r\n    }\r\n    _clearTimeout() {\r\n      clearTimeout(this._timeout);\r\n      this._timeout = null;\r\n    }\r\n\r\n    // Static\r\n    static jQueryInterface(config) {\r\n      return this.each(function () {\r\n        const data = Toast.getOrCreateInstance(this, config);\r\n        if (typeof config === 'string') {\r\n          if (typeof data[config] === 'undefined') {\r\n            throw new TypeError(`No method named \"${config}\"`);\r\n          }\r\n          data[config](this);\r\n        }\r\n      });\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Data API implementation\r\n   */\r\n\r\n  enableDismissTrigger(Toast);\r\n\r\n  /**\r\n   * jQuery\r\n   */\r\n\r\n  defineJQueryPlugin(Toast);\r\n\r\n  /**\r\n   * --------------------------------------------------------------------------\r\n   * Bootstrap index.umd.js\r\n   * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE)\r\n   * --------------------------------------------------------------------------\r\n   */\r\n\r\n  const index_umd = {\r\n    Alert,\r\n    Button,\r\n    Carousel,\r\n    Collapse,\r\n    Dropdown,\r\n    Modal,\r\n    Offcanvas,\r\n    Popover,\r\n    ScrollSpy,\r\n    Tab,\r\n    Toast,\r\n    Tooltip\r\n  };\r\n\r\n  return index_umd;\r\n\r\n}));\r\n//# sourceMappingURL=bootstrap.bundle.js.map\r\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmJ1bmRsZS5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLEtBQTREO0FBQzlELEVBQUUsQ0FDd0c7QUFDMUcsQ0FBQyx1QkFBdUI7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUdBQXFHLGtDQUFrQztBQUN2STtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFLGVBQWU7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsT0FBTztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxhQUFhO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsSUFBSSxJQUFJLFdBQVc7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTLDJCQUEyQjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpRUFBaUU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLGtCQUFrQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0JBQXNCO0FBQzVELEtBQUs7QUFDTDtBQUNBLHlDQUF5QyxzQkFBc0I7QUFDL0QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJEQUEyRCxzQkFBc0I7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBLDREQUE0RDtBQUM1RCw4RUFBOEU7QUFDOUUsb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG9DQUFvQyxZQUFZLFNBQVMsbUJBQW1CLFVBQVUsdUJBQXVCLGNBQWM7QUFDNUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBO0FBQ0EsaUJBQWlCLGNBQWM7QUFDL0I7QUFDQTtBQUNBLGdCQUFnQixLQUFLLEVBQUUsZUFBZTtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw0QkFBNEI7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLGdKQUFnSixTQUFTO0FBQ3pKO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvQkFBb0I7QUFDM0Q7QUFDQSwrREFBK0QsS0FBSztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRkFBcUYsS0FBSztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDLDhCQUE4QixZQUFZO0FBQzFDLGdDQUFnQyxZQUFZO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxZQUFZLEVBQUUsZUFBZTtBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxZQUFZO0FBQ3BELHNDQUFzQyxZQUFZO0FBQ2xELG9DQUFvQyxZQUFZO0FBQ2hELDBDQUEwQyxZQUFZO0FBQ3RELHNDQUFzQyxZQUFZO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixZQUFZO0FBQzFDLDRCQUE0QixZQUFZO0FBQ3hDLG9DQUFvQyxZQUFZO0FBQ2hELDBDQUEwQyxZQUFZO0FBQ3RELDBDQUEwQyxZQUFZO0FBQ3RELHVDQUF1QyxZQUFZO0FBQ25ELHVDQUF1QyxZQUFZLEVBQUUsZUFBZTtBQUNwRSx5Q0FBeUMsWUFBWSxFQUFFLGVBQWU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLE1BQU07QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsT0FBTztBQUMzRDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQyxnQ0FBZ0MsWUFBWTtBQUM1Qyw4QkFBOEIsWUFBWTtBQUMxQyxrQ0FBa0MsWUFBWTtBQUM5Qyx5Q0FBeUMsWUFBWSxFQUFFLGVBQWU7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QscUJBQXFCLEdBQUcsb0JBQW9CO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHFCQUFxQjtBQUN2RDtBQUNBLDBDQUEwQywwQkFBMEI7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsaURBQWlEO0FBQzNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELE9BQU87QUFDM0Q7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUcsT0FBTztBQUNWO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlIQUF5SDtBQUN6SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSSxHQUFHO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1YsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixvQ0FBb0M7QUFDakU7QUFDQTtBQUNBLDJCQUEyQixxQ0FBcUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLG1EQUFtRDtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsa0RBQWtEO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0I7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDREQUE0RDtBQUM1RCxnR0FBZ0c7QUFDaEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHVCQUF1QjtBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUU7QUFDckU7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxJQUFJO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RkFBOEY7QUFDOUY7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RDtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCxpQ0FBaUM7QUFDakMsOEJBQThCO0FBQzlCLE9BQU87QUFDUDtBQUNBLEtBQUssSUFBSSxHQUFHO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxhQUFhO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQyx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxvSEFBb0g7QUFDcEg7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQSwrQ0FBK0MsS0FBSztBQUNwRDtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFLFdBQVc7QUFDWDtBQUNBLDhCQUE4Qix1Q0FBdUM7QUFDckU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPLEdBQUc7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxREFBcUQ7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLEdBQUc7QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyx3QkFBd0IsaUJBQWlCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSw4QkFBOEIsWUFBWTtBQUMxQyxrQ0FBa0MsWUFBWTtBQUM5Qyw4QkFBOEIsWUFBWTtBQUMxQyxnQ0FBZ0MsWUFBWTtBQUM1Qyx5Q0FBeUMsWUFBWSxFQUFFLGVBQWU7QUFDdEUsMkNBQTJDLFlBQVksRUFBRSxlQUFlO0FBQ3hFLHVDQUF1QyxZQUFZLEVBQUUsZUFBZTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3Qyx1QkFBdUIsR0FBRyxrQkFBa0I7QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUJBQXFCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRTtBQUN0RTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyxPQUFPO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQyxvQ0FBb0MsWUFBWTtBQUNoRCwwQ0FBMEMsWUFBWTtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELDZDQUE2QztBQUNqRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUU7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQztBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUMsaURBQWlELFlBQVk7QUFDN0Qsa0NBQWtDLFlBQVk7QUFDOUMsOEJBQThCLFlBQVk7QUFDMUMsZ0NBQWdDLFlBQVk7QUFDNUMsa0NBQWtDLFlBQVk7QUFDOUMsOENBQThDLFlBQVk7QUFDMUQsc0RBQXNELFlBQVk7QUFDbEUsb0RBQW9ELFlBQVk7QUFDaEUseUNBQXlDLFlBQVksRUFBRSxlQUFlO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxlQUFlO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQSx1Q0FBdUMsWUFBWSxFQUFFLGVBQWU7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUMsZ0NBQWdDLFlBQVk7QUFDNUMsOEJBQThCLFlBQVk7QUFDMUMsK0NBQStDLFlBQVk7QUFDM0Qsa0NBQWtDLFlBQVk7QUFDOUMsZ0NBQWdDLFlBQVk7QUFDNUMseUNBQXlDLFlBQVksRUFBRSxlQUFlO0FBQ3RFLGtEQUFrRCxZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELE9BQU87QUFDekQ7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsaUJBQWlCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixzQkFBc0I7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx5QkFBeUIsc0JBQXNCO0FBQy9DO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtRUFBbUU7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4REFBOEQ7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixXQUFXO0FBQ3JDO0FBQ0Esb0NBQW9DLFlBQVk7QUFDaEQsOEJBQThCLFlBQVk7QUFDMUMsdUNBQXVDLFlBQVksRUFBRSxhQUFhO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUJBQW1CLElBQUksb0JBQW9CLElBQUksbUJBQW1CLElBQUksb0JBQW9CO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLHFCQUFxQjtBQUMxRjtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELGdCQUFnQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELHNCQUFzQixHQUFHLG9CQUFvQjtBQUM5RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsV0FBVztBQUNyQyw4QkFBOEIsWUFBWTtBQUMxQyxrQ0FBa0MsWUFBWTtBQUM5Qyw4QkFBOEIsWUFBWTtBQUMxQyxnQ0FBZ0MsWUFBWTtBQUM1Qyx1Q0FBdUMsWUFBWTtBQUNuRCxrQ0FBa0MsWUFBWTtBQUM5QyxxQ0FBcUMsWUFBWTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MseUJBQXlCO0FBQ3hFO0FBQ0E7QUFDQSxxQ0FBcUMsNkJBQTZCLG9CQUFvQiw2QkFBNkIsZ0JBQWdCLDZCQUE2QjtBQUNoSywyR0FBMkc7QUFDM0csaUNBQWlDLGVBQWUsSUFBSSxxQkFBcUI7QUFDekUsMENBQTBDLGtCQUFrQiwyQkFBMkIsa0JBQWtCLDRCQUE0QixrQkFBa0I7QUFDdko7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1CQUFtQix5QkFBeUIsb0JBQW9CO0FBQ2xHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0VBQXNFO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLFNBQVM7QUFDN0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxPQUFPO0FBQ3pEO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDLHNDQUFzQyxVQUFVO0FBQ2hELG9DQUFvQyxVQUFVO0FBQzlDLGtDQUFrQyxVQUFVO0FBQzVDLG9DQUFvQyxVQUFVO0FBQzlDLDRCQUE0QixVQUFVO0FBQ3RDLGdDQUFnQyxVQUFVO0FBQzFDLDRCQUE0QixVQUFVO0FBQ3RDLDhCQUE4QixVQUFVO0FBQ3hDO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVEO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bWFtdXN1bWUtdHJhY2tlci1hcHAvLi9ub2RlX21vZHVsZXMvYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmJ1bmRsZS5qcz84MGM3Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxyXG4gICogQm9vdHN0cmFwIHY1LjMuNyAoaHR0cHM6Ly9nZXRib290c3RyYXAuY29tLylcclxuICAqIENvcHlyaWdodCAyMDExLTIwMjUgVGhlIEJvb3RzdHJhcCBBdXRob3JzIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvZ3JhcGhzL2NvbnRyaWJ1dG9ycylcclxuICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICovXHJcbihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XHJcbiAgdHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxyXG4gIHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCA/IGRlZmluZShmYWN0b3J5KSA6XHJcbiAgKGdsb2JhbCA9IHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbFRoaXMgOiBnbG9iYWwgfHwgc2VsZiwgZ2xvYmFsLmJvb3RzdHJhcCA9IGZhY3RvcnkoKSk7XHJcbn0pKHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgZG9tL2RhdGEuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgZWxlbWVudE1hcCA9IG5ldyBNYXAoKTtcclxuICBjb25zdCBEYXRhID0ge1xyXG4gICAgc2V0KGVsZW1lbnQsIGtleSwgaW5zdGFuY2UpIHtcclxuICAgICAgaWYgKCFlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xyXG4gICAgICAgIGVsZW1lbnRNYXAuc2V0KGVsZW1lbnQsIG5ldyBNYXAoKSk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgaW5zdGFuY2VNYXAgPSBlbGVtZW50TWFwLmdldChlbGVtZW50KTtcclxuXHJcbiAgICAgIC8vIG1ha2UgaXQgY2xlYXIgd2Ugb25seSB3YW50IG9uZSBpbnN0YW5jZSBwZXIgZWxlbWVudFxyXG4gICAgICAvLyBjYW4gYmUgcmVtb3ZlZCBsYXRlciB3aGVuIG11bHRpcGxlIGtleS9pbnN0YW5jZXMgYXJlIGZpbmUgdG8gYmUgdXNlZFxyXG4gICAgICBpZiAoIWluc3RhbmNlTWFwLmhhcyhrZXkpICYmIGluc3RhbmNlTWFwLnNpemUgIT09IDApIHtcclxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tY29uc29sZVxyXG4gICAgICAgIGNvbnNvbGUuZXJyb3IoYEJvb3RzdHJhcCBkb2Vzbid0IGFsbG93IG1vcmUgdGhhbiBvbmUgaW5zdGFuY2UgcGVyIGVsZW1lbnQuIEJvdW5kIGluc3RhbmNlOiAke0FycmF5LmZyb20oaW5zdGFuY2VNYXAua2V5cygpKVswXX0uYCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGluc3RhbmNlTWFwLnNldChrZXksIGluc3RhbmNlKTtcclxuICAgIH0sXHJcbiAgICBnZXQoZWxlbWVudCwga2V5KSB7XHJcbiAgICAgIGlmIChlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xyXG4gICAgICAgIHJldHVybiBlbGVtZW50TWFwLmdldChlbGVtZW50KS5nZXQoa2V5KSB8fCBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuICAgIHJlbW92ZShlbGVtZW50LCBrZXkpIHtcclxuICAgICAgaWYgKCFlbGVtZW50TWFwLmhhcyhlbGVtZW50KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBpbnN0YW5jZU1hcCA9IGVsZW1lbnRNYXAuZ2V0KGVsZW1lbnQpO1xyXG4gICAgICBpbnN0YW5jZU1hcC5kZWxldGUoa2V5KTtcclxuXHJcbiAgICAgIC8vIGZyZWUgdXAgZWxlbWVudCByZWZlcmVuY2VzIGlmIHRoZXJlIGFyZSBubyBpbnN0YW5jZXMgbGVmdCBmb3IgYW4gZWxlbWVudFxyXG4gICAgICBpZiAoaW5zdGFuY2VNYXAuc2l6ZSA9PT0gMCkge1xyXG4gICAgICAgIGVsZW1lbnRNYXAuZGVsZXRlKGVsZW1lbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgdXRpbC9pbmRleC5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE1BWF9VSUQgPSAxMDAwMDAwO1xyXG4gIGNvbnN0IE1JTExJU0VDT05EU19NVUxUSVBMSUVSID0gMTAwMDtcclxuICBjb25zdCBUUkFOU0lUSU9OX0VORCA9ICd0cmFuc2l0aW9uZW5kJztcclxuXHJcbiAgLyoqXHJcbiAgICogUHJvcGVybHkgZXNjYXBlIElEcyBzZWxlY3RvcnMgdG8gaGFuZGxlIHdlaXJkIElEc1xyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzZWxlY3RvclxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgY29uc3QgcGFyc2VTZWxlY3RvciA9IHNlbGVjdG9yID0+IHtcclxuICAgIGlmIChzZWxlY3RvciAmJiB3aW5kb3cuQ1NTICYmIHdpbmRvdy5DU1MuZXNjYXBlKSB7XHJcbiAgICAgIC8vIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IgbmVlZHMgZXNjYXBpbmcgdG8gaGFuZGxlIElEcyAoaHRtbDUrKSBjb250YWluaW5nIGZvciBpbnN0YW5jZSAvXHJcbiAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvIyhbXlxcc1wiIyddKykvZywgKG1hdGNoLCBpZCkgPT4gYCMke0NTUy5lc2NhcGUoaWQpfWApO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHNlbGVjdG9yO1xyXG4gIH07XHJcblxyXG4gIC8vIFNob3V0LW91dCBBbmd1cyBDcm9sbCAoaHR0cHM6Ly9nb28uZ2wvcHh3UUdwKVxyXG4gIGNvbnN0IHRvVHlwZSA9IG9iamVjdCA9PiB7XHJcbiAgICBpZiAob2JqZWN0ID09PSBudWxsIHx8IG9iamVjdCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybiBgJHtvYmplY3R9YDtcclxuICAgIH1cclxuICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqZWN0KS5tYXRjaCgvXFxzKFthLXpdKykvaSlbMV0udG9Mb3dlckNhc2UoKTtcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBQdWJsaWMgVXRpbCBBUElcclxuICAgKi9cclxuXHJcbiAgY29uc3QgZ2V0VUlEID0gcHJlZml4ID0+IHtcclxuICAgIGRvIHtcclxuICAgICAgcHJlZml4ICs9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIE1BWF9VSUQpO1xyXG4gICAgfSB3aGlsZSAoZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQocHJlZml4KSk7XHJcbiAgICByZXR1cm4gcHJlZml4O1xyXG4gIH07XHJcbiAgY29uc3QgZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQgPSBlbGVtZW50ID0+IHtcclxuICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXQgdHJhbnNpdGlvbi1kdXJhdGlvbiBvZiB0aGUgZWxlbWVudFxyXG4gICAgbGV0IHtcclxuICAgICAgdHJhbnNpdGlvbkR1cmF0aW9uLFxyXG4gICAgICB0cmFuc2l0aW9uRGVsYXlcclxuICAgIH0gPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcclxuICAgIGNvbnN0IGZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uID0gTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkR1cmF0aW9uKTtcclxuICAgIGNvbnN0IGZsb2F0VHJhbnNpdGlvbkRlbGF5ID0gTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KTtcclxuXHJcbiAgICAvLyBSZXR1cm4gMCBpZiBlbGVtZW50IG9yIHRyYW5zaXRpb24gZHVyYXRpb24gaXMgbm90IGZvdW5kXHJcbiAgICBpZiAoIWZsb2F0VHJhbnNpdGlvbkR1cmF0aW9uICYmICFmbG9hdFRyYW5zaXRpb25EZWxheSkge1xyXG4gICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBtdWx0aXBsZSBkdXJhdGlvbnMgYXJlIGRlZmluZWQsIHRha2UgdGhlIGZpcnN0XHJcbiAgICB0cmFuc2l0aW9uRHVyYXRpb24gPSB0cmFuc2l0aW9uRHVyYXRpb24uc3BsaXQoJywnKVswXTtcclxuICAgIHRyYW5zaXRpb25EZWxheSA9IHRyYW5zaXRpb25EZWxheS5zcGxpdCgnLCcpWzBdO1xyXG4gICAgcmV0dXJuIChOdW1iZXIucGFyc2VGbG9hdCh0cmFuc2l0aW9uRHVyYXRpb24pICsgTnVtYmVyLnBhcnNlRmxvYXQodHJhbnNpdGlvbkRlbGF5KSkgKiBNSUxMSVNFQ09ORFNfTVVMVElQTElFUjtcclxuICB9O1xyXG4gIGNvbnN0IHRyaWdnZXJUcmFuc2l0aW9uRW5kID0gZWxlbWVudCA9PiB7XHJcbiAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFRSQU5TSVRJT05fRU5EKSk7XHJcbiAgfTtcclxuICBjb25zdCBpc0VsZW1lbnQkMSA9IG9iamVjdCA9PiB7XHJcbiAgICBpZiAoIW9iamVjdCB8fCB0eXBlb2Ygb2JqZWN0ICE9PSAnb2JqZWN0Jykge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIG9iamVjdC5qcXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgIG9iamVjdCA9IG9iamVjdFswXTtcclxuICAgIH1cclxuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0Lm5vZGVUeXBlICE9PSAndW5kZWZpbmVkJztcclxuICB9O1xyXG4gIGNvbnN0IGdldEVsZW1lbnQgPSBvYmplY3QgPT4ge1xyXG4gICAgLy8gaXQncyBhIGpRdWVyeSBvYmplY3Qgb3IgYSBub2RlIGVsZW1lbnRcclxuICAgIGlmIChpc0VsZW1lbnQkMShvYmplY3QpKSB7XHJcbiAgICAgIHJldHVybiBvYmplY3QuanF1ZXJ5ID8gb2JqZWN0WzBdIDogb2JqZWN0O1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnICYmIG9iamVjdC5sZW5ndGggPiAwKSB7XHJcbiAgICAgIHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHBhcnNlU2VsZWN0b3Iob2JqZWN0KSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9O1xyXG4gIGNvbnN0IGlzVmlzaWJsZSA9IGVsZW1lbnQgPT4ge1xyXG4gICAgaWYgKCFpc0VsZW1lbnQkMShlbGVtZW50KSB8fCBlbGVtZW50LmdldENsaWVudFJlY3RzKCkubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIGNvbnN0IGVsZW1lbnRJc1Zpc2libGUgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQpLmdldFByb3BlcnR5VmFsdWUoJ3Zpc2liaWxpdHknKSA9PT0gJ3Zpc2libGUnO1xyXG4gICAgLy8gSGFuZGxlIGBkZXRhaWxzYCBlbGVtZW50IGFzIGl0cyBjb250ZW50IG1heSBmYWxzaWUgYXBwZWFyIHZpc2libGUgd2hlbiBpdCBpcyBjbG9zZWRcclxuICAgIGNvbnN0IGNsb3NlZERldGFpbHMgPSBlbGVtZW50LmNsb3Nlc3QoJ2RldGFpbHM6bm90KFtvcGVuXSknKTtcclxuICAgIGlmICghY2xvc2VkRGV0YWlscykge1xyXG4gICAgICByZXR1cm4gZWxlbWVudElzVmlzaWJsZTtcclxuICAgIH1cclxuICAgIGlmIChjbG9zZWREZXRhaWxzICE9PSBlbGVtZW50KSB7XHJcbiAgICAgIGNvbnN0IHN1bW1hcnkgPSBlbGVtZW50LmNsb3Nlc3QoJ3N1bW1hcnknKTtcclxuICAgICAgaWYgKHN1bW1hcnkgJiYgc3VtbWFyeS5wYXJlbnROb2RlICE9PSBjbG9zZWREZXRhaWxzKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChzdW1tYXJ5ID09PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWxlbWVudElzVmlzaWJsZTtcclxuICB9O1xyXG4gIGNvbnN0IGlzRGlzYWJsZWQgPSBlbGVtZW50ID0+IHtcclxuICAgIGlmICghZWxlbWVudCB8fCBlbGVtZW50Lm5vZGVUeXBlICE9PSBOb2RlLkVMRU1FTlRfTk9ERSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmIChlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucygnZGlzYWJsZWQnKSkge1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIGlmICh0eXBlb2YgZWxlbWVudC5kaXNhYmxlZCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgcmV0dXJuIGVsZW1lbnQuZGlzYWJsZWQ7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJykgIT09ICdmYWxzZSc7XHJcbiAgfTtcclxuICBjb25zdCBmaW5kU2hhZG93Um9vdCA9IGVsZW1lbnQgPT4ge1xyXG4gICAgaWYgKCFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuYXR0YWNoU2hhZG93KSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENhbiBmaW5kIHRoZSBzaGFkb3cgcm9vdCBvdGhlcndpc2UgaXQnbGwgcmV0dXJuIHRoZSBkb2N1bWVudFxyXG4gICAgaWYgKHR5cGVvZiBlbGVtZW50LmdldFJvb3ROb2RlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIGNvbnN0IHJvb3QgPSBlbGVtZW50LmdldFJvb3ROb2RlKCk7XHJcbiAgICAgIHJldHVybiByb290IGluc3RhbmNlb2YgU2hhZG93Um9vdCA/IHJvb3QgOiBudWxsO1xyXG4gICAgfVxyXG4gICAgaWYgKGVsZW1lbnQgaW5zdGFuY2VvZiBTaGFkb3dSb290KSB7XHJcbiAgICAgIHJldHVybiBlbGVtZW50O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHdoZW4gd2UgZG9uJ3QgZmluZCBhIHNoYWRvdyByb290XHJcbiAgICBpZiAoIWVsZW1lbnQucGFyZW50Tm9kZSkge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuICAgIHJldHVybiBmaW5kU2hhZG93Um9vdChlbGVtZW50LnBhcmVudE5vZGUpO1xyXG4gIH07XHJcbiAgY29uc3Qgbm9vcCA9ICgpID0+IHt9O1xyXG5cclxuICAvKipcclxuICAgKiBUcmljayB0byByZXN0YXJ0IGFuIGVsZW1lbnQncyBhbmltYXRpb25cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGVsZW1lbnRcclxuICAgKiBAcmV0dXJuIHZvaWRcclxuICAgKlxyXG4gICAqIEBzZWUgaHR0cHM6Ly93d3cuaGFycnl0aGVvLmNvbS9ibG9nLzIwMjEvMDIvcmVzdGFydC1hLWNzcy1hbmltYXRpb24td2l0aC1qYXZhc2NyaXB0LyNyZXN0YXJ0aW5nLWEtY3NzLWFuaW1hdGlvblxyXG4gICAqL1xyXG4gIGNvbnN0IHJlZmxvdyA9IGVsZW1lbnQgPT4ge1xyXG4gICAgZWxlbWVudC5vZmZzZXRIZWlnaHQ7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLWV4cHJlc3Npb25zXHJcbiAgfTtcclxuICBjb25zdCBnZXRqUXVlcnkgPSAoKSA9PiB7XHJcbiAgICBpZiAod2luZG93LmpRdWVyeSAmJiAhZG9jdW1lbnQuYm9keS5oYXNBdHRyaWJ1dGUoJ2RhdGEtYnMtbm8tanF1ZXJ5JykpIHtcclxuICAgICAgcmV0dXJuIHdpbmRvdy5qUXVlcnk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxuICB9O1xyXG4gIGNvbnN0IERPTUNvbnRlbnRMb2FkZWRDYWxsYmFja3MgPSBbXTtcclxuICBjb25zdCBvbkRPTUNvbnRlbnRMb2FkZWQgPSBjYWxsYmFjayA9PiB7XHJcbiAgICBpZiAoZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gJ2xvYWRpbmcnKSB7XHJcbiAgICAgIC8vIGFkZCBsaXN0ZW5lciBvbiB0aGUgZmlyc3QgY2FsbCB3aGVuIHRoZSBkb2N1bWVudCBpcyBpbiBsb2FkaW5nIHN0YXRlXHJcbiAgICAgIGlmICghRE9NQ29udGVudExvYWRlZENhbGxiYWNrcy5sZW5ndGgpIHtcclxuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgKCkgPT4ge1xyXG4gICAgICAgICAgZm9yIChjb25zdCBjYWxsYmFjayBvZiBET01Db250ZW50TG9hZGVkQ2FsbGJhY2tzKSB7XHJcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuICAgICAgRE9NQ29udGVudExvYWRlZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNhbGxiYWNrKCk7XHJcbiAgICB9XHJcbiAgfTtcclxuICBjb25zdCBpc1JUTCA9ICgpID0+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5kaXIgPT09ICdydGwnO1xyXG4gIGNvbnN0IGRlZmluZUpRdWVyeVBsdWdpbiA9IHBsdWdpbiA9PiB7XHJcbiAgICBvbkRPTUNvbnRlbnRMb2FkZWQoKCkgPT4ge1xyXG4gICAgICBjb25zdCAkID0gZ2V0alF1ZXJ5KCk7XHJcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xyXG4gICAgICBpZiAoJCkge1xyXG4gICAgICAgIGNvbnN0IG5hbWUgPSBwbHVnaW4uTkFNRTtcclxuICAgICAgICBjb25zdCBKUVVFUllfTk9fQ09ORkxJQ1QgPSAkLmZuW25hbWVdO1xyXG4gICAgICAgICQuZm5bbmFtZV0gPSBwbHVnaW4ualF1ZXJ5SW50ZXJmYWNlO1xyXG4gICAgICAgICQuZm5bbmFtZV0uQ29uc3RydWN0b3IgPSBwbHVnaW47XHJcbiAgICAgICAgJC5mbltuYW1lXS5ub0NvbmZsaWN0ID0gKCkgPT4ge1xyXG4gICAgICAgICAgJC5mbltuYW1lXSA9IEpRVUVSWV9OT19DT05GTElDVDtcclxuICAgICAgICAgIHJldHVybiBwbHVnaW4ualF1ZXJ5SW50ZXJmYWNlO1xyXG4gICAgICAgIH07XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH07XHJcbiAgY29uc3QgZXhlY3V0ZSA9IChwb3NzaWJsZUNhbGxiYWNrLCBhcmdzID0gW10sIGRlZmF1bHRWYWx1ZSA9IHBvc3NpYmxlQ2FsbGJhY2spID0+IHtcclxuICAgIHJldHVybiB0eXBlb2YgcG9zc2libGVDYWxsYmFjayA9PT0gJ2Z1bmN0aW9uJyA/IHBvc3NpYmxlQ2FsbGJhY2suY2FsbCguLi5hcmdzKSA6IGRlZmF1bHRWYWx1ZTtcclxuICB9O1xyXG4gIGNvbnN0IGV4ZWN1dGVBZnRlclRyYW5zaXRpb24gPSAoY2FsbGJhY2ssIHRyYW5zaXRpb25FbGVtZW50LCB3YWl0Rm9yVHJhbnNpdGlvbiA9IHRydWUpID0+IHtcclxuICAgIGlmICghd2FpdEZvclRyYW5zaXRpb24pIHtcclxuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIGNvbnN0IGR1cmF0aW9uUGFkZGluZyA9IDU7XHJcbiAgICBjb25zdCBlbXVsYXRlZER1cmF0aW9uID0gZ2V0VHJhbnNpdGlvbkR1cmF0aW9uRnJvbUVsZW1lbnQodHJhbnNpdGlvbkVsZW1lbnQpICsgZHVyYXRpb25QYWRkaW5nO1xyXG4gICAgbGV0IGNhbGxlZCA9IGZhbHNlO1xyXG4gICAgY29uc3QgaGFuZGxlciA9ICh7XHJcbiAgICAgIHRhcmdldFxyXG4gICAgfSkgPT4ge1xyXG4gICAgICBpZiAodGFyZ2V0ICE9PSB0cmFuc2l0aW9uRWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjYWxsZWQgPSB0cnVlO1xyXG4gICAgICB0cmFuc2l0aW9uRWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFRSQU5TSVRJT05fRU5ELCBoYW5kbGVyKTtcclxuICAgICAgZXhlY3V0ZShjYWxsYmFjayk7XHJcbiAgICB9O1xyXG4gICAgdHJhbnNpdGlvbkVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihUUkFOU0lUSU9OX0VORCwgaGFuZGxlcik7XHJcbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgaWYgKCFjYWxsZWQpIHtcclxuICAgICAgICB0cmlnZ2VyVHJhbnNpdGlvbkVuZCh0cmFuc2l0aW9uRWxlbWVudCk7XHJcbiAgICAgIH1cclxuICAgIH0sIGVtdWxhdGVkRHVyYXRpb24pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgcHJldmlvdXMvbmV4dCBlbGVtZW50IG9mIGEgbGlzdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YXJyYXl9IGxpc3QgICAgVGhlIGxpc3Qgb2YgZWxlbWVudHNcclxuICAgKiBAcGFyYW0gYWN0aXZlRWxlbWVudCAgIFRoZSBhY3RpdmUgZWxlbWVudFxyXG4gICAqIEBwYXJhbSBzaG91bGRHZXROZXh0ICAgQ2hvb3NlIHRvIGdldCBuZXh0IG9yIHByZXZpb3VzIGVsZW1lbnRcclxuICAgKiBAcGFyYW0gaXNDeWNsZUFsbG93ZWRcclxuICAgKiBAcmV0dXJuIHtFbGVtZW50fGVsZW19IFRoZSBwcm9wZXIgZWxlbWVudFxyXG4gICAqL1xyXG4gIGNvbnN0IGdldE5leHRBY3RpdmVFbGVtZW50ID0gKGxpc3QsIGFjdGl2ZUVsZW1lbnQsIHNob3VsZEdldE5leHQsIGlzQ3ljbGVBbGxvd2VkKSA9PiB7XHJcbiAgICBjb25zdCBsaXN0TGVuZ3RoID0gbGlzdC5sZW5ndGg7XHJcbiAgICBsZXQgaW5kZXggPSBsaXN0LmluZGV4T2YoYWN0aXZlRWxlbWVudCk7XHJcblxyXG4gICAgLy8gaWYgdGhlIGVsZW1lbnQgZG9lcyBub3QgZXhpc3QgaW4gdGhlIGxpc3QgcmV0dXJuIGFuIGVsZW1lbnRcclxuICAgIC8vIGRlcGVuZGluZyBvbiB0aGUgZGlyZWN0aW9uIGFuZCBpZiBjeWNsZSBpcyBhbGxvd2VkXHJcbiAgICBpZiAoaW5kZXggPT09IC0xKSB7XHJcbiAgICAgIHJldHVybiAhc2hvdWxkR2V0TmV4dCAmJiBpc0N5Y2xlQWxsb3dlZCA/IGxpc3RbbGlzdExlbmd0aCAtIDFdIDogbGlzdFswXTtcclxuICAgIH1cclxuICAgIGluZGV4ICs9IHNob3VsZEdldE5leHQgPyAxIDogLTE7XHJcbiAgICBpZiAoaXNDeWNsZUFsbG93ZWQpIHtcclxuICAgICAgaW5kZXggPSAoaW5kZXggKyBsaXN0TGVuZ3RoKSAlIGxpc3RMZW5ndGg7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbGlzdFtNYXRoLm1heCgwLCBNYXRoLm1pbihpbmRleCwgbGlzdExlbmd0aCAtIDEpKV07XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgZG9tL2V2ZW50LWhhbmRsZXIuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IG5hbWVzcGFjZVJlZ2V4ID0gL1teLl0qKD89XFwuLiopXFwufC4qLztcclxuICBjb25zdCBzdHJpcE5hbWVSZWdleCA9IC9cXC4uKi87XHJcbiAgY29uc3Qgc3RyaXBVaWRSZWdleCA9IC86OlxcZCskLztcclxuICBjb25zdCBldmVudFJlZ2lzdHJ5ID0ge307IC8vIEV2ZW50cyBzdG9yYWdlXHJcbiAgbGV0IHVpZEV2ZW50ID0gMTtcclxuICBjb25zdCBjdXN0b21FdmVudHMgPSB7XHJcbiAgICBtb3VzZWVudGVyOiAnbW91c2VvdmVyJyxcclxuICAgIG1vdXNlbGVhdmU6ICdtb3VzZW91dCdcclxuICB9O1xyXG4gIGNvbnN0IG5hdGl2ZUV2ZW50cyA9IG5ldyBTZXQoWydjbGljaycsICdkYmxjbGljaycsICdtb3VzZXVwJywgJ21vdXNlZG93bicsICdjb250ZXh0bWVudScsICdtb3VzZXdoZWVsJywgJ0RPTU1vdXNlU2Nyb2xsJywgJ21vdXNlb3ZlcicsICdtb3VzZW91dCcsICdtb3VzZW1vdmUnLCAnc2VsZWN0c3RhcnQnLCAnc2VsZWN0ZW5kJywgJ2tleWRvd24nLCAna2V5cHJlc3MnLCAna2V5dXAnLCAnb3JpZW50YXRpb25jaGFuZ2UnLCAndG91Y2hzdGFydCcsICd0b3VjaG1vdmUnLCAndG91Y2hlbmQnLCAndG91Y2hjYW5jZWwnLCAncG9pbnRlcmRvd24nLCAncG9pbnRlcm1vdmUnLCAncG9pbnRlcnVwJywgJ3BvaW50ZXJsZWF2ZScsICdwb2ludGVyY2FuY2VsJywgJ2dlc3R1cmVzdGFydCcsICdnZXN0dXJlY2hhbmdlJywgJ2dlc3R1cmVlbmQnLCAnZm9jdXMnLCAnYmx1cicsICdjaGFuZ2UnLCAncmVzZXQnLCAnc2VsZWN0JywgJ3N1Ym1pdCcsICdmb2N1c2luJywgJ2ZvY3Vzb3V0JywgJ2xvYWQnLCAndW5sb2FkJywgJ2JlZm9yZXVubG9hZCcsICdyZXNpemUnLCAnbW92ZScsICdET01Db250ZW50TG9hZGVkJywgJ3JlYWR5c3RhdGVjaGFuZ2UnLCAnZXJyb3InLCAnYWJvcnQnLCAnc2Nyb2xsJ10pO1xyXG5cclxuICAvKipcclxuICAgKiBQcml2YXRlIG1ldGhvZHNcclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gbWFrZUV2ZW50VWlkKGVsZW1lbnQsIHVpZCkge1xyXG4gICAgcmV0dXJuIHVpZCAmJiBgJHt1aWR9Ojoke3VpZEV2ZW50Kyt9YCB8fCBlbGVtZW50LnVpZEV2ZW50IHx8IHVpZEV2ZW50Kys7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGdldEVsZW1lbnRFdmVudHMoZWxlbWVudCkge1xyXG4gICAgY29uc3QgdWlkID0gbWFrZUV2ZW50VWlkKGVsZW1lbnQpO1xyXG4gICAgZWxlbWVudC51aWRFdmVudCA9IHVpZDtcclxuICAgIGV2ZW50UmVnaXN0cnlbdWlkXSA9IGV2ZW50UmVnaXN0cnlbdWlkXSB8fCB7fTtcclxuICAgIHJldHVybiBldmVudFJlZ2lzdHJ5W3VpZF07XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGJvb3RzdHJhcEhhbmRsZXIoZWxlbWVudCwgZm4pIHtcclxuICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVyKGV2ZW50KSB7XHJcbiAgICAgIGh5ZHJhdGVPYmooZXZlbnQsIHtcclxuICAgICAgICBkZWxlZ2F0ZVRhcmdldDogZWxlbWVudFxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKGhhbmRsZXIub25lT2ZmKSB7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCBldmVudC50eXBlLCBmbik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGZuLmFwcGx5KGVsZW1lbnQsIFtldmVudF0pO1xyXG4gICAgfTtcclxuICB9XHJcbiAgZnVuY3Rpb24gYm9vdHN0cmFwRGVsZWdhdGlvbkhhbmRsZXIoZWxlbWVudCwgc2VsZWN0b3IsIGZuKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gaGFuZGxlcihldmVudCkge1xyXG4gICAgICBjb25zdCBkb21FbGVtZW50cyA9IGVsZW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3Rvcik7XHJcbiAgICAgIGZvciAobGV0IHtcclxuICAgICAgICB0YXJnZXRcclxuICAgICAgfSA9IGV2ZW50OyB0YXJnZXQgJiYgdGFyZ2V0ICE9PSB0aGlzOyB0YXJnZXQgPSB0YXJnZXQucGFyZW50Tm9kZSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZG9tRWxlbWVudCBvZiBkb21FbGVtZW50cykge1xyXG4gICAgICAgICAgaWYgKGRvbUVsZW1lbnQgIT09IHRhcmdldCkge1xyXG4gICAgICAgICAgICBjb250aW51ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGh5ZHJhdGVPYmooZXZlbnQsIHtcclxuICAgICAgICAgICAgZGVsZWdhdGVUYXJnZXQ6IHRhcmdldFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBpZiAoaGFuZGxlci5vbmVPZmYpIHtcclxuICAgICAgICAgICAgRXZlbnRIYW5kbGVyLm9mZihlbGVtZW50LCBldmVudC50eXBlLCBzZWxlY3RvciwgZm4pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRhcmdldCwgW2V2ZW50XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH1cclxuICBmdW5jdGlvbiBmaW5kSGFuZGxlcihldmVudHMsIGNhbGxhYmxlLCBkZWxlZ2F0aW9uU2VsZWN0b3IgPSBudWxsKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LnZhbHVlcyhldmVudHMpLmZpbmQoZXZlbnQgPT4gZXZlbnQuY2FsbGFibGUgPT09IGNhbGxhYmxlICYmIGV2ZW50LmRlbGVnYXRpb25TZWxlY3RvciA9PT0gZGVsZWdhdGlvblNlbGVjdG9yKTtcclxuICB9XHJcbiAgZnVuY3Rpb24gbm9ybWFsaXplUGFyYW1ldGVycyhvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XHJcbiAgICBjb25zdCBpc0RlbGVnYXRlZCA9IHR5cGVvZiBoYW5kbGVyID09PSAnc3RyaW5nJztcclxuICAgIC8vIFRPRE86IHRvb2x0aXAgcGFzc2VzIGBmYWxzZWAgaW5zdGVhZCBvZiBzZWxlY3Rvciwgc28gd2UgbmVlZCB0byBjaGVja1xyXG4gICAgY29uc3QgY2FsbGFibGUgPSBpc0RlbGVnYXRlZCA/IGRlbGVnYXRpb25GdW5jdGlvbiA6IGhhbmRsZXIgfHwgZGVsZWdhdGlvbkZ1bmN0aW9uO1xyXG4gICAgbGV0IHR5cGVFdmVudCA9IGdldFR5cGVFdmVudChvcmlnaW5hbFR5cGVFdmVudCk7XHJcbiAgICBpZiAoIW5hdGl2ZUV2ZW50cy5oYXModHlwZUV2ZW50KSkge1xyXG4gICAgICB0eXBlRXZlbnQgPSBvcmlnaW5hbFR5cGVFdmVudDtcclxuICAgIH1cclxuICAgIHJldHVybiBbaXNEZWxlZ2F0ZWQsIGNhbGxhYmxlLCB0eXBlRXZlbnRdO1xyXG4gIH1cclxuICBmdW5jdGlvbiBhZGRIYW5kbGVyKGVsZW1lbnQsIG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24sIG9uZU9mZikge1xyXG4gICAgaWYgKHR5cGVvZiBvcmlnaW5hbFR5cGVFdmVudCAhPT0gJ3N0cmluZycgfHwgIWVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgbGV0IFtpc0RlbGVnYXRlZCwgY2FsbGFibGUsIHR5cGVFdmVudF0gPSBub3JtYWxpemVQYXJhbWV0ZXJzKG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pO1xyXG5cclxuICAgIC8vIGluIGNhc2Ugb2YgbW91c2VlbnRlciBvciBtb3VzZWxlYXZlIHdyYXAgdGhlIGhhbmRsZXIgd2l0aGluIGEgZnVuY3Rpb24gdGhhdCBjaGVja3MgZm9yIGl0cyBET00gcG9zaXRpb25cclxuICAgIC8vIHRoaXMgcHJldmVudHMgdGhlIGhhbmRsZXIgZnJvbSBiZWluZyBkaXNwYXRjaGVkIHRoZSBzYW1lIHdheSBhcyBtb3VzZW92ZXIgb3IgbW91c2VvdXQgZG9lc1xyXG4gICAgaWYgKG9yaWdpbmFsVHlwZUV2ZW50IGluIGN1c3RvbUV2ZW50cykge1xyXG4gICAgICBjb25zdCB3cmFwRnVuY3Rpb24gPSBmbiA9PiB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgICAgaWYgKCFldmVudC5yZWxhdGVkVGFyZ2V0IHx8IGV2ZW50LnJlbGF0ZWRUYXJnZXQgIT09IGV2ZW50LmRlbGVnYXRlVGFyZ2V0ICYmICFldmVudC5kZWxlZ2F0ZVRhcmdldC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZm4uY2FsbCh0aGlzLCBldmVudCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgfTtcclxuICAgICAgY2FsbGFibGUgPSB3cmFwRnVuY3Rpb24oY2FsbGFibGUpO1xyXG4gICAgfVxyXG4gICAgY29uc3QgZXZlbnRzID0gZ2V0RWxlbWVudEV2ZW50cyhlbGVtZW50KTtcclxuICAgIGNvbnN0IGhhbmRsZXJzID0gZXZlbnRzW3R5cGVFdmVudF0gfHwgKGV2ZW50c1t0eXBlRXZlbnRdID0ge30pO1xyXG4gICAgY29uc3QgcHJldmlvdXNGdW5jdGlvbiA9IGZpbmRIYW5kbGVyKGhhbmRsZXJzLCBjYWxsYWJsZSwgaXNEZWxlZ2F0ZWQgPyBoYW5kbGVyIDogbnVsbCk7XHJcbiAgICBpZiAocHJldmlvdXNGdW5jdGlvbikge1xyXG4gICAgICBwcmV2aW91c0Z1bmN0aW9uLm9uZU9mZiA9IHByZXZpb3VzRnVuY3Rpb24ub25lT2ZmICYmIG9uZU9mZjtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY29uc3QgdWlkID0gbWFrZUV2ZW50VWlkKGNhbGxhYmxlLCBvcmlnaW5hbFR5cGVFdmVudC5yZXBsYWNlKG5hbWVzcGFjZVJlZ2V4LCAnJykpO1xyXG4gICAgY29uc3QgZm4gPSBpc0RlbGVnYXRlZCA/IGJvb3RzdHJhcERlbGVnYXRpb25IYW5kbGVyKGVsZW1lbnQsIGhhbmRsZXIsIGNhbGxhYmxlKSA6IGJvb3RzdHJhcEhhbmRsZXIoZWxlbWVudCwgY2FsbGFibGUpO1xyXG4gICAgZm4uZGVsZWdhdGlvblNlbGVjdG9yID0gaXNEZWxlZ2F0ZWQgPyBoYW5kbGVyIDogbnVsbDtcclxuICAgIGZuLmNhbGxhYmxlID0gY2FsbGFibGU7XHJcbiAgICBmbi5vbmVPZmYgPSBvbmVPZmY7XHJcbiAgICBmbi51aWRFdmVudCA9IHVpZDtcclxuICAgIGhhbmRsZXJzW3VpZF0gPSBmbjtcclxuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcih0eXBlRXZlbnQsIGZuLCBpc0RlbGVnYXRlZCk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25TZWxlY3Rvcikge1xyXG4gICAgY29uc3QgZm4gPSBmaW5kSGFuZGxlcihldmVudHNbdHlwZUV2ZW50XSwgaGFuZGxlciwgZGVsZWdhdGlvblNlbGVjdG9yKTtcclxuICAgIGlmICghZm4pIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgZWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGVFdmVudCwgZm4sIEJvb2xlYW4oZGVsZWdhdGlvblNlbGVjdG9yKSk7XHJcbiAgICBkZWxldGUgZXZlbnRzW3R5cGVFdmVudF1bZm4udWlkRXZlbnRdO1xyXG4gIH1cclxuICBmdW5jdGlvbiByZW1vdmVOYW1lc3BhY2VkSGFuZGxlcnMoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIG5hbWVzcGFjZSkge1xyXG4gICAgY29uc3Qgc3RvcmVFbGVtZW50RXZlbnQgPSBldmVudHNbdHlwZUV2ZW50XSB8fCB7fTtcclxuICAgIGZvciAoY29uc3QgW2hhbmRsZXJLZXksIGV2ZW50XSBvZiBPYmplY3QuZW50cmllcyhzdG9yZUVsZW1lbnRFdmVudCkpIHtcclxuICAgICAgaWYgKGhhbmRsZXJLZXkuaW5jbHVkZXMobmFtZXNwYWNlKSkge1xyXG4gICAgICAgIHJlbW92ZUhhbmRsZXIoZWxlbWVudCwgZXZlbnRzLCB0eXBlRXZlbnQsIGV2ZW50LmNhbGxhYmxlLCBldmVudC5kZWxlZ2F0aW9uU2VsZWN0b3IpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIGdldFR5cGVFdmVudChldmVudCkge1xyXG4gICAgLy8gYWxsb3cgdG8gZ2V0IHRoZSBuYXRpdmUgZXZlbnRzIGZyb20gbmFtZXNwYWNlZCBldmVudHMgKCdjbGljay5icy5idXR0b24nIC0tPiAnY2xpY2snKVxyXG4gICAgZXZlbnQgPSBldmVudC5yZXBsYWNlKHN0cmlwTmFtZVJlZ2V4LCAnJyk7XHJcbiAgICByZXR1cm4gY3VzdG9tRXZlbnRzW2V2ZW50XSB8fCBldmVudDtcclxuICB9XHJcbiAgY29uc3QgRXZlbnRIYW5kbGVyID0ge1xyXG4gICAgb24oZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbikge1xyXG4gICAgICBhZGRIYW5kbGVyKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24sIGZhbHNlKTtcclxuICAgIH0sXHJcbiAgICBvbmUoZWxlbWVudCwgZXZlbnQsIGhhbmRsZXIsIGRlbGVnYXRpb25GdW5jdGlvbikge1xyXG4gICAgICBhZGRIYW5kbGVyKGVsZW1lbnQsIGV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24sIHRydWUpO1xyXG4gICAgfSxcclxuICAgIG9mZihlbGVtZW50LCBvcmlnaW5hbFR5cGVFdmVudCwgaGFuZGxlciwgZGVsZWdhdGlvbkZ1bmN0aW9uKSB7XHJcbiAgICAgIGlmICh0eXBlb2Ygb3JpZ2luYWxUeXBlRXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IFtpc0RlbGVnYXRlZCwgY2FsbGFibGUsIHR5cGVFdmVudF0gPSBub3JtYWxpemVQYXJhbWV0ZXJzKG9yaWdpbmFsVHlwZUV2ZW50LCBoYW5kbGVyLCBkZWxlZ2F0aW9uRnVuY3Rpb24pO1xyXG4gICAgICBjb25zdCBpbk5hbWVzcGFjZSA9IHR5cGVFdmVudCAhPT0gb3JpZ2luYWxUeXBlRXZlbnQ7XHJcbiAgICAgIGNvbnN0IGV2ZW50cyA9IGdldEVsZW1lbnRFdmVudHMoZWxlbWVudCk7XHJcbiAgICAgIGNvbnN0IHN0b3JlRWxlbWVudEV2ZW50ID0gZXZlbnRzW3R5cGVFdmVudF0gfHwge307XHJcbiAgICAgIGNvbnN0IGlzTmFtZXNwYWNlID0gb3JpZ2luYWxUeXBlRXZlbnQuc3RhcnRzV2l0aCgnLicpO1xyXG4gICAgICBpZiAodHlwZW9mIGNhbGxhYmxlICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIC8vIFNpbXBsZXN0IGNhc2U6IGhhbmRsZXIgaXMgcGFzc2VkLCByZW1vdmUgdGhhdCBsaXN0ZW5lciBPTkxZLlxyXG4gICAgICAgIGlmICghT2JqZWN0LmtleXMoc3RvcmVFbGVtZW50RXZlbnQpLmxlbmd0aCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBjYWxsYWJsZSwgaXNEZWxlZ2F0ZWQgPyBoYW5kbGVyIDogbnVsbCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc05hbWVzcGFjZSkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudEV2ZW50IG9mIE9iamVjdC5rZXlzKGV2ZW50cykpIHtcclxuICAgICAgICAgIHJlbW92ZU5hbWVzcGFjZWRIYW5kbGVycyhlbGVtZW50LCBldmVudHMsIGVsZW1lbnRFdmVudCwgb3JpZ2luYWxUeXBlRXZlbnQuc2xpY2UoMSkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBmb3IgKGNvbnN0IFtrZXlIYW5kbGVycywgZXZlbnRdIG9mIE9iamVjdC5lbnRyaWVzKHN0b3JlRWxlbWVudEV2ZW50KSkge1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZXJLZXkgPSBrZXlIYW5kbGVycy5yZXBsYWNlKHN0cmlwVWlkUmVnZXgsICcnKTtcclxuICAgICAgICBpZiAoIWluTmFtZXNwYWNlIHx8IG9yaWdpbmFsVHlwZUV2ZW50LmluY2x1ZGVzKGhhbmRsZXJLZXkpKSB7XHJcbiAgICAgICAgICByZW1vdmVIYW5kbGVyKGVsZW1lbnQsIGV2ZW50cywgdHlwZUV2ZW50LCBldmVudC5jYWxsYWJsZSwgZXZlbnQuZGVsZWdhdGlvblNlbGVjdG9yKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0sXHJcbiAgICB0cmlnZ2VyKGVsZW1lbnQsIGV2ZW50LCBhcmdzKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdzdHJpbmcnIHx8ICFlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgJCA9IGdldGpRdWVyeSgpO1xyXG4gICAgICBjb25zdCB0eXBlRXZlbnQgPSBnZXRUeXBlRXZlbnQoZXZlbnQpO1xyXG4gICAgICBjb25zdCBpbk5hbWVzcGFjZSA9IGV2ZW50ICE9PSB0eXBlRXZlbnQ7XHJcbiAgICAgIGxldCBqUXVlcnlFdmVudCA9IG51bGw7XHJcbiAgICAgIGxldCBidWJibGVzID0gdHJ1ZTtcclxuICAgICAgbGV0IG5hdGl2ZURpc3BhdGNoID0gdHJ1ZTtcclxuICAgICAgbGV0IGRlZmF1bHRQcmV2ZW50ZWQgPSBmYWxzZTtcclxuICAgICAgaWYgKGluTmFtZXNwYWNlICYmICQpIHtcclxuICAgICAgICBqUXVlcnlFdmVudCA9ICQuRXZlbnQoZXZlbnQsIGFyZ3MpO1xyXG4gICAgICAgICQoZWxlbWVudCkudHJpZ2dlcihqUXVlcnlFdmVudCk7XHJcbiAgICAgICAgYnViYmxlcyA9ICFqUXVlcnlFdmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpO1xyXG4gICAgICAgIG5hdGl2ZURpc3BhdGNoID0gIWpRdWVyeUV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCk7XHJcbiAgICAgICAgZGVmYXVsdFByZXZlbnRlZCA9IGpRdWVyeUV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGV2dCA9IGh5ZHJhdGVPYmoobmV3IEV2ZW50KGV2ZW50LCB7XHJcbiAgICAgICAgYnViYmxlcyxcclxuICAgICAgICBjYW5jZWxhYmxlOiB0cnVlXHJcbiAgICAgIH0pLCBhcmdzKTtcclxuICAgICAgaWYgKGRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICBldnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAobmF0aXZlRGlzcGF0Y2gpIHtcclxuICAgICAgICBlbGVtZW50LmRpc3BhdGNoRXZlbnQoZXZ0KTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZXZ0LmRlZmF1bHRQcmV2ZW50ZWQgJiYgalF1ZXJ5RXZlbnQpIHtcclxuICAgICAgICBqUXVlcnlFdmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBldnQ7XHJcbiAgICB9XHJcbiAgfTtcclxuICBmdW5jdGlvbiBoeWRyYXRlT2JqKG9iaiwgbWV0YSA9IHt9KSB7XHJcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhtZXRhKSkge1xyXG4gICAgICB0cnkge1xyXG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XHJcbiAgICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcclxuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcclxuICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICAgIGdldCgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gb2JqO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgZG9tL21hbmlwdWxhdG9yLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcbiAgZnVuY3Rpb24gbm9ybWFsaXplRGF0YSh2YWx1ZSkge1xyXG4gICAgaWYgKHZhbHVlID09PSAndHJ1ZScpIHtcclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgPT09ICdmYWxzZScpIHtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgaWYgKHZhbHVlID09PSBOdW1iZXIodmFsdWUpLnRvU3RyaW5nKCkpIHtcclxuICAgICAgcmV0dXJuIE51bWJlcih2YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBpZiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSAnbnVsbCcpIHtcclxuICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJykge1xyXG4gICAgICByZXR1cm4gdmFsdWU7XHJcbiAgICB9XHJcbiAgICB0cnkge1xyXG4gICAgICByZXR1cm4gSlNPTi5wYXJzZShkZWNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcclxuICAgIH0gY2F0Y2ggKF91bnVzZWQpIHtcclxuICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gIH1cclxuICBmdW5jdGlvbiBub3JtYWxpemVEYXRhS2V5KGtleSkge1xyXG4gICAgcmV0dXJuIGtleS5yZXBsYWNlKC9bQS1aXS9nLCBjaHIgPT4gYC0ke2Noci50b0xvd2VyQ2FzZSgpfWApO1xyXG4gIH1cclxuICBjb25zdCBNYW5pcHVsYXRvciA9IHtcclxuICAgIHNldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwga2V5LCB2YWx1ZSkge1xyXG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShgZGF0YS1icy0ke25vcm1hbGl6ZURhdGFLZXkoa2V5KX1gLCB2YWx1ZSk7XHJcbiAgICB9LFxyXG4gICAgcmVtb3ZlRGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXkpIHtcclxuICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YCk7XHJcbiAgICB9LFxyXG4gICAgZ2V0RGF0YUF0dHJpYnV0ZXMoZWxlbWVudCkge1xyXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm4ge307XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgYXR0cmlidXRlcyA9IHt9O1xyXG4gICAgICBjb25zdCBic0tleXMgPSBPYmplY3Qua2V5cyhlbGVtZW50LmRhdGFzZXQpLmZpbHRlcihrZXkgPT4ga2V5LnN0YXJ0c1dpdGgoJ2JzJykgJiYgIWtleS5zdGFydHNXaXRoKCdic0NvbmZpZycpKTtcclxuICAgICAgZm9yIChjb25zdCBrZXkgb2YgYnNLZXlzKSB7XHJcbiAgICAgICAgbGV0IHB1cmVLZXkgPSBrZXkucmVwbGFjZSgvXmJzLywgJycpO1xyXG4gICAgICAgIHB1cmVLZXkgPSBwdXJlS2V5LmNoYXJBdCgwKS50b0xvd2VyQ2FzZSgpICsgcHVyZUtleS5zbGljZSgxKTtcclxuICAgICAgICBhdHRyaWJ1dGVzW3B1cmVLZXldID0gbm9ybWFsaXplRGF0YShlbGVtZW50LmRhdGFzZXRba2V5XSk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXM7XHJcbiAgICB9LFxyXG4gICAgZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBrZXkpIHtcclxuICAgICAgcmV0dXJuIG5vcm1hbGl6ZURhdGEoZWxlbWVudC5nZXRBdHRyaWJ1dGUoYGRhdGEtYnMtJHtub3JtYWxpemVEYXRhS2V5KGtleSl9YCkpO1xyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwIHV0aWwvY29uZmlnLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENsYXNzIGRlZmluaXRpb25cclxuICAgKi9cclxuXHJcbiAgY2xhc3MgQ29uZmlnIHtcclxuICAgIC8vIEdldHRlcnNcclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcclxuICAgICAgcmV0dXJuIHt9O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBoYXZlIHRvIGltcGxlbWVudCB0aGUgc3RhdGljIG1ldGhvZCBcIk5BTUVcIiwgZm9yIGVhY2ggY29tcG9uZW50IScpO1xyXG4gICAgfVxyXG4gICAgX2dldENvbmZpZyhjb25maWcpIHtcclxuICAgICAgY29uZmlnID0gdGhpcy5fbWVyZ2VDb25maWdPYmooY29uZmlnKTtcclxuICAgICAgY29uZmlnID0gdGhpcy5fY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpO1xyXG4gICAgICB0aGlzLl90eXBlQ2hlY2tDb25maWcoY29uZmlnKTtcclxuICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgIH1cclxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xyXG4gICAgICByZXR1cm4gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgX21lcmdlQ29uZmlnT2JqKGNvbmZpZywgZWxlbWVudCkge1xyXG4gICAgICBjb25zdCBqc29uQ29uZmlnID0gaXNFbGVtZW50JDEoZWxlbWVudCkgPyBNYW5pcHVsYXRvci5nZXREYXRhQXR0cmlidXRlKGVsZW1lbnQsICdjb25maWcnKSA6IHt9OyAvLyB0cnkgdG8gcGFyc2VcclxuXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4udGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0LFxyXG4gICAgICAgIC4uLih0eXBlb2YganNvbkNvbmZpZyA9PT0gJ29iamVjdCcgPyBqc29uQ29uZmlnIDoge30pLFxyXG4gICAgICAgIC4uLihpc0VsZW1lbnQkMShlbGVtZW50KSA/IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKGVsZW1lbnQpIDoge30pLFxyXG4gICAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyA/IGNvbmZpZyA6IHt9KVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgX3R5cGVDaGVja0NvbmZpZyhjb25maWcsIGNvbmZpZ1R5cGVzID0gdGhpcy5jb25zdHJ1Y3Rvci5EZWZhdWx0VHlwZSkge1xyXG4gICAgICBmb3IgKGNvbnN0IFtwcm9wZXJ0eSwgZXhwZWN0ZWRUeXBlc10gb2YgT2JqZWN0LmVudHJpZXMoY29uZmlnVHlwZXMpKSB7XHJcbiAgICAgICAgY29uc3QgdmFsdWUgPSBjb25maWdbcHJvcGVydHldO1xyXG4gICAgICAgIGNvbnN0IHZhbHVlVHlwZSA9IGlzRWxlbWVudCQxKHZhbHVlKSA/ICdlbGVtZW50JyA6IHRvVHlwZSh2YWx1ZSk7XHJcbiAgICAgICAgaWYgKCFuZXcgUmVnRXhwKGV4cGVjdGVkVHlwZXMpLnRlc3QodmFsdWVUeXBlKSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHt0aGlzLmNvbnN0cnVjdG9yLk5BTUUudG9VcHBlckNhc2UoKX06IE9wdGlvbiBcIiR7cHJvcGVydHl9XCIgcHJvdmlkZWQgdHlwZSBcIiR7dmFsdWVUeXBlfVwiIGJ1dCBleHBlY3RlZCB0eXBlIFwiJHtleHBlY3RlZFR5cGVzfVwiLmApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgYmFzZS1jb21wb25lbnQuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IFZFUlNJT04gPSAnNS4zLjcnO1xyXG5cclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIEJhc2VDb21wb25lbnQgZXh0ZW5kcyBDb25maWcge1xyXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIGVsZW1lbnQgPSBnZXRFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xyXG4gICAgICBEYXRhLnNldCh0aGlzLl9lbGVtZW50LCB0aGlzLmNvbnN0cnVjdG9yLkRBVEFfS0VZLCB0aGlzKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQdWJsaWNcclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgIERhdGEucmVtb3ZlKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuREFUQV9LRVkpO1xyXG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuRVZFTlRfS0VZKTtcclxuICAgICAgZm9yIChjb25zdCBwcm9wZXJ0eU5hbWUgb2YgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModGhpcykpIHtcclxuICAgICAgICB0aGlzW3Byb3BlcnR5TmFtZV0gPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJpdmF0ZVxyXG4gICAgX3F1ZXVlQ2FsbGJhY2soY2FsbGJhY2ssIGVsZW1lbnQsIGlzQW5pbWF0ZWQgPSB0cnVlKSB7XHJcbiAgICAgIGV4ZWN1dGVBZnRlclRyYW5zaXRpb24oY2FsbGJhY2ssIGVsZW1lbnQsIGlzQW5pbWF0ZWQpO1xyXG4gICAgfVxyXG4gICAgX2dldENvbmZpZyhjb25maWcpIHtcclxuICAgICAgY29uZmlnID0gdGhpcy5fbWVyZ2VDb25maWdPYmooY29uZmlnLCB0aGlzLl9lbGVtZW50KTtcclxuICAgICAgY29uZmlnID0gdGhpcy5fY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpO1xyXG4gICAgICB0aGlzLl90eXBlQ2hlY2tDb25maWcoY29uZmlnKTtcclxuICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGF0aWNcclxuICAgIHN0YXRpYyBnZXRJbnN0YW5jZShlbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBEYXRhLmdldChnZXRFbGVtZW50KGVsZW1lbnQpLCB0aGlzLkRBVEFfS0VZKTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIGNvbmZpZyA9IHt9KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKGVsZW1lbnQpIHx8IG5ldyB0aGlzKGVsZW1lbnQsIHR5cGVvZiBjb25maWcgPT09ICdvYmplY3QnID8gY29uZmlnIDogbnVsbCk7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IFZFUlNJT04oKSB7XHJcbiAgICAgIHJldHVybiBWRVJTSU9OO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBEQVRBX0tFWSgpIHtcclxuICAgICAgcmV0dXJuIGBicy4ke3RoaXMuTkFNRX1gO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBFVkVOVF9LRVkoKSB7XHJcbiAgICAgIHJldHVybiBgLiR7dGhpcy5EQVRBX0tFWX1gO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGV2ZW50TmFtZShuYW1lKSB7XHJcbiAgICAgIHJldHVybiBgJHtuYW1lfSR7dGhpcy5FVkVOVF9LRVl9YDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwIGRvbS9zZWxlY3Rvci1lbmdpbmUuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuICBjb25zdCBnZXRTZWxlY3RvciA9IGVsZW1lbnQgPT4ge1xyXG4gICAgbGV0IHNlbGVjdG9yID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtdGFyZ2V0Jyk7XHJcbiAgICBpZiAoIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSAnIycpIHtcclxuICAgICAgbGV0IGhyZWZBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaHJlZicpO1xyXG5cclxuICAgICAgLy8gVGhlIG9ubHkgdmFsaWQgY29udGVudCB0aGF0IGNvdWxkIGRvdWJsZSBhcyBhIHNlbGVjdG9yIGFyZSBJRHMgb3IgY2xhc3NlcyxcclxuICAgICAgLy8gc28gZXZlcnl0aGluZyBzdGFydGluZyB3aXRoIGAjYCBvciBgLmAuIElmIGEgXCJyZWFsXCIgVVJMIGlzIHVzZWQgYXMgdGhlIHNlbGVjdG9yLFxyXG4gICAgICAvLyBgZG9jdW1lbnQucXVlcnlTZWxlY3RvcmAgd2lsbCByaWdodGZ1bGx5IGNvbXBsYWluIGl0IGlzIGludmFsaWQuXHJcbiAgICAgIC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvaXNzdWVzLzMyMjczXHJcbiAgICAgIGlmICghaHJlZkF0dHJpYnV0ZSB8fCAhaHJlZkF0dHJpYnV0ZS5pbmNsdWRlcygnIycpICYmICFocmVmQXR0cmlidXRlLnN0YXJ0c1dpdGgoJy4nKSkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBKdXN0IGluIGNhc2Ugc29tZSBDTVMgcHV0cyBvdXQgYSBmdWxsIFVSTCB3aXRoIHRoZSBhbmNob3IgYXBwZW5kZWRcclxuICAgICAgaWYgKGhyZWZBdHRyaWJ1dGUuaW5jbHVkZXMoJyMnKSAmJiAhaHJlZkF0dHJpYnV0ZS5zdGFydHNXaXRoKCcjJykpIHtcclxuICAgICAgICBocmVmQXR0cmlidXRlID0gYCMke2hyZWZBdHRyaWJ1dGUuc3BsaXQoJyMnKVsxXX1gO1xyXG4gICAgICB9XHJcbiAgICAgIHNlbGVjdG9yID0gaHJlZkF0dHJpYnV0ZSAmJiBocmVmQXR0cmlidXRlICE9PSAnIycgPyBocmVmQXR0cmlidXRlLnRyaW0oKSA6IG51bGw7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gc2VsZWN0b3IgPyBzZWxlY3Rvci5zcGxpdCgnLCcpLm1hcChzZWwgPT4gcGFyc2VTZWxlY3RvcihzZWwpKS5qb2luKCcsJykgOiBudWxsO1xyXG4gIH07XHJcbiAgY29uc3QgU2VsZWN0b3JFbmdpbmUgPSB7XHJcbiAgICBmaW5kKHNlbGVjdG9yLCBlbGVtZW50ID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KSB7XHJcbiAgICAgIHJldHVybiBbXS5jb25jYXQoLi4uRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbC5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKSk7XHJcbiAgICB9LFxyXG4gICAgZmluZE9uZShzZWxlY3RvciwgZWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3Rvci5jYWxsKGVsZW1lbnQsIHNlbGVjdG9yKTtcclxuICAgIH0sXHJcbiAgICBjaGlsZHJlbihlbGVtZW50LCBzZWxlY3Rvcikge1xyXG4gICAgICByZXR1cm4gW10uY29uY2F0KC4uLmVsZW1lbnQuY2hpbGRyZW4pLmZpbHRlcihjaGlsZCA9PiBjaGlsZC5tYXRjaGVzKHNlbGVjdG9yKSk7XHJcbiAgICB9LFxyXG4gICAgcGFyZW50cyhlbGVtZW50LCBzZWxlY3Rvcikge1xyXG4gICAgICBjb25zdCBwYXJlbnRzID0gW107XHJcbiAgICAgIGxldCBhbmNlc3RvciA9IGVsZW1lbnQucGFyZW50Tm9kZS5jbG9zZXN0KHNlbGVjdG9yKTtcclxuICAgICAgd2hpbGUgKGFuY2VzdG9yKSB7XHJcbiAgICAgICAgcGFyZW50cy5wdXNoKGFuY2VzdG9yKTtcclxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudE5vZGUuY2xvc2VzdChzZWxlY3Rvcik7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHBhcmVudHM7XHJcbiAgICB9LFxyXG4gICAgcHJldihlbGVtZW50LCBzZWxlY3Rvcikge1xyXG4gICAgICBsZXQgcHJldmlvdXMgPSBlbGVtZW50LnByZXZpb3VzRWxlbWVudFNpYmxpbmc7XHJcbiAgICAgIHdoaWxlIChwcmV2aW91cykge1xyXG4gICAgICAgIGlmIChwcmV2aW91cy5tYXRjaGVzKHNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgcmV0dXJuIFtwcmV2aW91c107XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXZpb3VzID0gcHJldmlvdXMucHJldmlvdXNFbGVtZW50U2libGluZztcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gW107XHJcbiAgICB9LFxyXG4gICAgLy8gVE9ETzogdGhpcyBpcyBub3cgdW51c2VkOyByZW1vdmUgbGF0ZXIgYWxvbmcgd2l0aCBwcmV2KClcclxuICAgIG5leHQoZWxlbWVudCwgc2VsZWN0b3IpIHtcclxuICAgICAgbGV0IG5leHQgPSBlbGVtZW50Lm5leHRFbGVtZW50U2libGluZztcclxuICAgICAgd2hpbGUgKG5leHQpIHtcclxuICAgICAgICBpZiAobmV4dC5tYXRjaGVzKHNlbGVjdG9yKSkge1xyXG4gICAgICAgICAgcmV0dXJuIFtuZXh0XTtcclxuICAgICAgICB9XHJcbiAgICAgICAgbmV4dCA9IG5leHQubmV4dEVsZW1lbnRTaWJsaW5nO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH0sXHJcbiAgICBmb2N1c2FibGVDaGlsZHJlbihlbGVtZW50KSB7XHJcbiAgICAgIGNvbnN0IGZvY3VzYWJsZXMgPSBbJ2EnLCAnYnV0dG9uJywgJ2lucHV0JywgJ3RleHRhcmVhJywgJ3NlbGVjdCcsICdkZXRhaWxzJywgJ1t0YWJpbmRleF0nLCAnW2NvbnRlbnRlZGl0YWJsZT1cInRydWVcIl0nXS5tYXAoc2VsZWN0b3IgPT4gYCR7c2VsZWN0b3J9Om5vdChbdGFiaW5kZXhePVwiLVwiXSlgKS5qb2luKCcsJyk7XHJcbiAgICAgIHJldHVybiB0aGlzLmZpbmQoZm9jdXNhYmxlcywgZWxlbWVudCkuZmlsdGVyKGVsID0+ICFpc0Rpc2FibGVkKGVsKSAmJiBpc1Zpc2libGUoZWwpKTtcclxuICAgIH0sXHJcbiAgICBnZXRTZWxlY3RvckZyb21FbGVtZW50KGVsZW1lbnQpIHtcclxuICAgICAgY29uc3Qgc2VsZWN0b3IgPSBnZXRTZWxlY3RvcihlbGVtZW50KTtcclxuICAgICAgaWYgKHNlbGVjdG9yKSB7XHJcbiAgICAgICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoc2VsZWN0b3IpID8gc2VsZWN0b3IgOiBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfSxcclxuICAgIGdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCkge1xyXG4gICAgICBjb25zdCBzZWxlY3RvciA9IGdldFNlbGVjdG9yKGVsZW1lbnQpO1xyXG4gICAgICByZXR1cm4gc2VsZWN0b3IgPyBTZWxlY3RvckVuZ2luZS5maW5kT25lKHNlbGVjdG9yKSA6IG51bGw7XHJcbiAgICB9LFxyXG4gICAgZ2V0TXVsdGlwbGVFbGVtZW50c0Zyb21TZWxlY3RvcihlbGVtZW50KSB7XHJcbiAgICAgIGNvbnN0IHNlbGVjdG9yID0gZ2V0U2VsZWN0b3IoZWxlbWVudCk7XHJcbiAgICAgIHJldHVybiBzZWxlY3RvciA/IFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IpIDogW107XHJcbiAgICB9XHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgdXRpbC9jb21wb25lbnQtZnVuY3Rpb25zLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcbiAgY29uc3QgZW5hYmxlRGlzbWlzc1RyaWdnZXIgPSAoY29tcG9uZW50LCBtZXRob2QgPSAnaGlkZScpID0+IHtcclxuICAgIGNvbnN0IGNsaWNrRXZlbnQgPSBgY2xpY2suZGlzbWlzcyR7Y29tcG9uZW50LkVWRU5UX0tFWX1gO1xyXG4gICAgY29uc3QgbmFtZSA9IGNvbXBvbmVudC5OQU1FO1xyXG4gICAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBjbGlja0V2ZW50LCBgW2RhdGEtYnMtZGlzbWlzcz1cIiR7bmFtZX1cIl1gLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgaWYgKFsnQScsICdBUkVBJ10uaW5jbHVkZXModGhpcy50YWdOYW1lKSkge1xyXG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKGlzRGlzYWJsZWQodGhpcykpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgdGFyZ2V0ID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3Rvcih0aGlzKSB8fCB0aGlzLmNsb3Nlc3QoYC4ke25hbWV9YCk7XHJcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gY29tcG9uZW50LmdldE9yQ3JlYXRlSW5zdGFuY2UodGFyZ2V0KTtcclxuXHJcbiAgICAgIC8vIE1ldGhvZCBhcmd1bWVudCBpcyBsZWZ0LCBmb3IgQWxlcnQgYW5kIG9ubHksIGFzIGl0IGRvZXNuJ3QgaW1wbGVtZW50IHRoZSAnaGlkZScgbWV0aG9kXHJcbiAgICAgIGluc3RhbmNlW21ldGhvZF0oKTtcclxuICAgIH0pO1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwIGFsZXJ0LmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBOQU1FJGYgPSAnYWxlcnQnO1xyXG4gIGNvbnN0IERBVEFfS0VZJGEgPSAnYnMuYWxlcnQnO1xyXG4gIGNvbnN0IEVWRU5UX0tFWSRiID0gYC4ke0RBVEFfS0VZJGF9YDtcclxuICBjb25zdCBFVkVOVF9DTE9TRSA9IGBjbG9zZSR7RVZFTlRfS0VZJGJ9YDtcclxuICBjb25zdCBFVkVOVF9DTE9TRUQgPSBgY2xvc2VkJHtFVkVOVF9LRVkkYn1gO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQ1ID0gJ2ZhZGUnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQ4ID0gJ3Nob3cnO1xyXG5cclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIEFsZXJ0IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAvLyBHZXR0ZXJzXHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHJldHVybiBOQU1FJGY7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHVibGljXHJcbiAgICBjbG9zZSgpIHtcclxuICAgICAgY29uc3QgY2xvc2VFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0NMT1NFKTtcclxuICAgICAgaWYgKGNsb3NlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDgpO1xyXG4gICAgICBjb25zdCBpc0FuaW1hdGVkID0gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDUpO1xyXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKCgpID0+IHRoaXMuX2Rlc3Ryb3lFbGVtZW50KCksIHRoaXMuX2VsZW1lbnQsIGlzQW5pbWF0ZWQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByaXZhdGVcclxuICAgIF9kZXN0cm95RWxlbWVudCgpIHtcclxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmUoKTtcclxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfQ0xPU0VEKTtcclxuICAgICAgdGhpcy5kaXNwb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RhdGljXHJcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gQWxlcnQuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cclxuICAgKi9cclxuXHJcbiAgZW5hYmxlRGlzbWlzc1RyaWdnZXIoQWxlcnQsICdjbG9zZScpO1xyXG5cclxuICAvKipcclxuICAgKiBqUXVlcnlcclxuICAgKi9cclxuXHJcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKEFsZXJ0KTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgYnV0dG9uLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBOQU1FJGUgPSAnYnV0dG9uJztcclxuICBjb25zdCBEQVRBX0tFWSQ5ID0gJ2JzLmJ1dHRvbic7XHJcbiAgY29uc3QgRVZFTlRfS0VZJGEgPSBgLiR7REFUQV9LRVkkOX1gO1xyXG4gIGNvbnN0IERBVEFfQVBJX0tFWSQ2ID0gJy5kYXRhLWFwaSc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUkMyA9ICdhY3RpdmUnO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDUgPSAnW2RhdGEtYnMtdG9nZ2xlPVwiYnV0dG9uXCJdJztcclxuICBjb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQ2ID0gYGNsaWNrJHtFVkVOVF9LRVkkYX0ke0RBVEFfQVBJX0tFWSQ2fWA7XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYXNzIGRlZmluaXRpb25cclxuICAgKi9cclxuXHJcbiAgY2xhc3MgQnV0dG9uIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICAvLyBHZXR0ZXJzXHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHJldHVybiBOQU1FJGU7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHVibGljXHJcbiAgICB0b2dnbGUoKSB7XHJcbiAgICAgIC8vIFRvZ2dsZSBjbGFzcyBhbmQgc3luYyB0aGUgYGFyaWEtcHJlc3NlZGAgYXR0cmlidXRlIHdpdGggdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgYC50b2dnbGUoKWAgbWV0aG9kXHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXByZXNzZWQnLCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC50b2dnbGUoQ0xBU1NfTkFNRV9BQ1RJVkUkMykpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0YXRpY1xyXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IEJ1dHRvbi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xyXG4gICAgICAgIGlmIChjb25maWcgPT09ICd0b2dnbGUnKSB7XHJcbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cclxuICAgKi9cclxuXHJcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQ2LCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ1LCBldmVudCA9PiB7XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgY29uc3QgYnV0dG9uID0gZXZlbnQudGFyZ2V0LmNsb3Nlc3QoU0VMRUNUT1JfREFUQV9UT0dHTEUkNSk7XHJcbiAgICBjb25zdCBkYXRhID0gQnV0dG9uLmdldE9yQ3JlYXRlSW5zdGFuY2UoYnV0dG9uKTtcclxuICAgIGRhdGEudG9nZ2xlKCk7XHJcbiAgfSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIGpRdWVyeVxyXG4gICAqL1xyXG5cclxuICBkZWZpbmVKUXVlcnlQbHVnaW4oQnV0dG9uKTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgdXRpbC9zd2lwZS5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcblxyXG5cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgTkFNRSRkID0gJ3N3aXBlJztcclxuICBjb25zdCBFVkVOVF9LRVkkOSA9ICcuYnMuc3dpcGUnO1xyXG4gIGNvbnN0IEVWRU5UX1RPVUNIU1RBUlQgPSBgdG91Y2hzdGFydCR7RVZFTlRfS0VZJDl9YDtcclxuICBjb25zdCBFVkVOVF9UT1VDSE1PVkUgPSBgdG91Y2htb3ZlJHtFVkVOVF9LRVkkOX1gO1xyXG4gIGNvbnN0IEVWRU5UX1RPVUNIRU5EID0gYHRvdWNoZW5kJHtFVkVOVF9LRVkkOX1gO1xyXG4gIGNvbnN0IEVWRU5UX1BPSU5URVJET1dOID0gYHBvaW50ZXJkb3duJHtFVkVOVF9LRVkkOX1gO1xyXG4gIGNvbnN0IEVWRU5UX1BPSU5URVJVUCA9IGBwb2ludGVydXAke0VWRU5UX0tFWSQ5fWA7XHJcbiAgY29uc3QgUE9JTlRFUl9UWVBFX1RPVUNIID0gJ3RvdWNoJztcclxuICBjb25zdCBQT0lOVEVSX1RZUEVfUEVOID0gJ3Blbic7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9QT0lOVEVSX0VWRU5UID0gJ3BvaW50ZXItZXZlbnQnO1xyXG4gIGNvbnN0IFNXSVBFX1RIUkVTSE9MRCA9IDQwO1xyXG4gIGNvbnN0IERlZmF1bHQkYyA9IHtcclxuICAgIGVuZENhbGxiYWNrOiBudWxsLFxyXG4gICAgbGVmdENhbGxiYWNrOiBudWxsLFxyXG4gICAgcmlnaHRDYWxsYmFjazogbnVsbFxyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdFR5cGUkYyA9IHtcclxuICAgIGVuZENhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJyxcclxuICAgIGxlZnRDYWxsYmFjazogJyhmdW5jdGlvbnxudWxsKScsXHJcbiAgICByaWdodENhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJ1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYXNzIGRlZmluaXRpb25cclxuICAgKi9cclxuXHJcbiAgY2xhc3MgU3dpcGUgZXh0ZW5kcyBDb25maWcge1xyXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBlbGVtZW50O1xyXG4gICAgICBpZiAoIWVsZW1lbnQgfHwgIVN3aXBlLmlzU3VwcG9ydGVkKCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XHJcbiAgICAgIHRoaXMuX2RlbHRhWCA9IDA7XHJcbiAgICAgIHRoaXMuX3N1cHBvcnRQb2ludGVyRXZlbnRzID0gQm9vbGVhbih3aW5kb3cuUG9pbnRlckV2ZW50KTtcclxuICAgICAgdGhpcy5faW5pdEV2ZW50cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldHRlcnNcclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHQkYztcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSRjO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgICByZXR1cm4gTkFNRSRkO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFB1YmxpY1xyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgRXZlbnRIYW5kbGVyLm9mZih0aGlzLl9lbGVtZW50LCBFVkVOVF9LRVkkOSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJpdmF0ZVxyXG4gICAgX3N0YXJ0KGV2ZW50KSB7XHJcbiAgICAgIGlmICghdGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMpIHtcclxuICAgICAgICB0aGlzLl9kZWx0YVggPSBldmVudC50b3VjaGVzWzBdLmNsaWVudFg7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLl9ldmVudElzUG9pbnRlclBlblRvdWNoKGV2ZW50KSkge1xyXG4gICAgICAgIHRoaXMuX2RlbHRhWCA9IGV2ZW50LmNsaWVudFg7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIF9lbmQoZXZlbnQpIHtcclxuICAgICAgaWYgKHRoaXMuX2V2ZW50SXNQb2ludGVyUGVuVG91Y2goZXZlbnQpKSB7XHJcbiAgICAgICAgdGhpcy5fZGVsdGFYID0gZXZlbnQuY2xpZW50WCAtIHRoaXMuX2RlbHRhWDtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9oYW5kbGVTd2lwZSgpO1xyXG4gICAgICBleGVjdXRlKHRoaXMuX2NvbmZpZy5lbmRDYWxsYmFjayk7XHJcbiAgICB9XHJcbiAgICBfbW92ZShldmVudCkge1xyXG4gICAgICB0aGlzLl9kZWx0YVggPSBldmVudC50b3VjaGVzICYmIGV2ZW50LnRvdWNoZXMubGVuZ3RoID4gMSA/IDAgOiBldmVudC50b3VjaGVzWzBdLmNsaWVudFggLSB0aGlzLl9kZWx0YVg7XHJcbiAgICB9XHJcbiAgICBfaGFuZGxlU3dpcGUoKSB7XHJcbiAgICAgIGNvbnN0IGFic0RlbHRhWCA9IE1hdGguYWJzKHRoaXMuX2RlbHRhWCk7XHJcbiAgICAgIGlmIChhYnNEZWx0YVggPD0gU1dJUEVfVEhSRVNIT0xEKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGRpcmVjdGlvbiA9IGFic0RlbHRhWCAvIHRoaXMuX2RlbHRhWDtcclxuICAgICAgdGhpcy5fZGVsdGFYID0gMDtcclxuICAgICAgaWYgKCFkaXJlY3Rpb24pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgZXhlY3V0ZShkaXJlY3Rpb24gPiAwID8gdGhpcy5fY29uZmlnLnJpZ2h0Q2FsbGJhY2sgOiB0aGlzLl9jb25maWcubGVmdENhbGxiYWNrKTtcclxuICAgIH1cclxuICAgIF9pbml0RXZlbnRzKCkge1xyXG4gICAgICBpZiAodGhpcy5fc3VwcG9ydFBvaW50ZXJFdmVudHMpIHtcclxuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfUE9JTlRFUkRPV04sIGV2ZW50ID0+IHRoaXMuX3N0YXJ0KGV2ZW50KSk7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1BPSU5URVJVUCwgZXZlbnQgPT4gdGhpcy5fZW5kKGV2ZW50KSk7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfUE9JTlRFUl9FVkVOVCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNIU1RBUlQsIGV2ZW50ID0+IHRoaXMuX3N0YXJ0KGV2ZW50KSk7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1RPVUNITU9WRSwgZXZlbnQgPT4gdGhpcy5fbW92ZShldmVudCkpO1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9UT1VDSEVORCwgZXZlbnQgPT4gdGhpcy5fZW5kKGV2ZW50KSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIF9ldmVudElzUG9pbnRlclBlblRvdWNoKGV2ZW50KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9zdXBwb3J0UG9pbnRlckV2ZW50cyAmJiAoZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9QRU4gfHwgZXZlbnQucG9pbnRlclR5cGUgPT09IFBPSU5URVJfVFlQRV9UT1VDSCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RhdGljXHJcbiAgICBzdGF0aWMgaXNTdXBwb3J0ZWQoKSB7XHJcbiAgICAgIHJldHVybiAnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgfHwgbmF2aWdhdG9yLm1heFRvdWNoUG9pbnRzID4gMDtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwIGNhcm91c2VsLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBOQU1FJGMgPSAnY2Fyb3VzZWwnO1xyXG4gIGNvbnN0IERBVEFfS0VZJDggPSAnYnMuY2Fyb3VzZWwnO1xyXG4gIGNvbnN0IEVWRU5UX0tFWSQ4ID0gYC4ke0RBVEFfS0VZJDh9YDtcclxuICBjb25zdCBEQVRBX0FQSV9LRVkkNSA9ICcuZGF0YS1hcGknO1xyXG4gIGNvbnN0IEFSUk9XX0xFRlRfS0VZJDEgPSAnQXJyb3dMZWZ0JztcclxuICBjb25zdCBBUlJPV19SSUdIVF9LRVkkMSA9ICdBcnJvd1JpZ2h0JztcclxuICBjb25zdCBUT1VDSEVWRU5UX0NPTVBBVF9XQUlUID0gNTAwOyAvLyBUaW1lIGZvciBtb3VzZSBjb21wYXQgZXZlbnRzIHRvIGZpcmUgYWZ0ZXIgdG91Y2hcclxuXHJcbiAgY29uc3QgT1JERVJfTkVYVCA9ICduZXh0JztcclxuICBjb25zdCBPUkRFUl9QUkVWID0gJ3ByZXYnO1xyXG4gIGNvbnN0IERJUkVDVElPTl9MRUZUID0gJ2xlZnQnO1xyXG4gIGNvbnN0IERJUkVDVElPTl9SSUdIVCA9ICdyaWdodCc7XHJcbiAgY29uc3QgRVZFTlRfU0xJREUgPSBgc2xpZGUke0VWRU5UX0tFWSQ4fWA7XHJcbiAgY29uc3QgRVZFTlRfU0xJRCA9IGBzbGlkJHtFVkVOVF9LRVkkOH1gO1xyXG4gIGNvbnN0IEVWRU5UX0tFWURPV04kMSA9IGBrZXlkb3duJHtFVkVOVF9LRVkkOH1gO1xyXG4gIGNvbnN0IEVWRU5UX01PVVNFRU5URVIkMSA9IGBtb3VzZWVudGVyJHtFVkVOVF9LRVkkOH1gO1xyXG4gIGNvbnN0IEVWRU5UX01PVVNFTEVBVkUkMSA9IGBtb3VzZWxlYXZlJHtFVkVOVF9LRVkkOH1gO1xyXG4gIGNvbnN0IEVWRU5UX0RSQUdfU1RBUlQgPSBgZHJhZ3N0YXJ0JHtFVkVOVF9LRVkkOH1gO1xyXG4gIGNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkkMyA9IGBsb2FkJHtFVkVOVF9LRVkkOH0ke0RBVEFfQVBJX0tFWSQ1fWA7XHJcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNSA9IGBjbGljayR7RVZFTlRfS0VZJDh9JHtEQVRBX0FQSV9LRVkkNX1gO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfQ0FST1VTRUwgPSAnY2Fyb3VzZWwnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfQUNUSVZFJDIgPSAnYWN0aXZlJztcclxuICBjb25zdCBDTEFTU19OQU1FX1NMSURFID0gJ3NsaWRlJztcclxuICBjb25zdCBDTEFTU19OQU1FX0VORCA9ICdjYXJvdXNlbC1pdGVtLWVuZCc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9TVEFSVCA9ICdjYXJvdXNlbC1pdGVtLXN0YXJ0JztcclxuICBjb25zdCBDTEFTU19OQU1FX05FWFQgPSAnY2Fyb3VzZWwtaXRlbS1uZXh0JztcclxuICBjb25zdCBDTEFTU19OQU1FX1BSRVYgPSAnY2Fyb3VzZWwtaXRlbS1wcmV2JztcclxuICBjb25zdCBTRUxFQ1RPUl9BQ1RJVkUgPSAnLmFjdGl2ZSc7XHJcbiAgY29uc3QgU0VMRUNUT1JfSVRFTSA9ICcuY2Fyb3VzZWwtaXRlbSc7XHJcbiAgY29uc3QgU0VMRUNUT1JfQUNUSVZFX0lURU0gPSBTRUxFQ1RPUl9BQ1RJVkUgKyBTRUxFQ1RPUl9JVEVNO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0lURU1fSU1HID0gJy5jYXJvdXNlbC1pdGVtIGltZyc7XHJcbiAgY29uc3QgU0VMRUNUT1JfSU5ESUNBVE9SUyA9ICcuY2Fyb3VzZWwtaW5kaWNhdG9ycyc7XHJcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9TTElERSA9ICdbZGF0YS1icy1zbGlkZV0sIFtkYXRhLWJzLXNsaWRlLXRvXSc7XHJcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9SSURFID0gJ1tkYXRhLWJzLXJpZGU9XCJjYXJvdXNlbFwiXSc7XHJcbiAgY29uc3QgS0VZX1RPX0RJUkVDVElPTiA9IHtcclxuICAgIFtBUlJPV19MRUZUX0tFWSQxXTogRElSRUNUSU9OX1JJR0hULFxyXG4gICAgW0FSUk9XX1JJR0hUX0tFWSQxXTogRElSRUNUSU9OX0xFRlRcclxuICB9O1xyXG4gIGNvbnN0IERlZmF1bHQkYiA9IHtcclxuICAgIGludGVydmFsOiA1MDAwLFxyXG4gICAga2V5Ym9hcmQ6IHRydWUsXHJcbiAgICBwYXVzZTogJ2hvdmVyJyxcclxuICAgIHJpZGU6IGZhbHNlLFxyXG4gICAgdG91Y2g6IHRydWUsXHJcbiAgICB3cmFwOiB0cnVlXHJcbiAgfTtcclxuICBjb25zdCBEZWZhdWx0VHlwZSRiID0ge1xyXG4gICAgaW50ZXJ2YWw6ICcobnVtYmVyfGJvb2xlYW4pJyxcclxuICAgIC8vIFRPRE86djYgcmVtb3ZlIGJvb2xlYW4gc3VwcG9ydFxyXG4gICAga2V5Ym9hcmQ6ICdib29sZWFuJyxcclxuICAgIHBhdXNlOiAnKHN0cmluZ3xib29sZWFuKScsXHJcbiAgICByaWRlOiAnKGJvb2xlYW58c3RyaW5nKScsXHJcbiAgICB0b3VjaDogJ2Jvb2xlYW4nLFxyXG4gICAgd3JhcDogJ2Jvb2xlYW4nXHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBDYXJvdXNlbCBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XHJcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XHJcbiAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcclxuICAgICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IG51bGw7XHJcbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IGZhbHNlO1xyXG4gICAgICB0aGlzLnRvdWNoVGltZW91dCA9IG51bGw7XHJcbiAgICAgIHRoaXMuX3N3aXBlSGVscGVyID0gbnVsbDtcclxuICAgICAgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0lORElDQVRPUlMsIHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgICB0aGlzLl9hZGRFdmVudExpc3RlbmVycygpO1xyXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnJpZGUgPT09IENMQVNTX05BTUVfQ0FST1VTRUwpIHtcclxuICAgICAgICB0aGlzLmN5Y2xlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXR0ZXJzXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0JGI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkYjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcclxuICAgICAgcmV0dXJuIE5BTUUkYztcclxuICAgIH1cclxuXHJcbiAgICAvLyBQdWJsaWNcclxuICAgIG5leHQoKSB7XHJcbiAgICAgIHRoaXMuX3NsaWRlKE9SREVSX05FWFQpO1xyXG4gICAgfVxyXG4gICAgbmV4dFdoZW5WaXNpYmxlKCkge1xyXG4gICAgICAvLyBGSVhNRSBUT0RPIHVzZSBgZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlYFxyXG4gICAgICAvLyBEb24ndCBjYWxsIG5leHQgd2hlbiB0aGUgcGFnZSBpc24ndCB2aXNpYmxlXHJcbiAgICAgIC8vIG9yIHRoZSBjYXJvdXNlbCBvciBpdHMgcGFyZW50IGlzbid0IHZpc2libGVcclxuICAgICAgaWYgKCFkb2N1bWVudC5oaWRkZW4gJiYgaXNWaXNpYmxlKHRoaXMuX2VsZW1lbnQpKSB7XHJcbiAgICAgICAgdGhpcy5uZXh0KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHByZXYoKSB7XHJcbiAgICAgIHRoaXMuX3NsaWRlKE9SREVSX1BSRVYpO1xyXG4gICAgfVxyXG4gICAgcGF1c2UoKSB7XHJcbiAgICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcclxuICAgICAgICB0cmlnZ2VyVHJhbnNpdGlvbkVuZCh0aGlzLl9lbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9jbGVhckludGVydmFsKCk7XHJcbiAgICB9XHJcbiAgICBjeWNsZSgpIHtcclxuICAgICAgdGhpcy5fY2xlYXJJbnRlcnZhbCgpO1xyXG4gICAgICB0aGlzLl91cGRhdGVJbnRlcnZhbCgpO1xyXG4gICAgICB0aGlzLl9pbnRlcnZhbCA9IHNldEludGVydmFsKCgpID0+IHRoaXMubmV4dFdoZW5WaXNpYmxlKCksIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCk7XHJcbiAgICB9XHJcbiAgICBfbWF5YmVFbmFibGVDeWNsZSgpIHtcclxuICAgICAgaWYgKCF0aGlzLl9jb25maWcucmlkZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uZSh0aGlzLl9lbGVtZW50LCBFVkVOVF9TTElELCAoKSA9PiB0aGlzLmN5Y2xlKCkpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLmN5Y2xlKCk7XHJcbiAgICB9XHJcbiAgICB0byhpbmRleCkge1xyXG4gICAgICBjb25zdCBpdGVtcyA9IHRoaXMuX2dldEl0ZW1zKCk7XHJcbiAgICAgIGlmIChpbmRleCA+IGl0ZW1zLmxlbmd0aCAtIDEgfHwgaW5kZXggPCAwKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLl9pc1NsaWRpbmcpIHtcclxuICAgICAgICBFdmVudEhhbmRsZXIub25lKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NMSUQsICgpID0+IHRoaXMudG8oaW5kZXgpKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgYWN0aXZlSW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgodGhpcy5fZ2V0QWN0aXZlKCkpO1xyXG4gICAgICBpZiAoYWN0aXZlSW5kZXggPT09IGluZGV4KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IG9yZGVyID0gaW5kZXggPiBhY3RpdmVJbmRleCA/IE9SREVSX05FWFQgOiBPUkRFUl9QUkVWO1xyXG4gICAgICB0aGlzLl9zbGlkZShvcmRlciwgaXRlbXNbaW5kZXhdKTtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgIGlmICh0aGlzLl9zd2lwZUhlbHBlcikge1xyXG4gICAgICAgIHRoaXMuX3N3aXBlSGVscGVyLmRpc3Bvc2UoKTtcclxuICAgICAgfVxyXG4gICAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJpdmF0ZVxyXG4gICAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XHJcbiAgICAgIGNvbmZpZy5kZWZhdWx0SW50ZXJ2YWwgPSBjb25maWcuaW50ZXJ2YWw7XHJcbiAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICB9XHJcbiAgICBfYWRkRXZlbnRMaXN0ZW5lcnMoKSB7XHJcbiAgICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcclxuICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfS0VZRE9XTiQxLCBldmVudCA9PiB0aGlzLl9rZXlkb3duKGV2ZW50KSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5wYXVzZSA9PT0gJ2hvdmVyJykge1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRUVOVEVSJDEsICgpID0+IHRoaXMucGF1c2UoKSk7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFTEVBVkUkMSwgKCkgPT4gdGhpcy5fbWF5YmVFbmFibGVDeWNsZSgpKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnRvdWNoICYmIFN3aXBlLmlzU3VwcG9ydGVkKCkpIHtcclxuICAgICAgICB0aGlzLl9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIF9hZGRUb3VjaEV2ZW50TGlzdGVuZXJzKCkge1xyXG4gICAgICBmb3IgKGNvbnN0IGltZyBvZiBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0lURU1fSU1HLCB0aGlzLl9lbGVtZW50KSkge1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbihpbWcsIEVWRU5UX0RSQUdfU1RBUlQsIGV2ZW50ID0+IGV2ZW50LnByZXZlbnREZWZhdWx0KCkpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGVuZENhbGxCYWNrID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcucGF1c2UgIT09ICdob3ZlcicpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIElmIGl0J3MgYSB0b3VjaC1lbmFibGVkIGRldmljZSwgbW91c2VlbnRlci9sZWF2ZSBhcmUgZmlyZWQgYXNcclxuICAgICAgICAvLyBwYXJ0IG9mIHRoZSBtb3VzZSBjb21wYXRpYmlsaXR5IGV2ZW50cyBvbiBmaXJzdCB0YXAgLSB0aGUgY2Fyb3VzZWxcclxuICAgICAgICAvLyB3b3VsZCBzdG9wIGN5Y2xpbmcgdW50aWwgdXNlciB0YXBwZWQgb3V0IG9mIGl0O1xyXG4gICAgICAgIC8vIGhlcmUsIHdlIGxpc3RlbiBmb3IgdG91Y2hlbmQsIGV4cGxpY2l0bHkgcGF1c2UgdGhlIGNhcm91c2VsXHJcbiAgICAgICAgLy8gKGFzIGlmIGl0J3MgdGhlIHNlY29uZCB0aW1lIHdlIHRhcCBvbiBpdCwgbW91c2VlbnRlciBjb21wYXQgZXZlbnRcclxuICAgICAgICAvLyBpcyBOT1QgZmlyZWQpIGFuZCBhZnRlciBhIHRpbWVvdXQgKHRvIGFsbG93IGZvciBtb3VzZSBjb21wYXRpYmlsaXR5XHJcbiAgICAgICAgLy8gZXZlbnRzIHRvIGZpcmUpIHdlIGV4cGxpY2l0bHkgcmVzdGFydCBjeWNsaW5nXHJcblxyXG4gICAgICAgIHRoaXMucGF1c2UoKTtcclxuICAgICAgICBpZiAodGhpcy50b3VjaFRpbWVvdXQpIHtcclxuICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRvdWNoVGltZW91dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMudG91Y2hUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB0aGlzLl9tYXliZUVuYWJsZUN5Y2xlKCksIFRPVUNIRVZFTlRfQ09NUEFUX1dBSVQgKyB0aGlzLl9jb25maWcuaW50ZXJ2YWwpO1xyXG4gICAgICB9O1xyXG4gICAgICBjb25zdCBzd2lwZUNvbmZpZyA9IHtcclxuICAgICAgICBsZWZ0Q2FsbGJhY2s6ICgpID0+IHRoaXMuX3NsaWRlKHRoaXMuX2RpcmVjdGlvblRvT3JkZXIoRElSRUNUSU9OX0xFRlQpKSxcclxuICAgICAgICByaWdodENhbGxiYWNrOiAoKSA9PiB0aGlzLl9zbGlkZSh0aGlzLl9kaXJlY3Rpb25Ub09yZGVyKERJUkVDVElPTl9SSUdIVCkpLFxyXG4gICAgICAgIGVuZENhbGxiYWNrOiBlbmRDYWxsQmFja1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLl9zd2lwZUhlbHBlciA9IG5ldyBTd2lwZSh0aGlzLl9lbGVtZW50LCBzd2lwZUNvbmZpZyk7XHJcbiAgICB9XHJcbiAgICBfa2V5ZG93bihldmVudCkge1xyXG4gICAgICBpZiAoL2lucHV0fHRleHRhcmVhL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZGlyZWN0aW9uID0gS0VZX1RPX0RJUkVDVElPTltldmVudC5rZXldO1xyXG4gICAgICBpZiAoZGlyZWN0aW9uKSB7XHJcbiAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB0aGlzLl9zbGlkZSh0aGlzLl9kaXJlY3Rpb25Ub09yZGVyKGRpcmVjdGlvbikpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfZ2V0SXRlbUluZGV4KGVsZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2dldEl0ZW1zKCkuaW5kZXhPZihlbGVtZW50KTtcclxuICAgIH1cclxuICAgIF9zZXRBY3RpdmVJbmRpY2F0b3JFbGVtZW50KGluZGV4KSB7XHJcbiAgICAgIGlmICghdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgYWN0aXZlSW5kaWNhdG9yID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9BQ1RJVkUsIHRoaXMuX2luZGljYXRvcnNFbGVtZW50KTtcclxuICAgICAgYWN0aXZlSW5kaWNhdG9yLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XHJcbiAgICAgIGFjdGl2ZUluZGljYXRvci5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtY3VycmVudCcpO1xyXG4gICAgICBjb25zdCBuZXdBY3RpdmVJbmRpY2F0b3IgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKGBbZGF0YS1icy1zbGlkZS10bz1cIiR7aW5kZXh9XCJdYCwgdGhpcy5faW5kaWNhdG9yc0VsZW1lbnQpO1xyXG4gICAgICBpZiAobmV3QWN0aXZlSW5kaWNhdG9yKSB7XHJcbiAgICAgICAgbmV3QWN0aXZlSW5kaWNhdG9yLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XHJcbiAgICAgICAgbmV3QWN0aXZlSW5kaWNhdG9yLnNldEF0dHJpYnV0ZSgnYXJpYS1jdXJyZW50JywgJ3RydWUnKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgX3VwZGF0ZUludGVydmFsKCkge1xyXG4gICAgICBjb25zdCBlbGVtZW50ID0gdGhpcy5fYWN0aXZlRWxlbWVudCB8fCB0aGlzLl9nZXRBY3RpdmUoKTtcclxuICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGVsZW1lbnRJbnRlcnZhbCA9IE51bWJlci5wYXJzZUludChlbGVtZW50LmdldEF0dHJpYnV0ZSgnZGF0YS1icy1pbnRlcnZhbCcpLCAxMCk7XHJcbiAgICAgIHRoaXMuX2NvbmZpZy5pbnRlcnZhbCA9IGVsZW1lbnRJbnRlcnZhbCB8fCB0aGlzLl9jb25maWcuZGVmYXVsdEludGVydmFsO1xyXG4gICAgfVxyXG4gICAgX3NsaWRlKG9yZGVyLCBlbGVtZW50ID0gbnVsbCkge1xyXG4gICAgICBpZiAodGhpcy5faXNTbGlkaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGFjdGl2ZUVsZW1lbnQgPSB0aGlzLl9nZXRBY3RpdmUoKTtcclxuICAgICAgY29uc3QgaXNOZXh0ID0gb3JkZXIgPT09IE9SREVSX05FWFQ7XHJcbiAgICAgIGNvbnN0IG5leHRFbGVtZW50ID0gZWxlbWVudCB8fCBnZXROZXh0QWN0aXZlRWxlbWVudCh0aGlzLl9nZXRJdGVtcygpLCBhY3RpdmVFbGVtZW50LCBpc05leHQsIHRoaXMuX2NvbmZpZy53cmFwKTtcclxuICAgICAgaWYgKG5leHRFbGVtZW50ID09PSBhY3RpdmVFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IG5leHRFbGVtZW50SW5kZXggPSB0aGlzLl9nZXRJdGVtSW5kZXgobmV4dEVsZW1lbnQpO1xyXG4gICAgICBjb25zdCB0cmlnZ2VyRXZlbnQgPSBldmVudE5hbWUgPT4ge1xyXG4gICAgICAgIHJldHVybiBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBldmVudE5hbWUsIHtcclxuICAgICAgICAgIHJlbGF0ZWRUYXJnZXQ6IG5leHRFbGVtZW50LFxyXG4gICAgICAgICAgZGlyZWN0aW9uOiB0aGlzLl9vcmRlclRvRGlyZWN0aW9uKG9yZGVyKSxcclxuICAgICAgICAgIGZyb206IHRoaXMuX2dldEl0ZW1JbmRleChhY3RpdmVFbGVtZW50KSxcclxuICAgICAgICAgIHRvOiBuZXh0RWxlbWVudEluZGV4XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcbiAgICAgIGNvbnN0IHNsaWRlRXZlbnQgPSB0cmlnZ2VyRXZlbnQoRVZFTlRfU0xJREUpO1xyXG4gICAgICBpZiAoc2xpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghYWN0aXZlRWxlbWVudCB8fCAhbmV4dEVsZW1lbnQpIHtcclxuICAgICAgICAvLyBTb21lIHdlaXJkbmVzcyBpcyBoYXBwZW5pbmcsIHNvIHdlIGJhaWxcclxuICAgICAgICAvLyBUT0RPOiBjaGFuZ2UgdGVzdHMgdGhhdCB1c2UgZW1wdHkgZGl2cyB0byBhdm9pZCB0aGlzIGNoZWNrXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGlzQ3ljbGluZyA9IEJvb2xlYW4odGhpcy5faW50ZXJ2YWwpO1xyXG4gICAgICB0aGlzLnBhdXNlKCk7XHJcbiAgICAgIHRoaXMuX2lzU2xpZGluZyA9IHRydWU7XHJcbiAgICAgIHRoaXMuX3NldEFjdGl2ZUluZGljYXRvckVsZW1lbnQobmV4dEVsZW1lbnRJbmRleCk7XHJcbiAgICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBuZXh0RWxlbWVudDtcclxuICAgICAgY29uc3QgZGlyZWN0aW9uYWxDbGFzc05hbWUgPSBpc05leHQgPyBDTEFTU19OQU1FX1NUQVJUIDogQ0xBU1NfTkFNRV9FTkQ7XHJcbiAgICAgIGNvbnN0IG9yZGVyQ2xhc3NOYW1lID0gaXNOZXh0ID8gQ0xBU1NfTkFNRV9ORVhUIDogQ0xBU1NfTkFNRV9QUkVWO1xyXG4gICAgICBuZXh0RWxlbWVudC5jbGFzc0xpc3QuYWRkKG9yZGVyQ2xhc3NOYW1lKTtcclxuICAgICAgcmVmbG93KG5leHRFbGVtZW50KTtcclxuICAgICAgYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QuYWRkKGRpcmVjdGlvbmFsQ2xhc3NOYW1lKTtcclxuICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LmFkZChkaXJlY3Rpb25hbENsYXNzTmFtZSk7XHJcbiAgICAgIGNvbnN0IGNvbXBsZXRlQ2FsbEJhY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgbmV4dEVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShkaXJlY3Rpb25hbENsYXNzTmFtZSwgb3JkZXJDbGFzc05hbWUpO1xyXG4gICAgICAgIG5leHRFbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMik7XHJcbiAgICAgICAgYWN0aXZlRWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQUNUSVZFJDIsIG9yZGVyQ2xhc3NOYW1lLCBkaXJlY3Rpb25hbENsYXNzTmFtZSk7XHJcbiAgICAgICAgdGhpcy5faXNTbGlkaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdHJpZ2dlckV2ZW50KEVWRU5UX1NMSUQpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlQ2FsbEJhY2ssIGFjdGl2ZUVsZW1lbnQsIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XHJcbiAgICAgIGlmIChpc0N5Y2xpbmcpIHtcclxuICAgICAgICB0aGlzLmN5Y2xlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIF9pc0FuaW1hdGVkKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TTElERSk7XHJcbiAgICB9XHJcbiAgICBfZ2V0QWN0aXZlKCkge1xyXG4gICAgICByZXR1cm4gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9BQ1RJVkVfSVRFTSwgdGhpcy5fZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgICBfZ2V0SXRlbXMoKSB7XHJcbiAgICAgIHJldHVybiBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0lURU0sIHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgX2NsZWFySW50ZXJ2YWwoKSB7XHJcbiAgICAgIGlmICh0aGlzLl9pbnRlcnZhbCkge1xyXG4gICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5faW50ZXJ2YWwpO1xyXG4gICAgICAgIHRoaXMuX2ludGVydmFsID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2RpcmVjdGlvblRvT3JkZXIoZGlyZWN0aW9uKSB7XHJcbiAgICAgIGlmIChpc1JUTCgpKSB7XHJcbiAgICAgICAgcmV0dXJuIGRpcmVjdGlvbiA9PT0gRElSRUNUSU9OX0xFRlQgPyBPUkRFUl9QUkVWIDogT1JERVJfTkVYVDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gZGlyZWN0aW9uID09PSBESVJFQ1RJT05fTEVGVCA/IE9SREVSX05FWFQgOiBPUkRFUl9QUkVWO1xyXG4gICAgfVxyXG4gICAgX29yZGVyVG9EaXJlY3Rpb24ob3JkZXIpIHtcclxuICAgICAgaWYgKGlzUlRMKCkpIHtcclxuICAgICAgICByZXR1cm4gb3JkZXIgPT09IE9SREVSX1BSRVYgPyBESVJFQ1RJT05fTEVGVCA6IERJUkVDVElPTl9SSUdIVDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb3JkZXIgPT09IE9SREVSX1BSRVYgPyBESVJFQ1RJT05fUklHSFQgOiBESVJFQ1RJT05fTEVGVDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGF0aWNcclxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBDYXJvdXNlbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICBkYXRhLnRvKGNvbmZpZyk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBkYXRhW2NvbmZpZ10oKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cclxuICAgKi9cclxuXHJcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQ1LCBTRUxFQ1RPUl9EQVRBX1NMSURFLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcyk7XHJcbiAgICBpZiAoIXRhcmdldCB8fCAhdGFyZ2V0LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0NBUk9VU0VMKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgY29uc3QgY2Fyb3VzZWwgPSBDYXJvdXNlbC5nZXRPckNyZWF0ZUluc3RhbmNlKHRhcmdldCk7XHJcbiAgICBjb25zdCBzbGlkZUluZGV4ID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtc2xpZGUtdG8nKTtcclxuICAgIGlmIChzbGlkZUluZGV4KSB7XHJcbiAgICAgIGNhcm91c2VsLnRvKHNsaWRlSW5kZXgpO1xyXG4gICAgICBjYXJvdXNlbC5fbWF5YmVFbmFibGVDeWNsZSgpO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBpZiAoTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZSh0aGlzLCAnc2xpZGUnKSA9PT0gJ25leHQnKSB7XHJcbiAgICAgIGNhcm91c2VsLm5leHQoKTtcclxuICAgICAgY2Fyb3VzZWwuX21heWJlRW5hYmxlQ3ljbGUoKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG4gICAgY2Fyb3VzZWwucHJldigpO1xyXG4gICAgY2Fyb3VzZWwuX21heWJlRW5hYmxlQ3ljbGUoKTtcclxuICB9KTtcclxuICBFdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9MT0FEX0RBVEFfQVBJJDMsICgpID0+IHtcclxuICAgIGNvbnN0IGNhcm91c2VscyA9IFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfREFUQV9SSURFKTtcclxuICAgIGZvciAoY29uc3QgY2Fyb3VzZWwgb2YgY2Fyb3VzZWxzKSB7XHJcbiAgICAgIENhcm91c2VsLmdldE9yQ3JlYXRlSW5zdGFuY2UoY2Fyb3VzZWwpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvKipcclxuICAgKiBqUXVlcnlcclxuICAgKi9cclxuXHJcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKENhcm91c2VsKTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgY29sbGFwc2UuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE5BTUUkYiA9ICdjb2xsYXBzZSc7XHJcbiAgY29uc3QgREFUQV9LRVkkNyA9ICdicy5jb2xsYXBzZSc7XHJcbiAgY29uc3QgRVZFTlRfS0VZJDcgPSBgLiR7REFUQV9LRVkkN31gO1xyXG4gIGNvbnN0IERBVEFfQVBJX0tFWSQ0ID0gJy5kYXRhLWFwaSc7XHJcbiAgY29uc3QgRVZFTlRfU0hPVyQ2ID0gYHNob3cke0VWRU5UX0tFWSQ3fWA7XHJcbiAgY29uc3QgRVZFTlRfU0hPV04kNiA9IGBzaG93biR7RVZFTlRfS0VZJDd9YDtcclxuICBjb25zdCBFVkVOVF9ISURFJDYgPSBgaGlkZSR7RVZFTlRfS0VZJDd9YDtcclxuICBjb25zdCBFVkVOVF9ISURERU4kNiA9IGBoaWRkZW4ke0VWRU5UX0tFWSQ3fWA7XHJcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkNCA9IGBjbGljayR7RVZFTlRfS0VZJDd9JHtEQVRBX0FQSV9LRVkkNH1gO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQ3ID0gJ3Nob3cnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0UgPSAnY29sbGFwc2UnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfQ09MTEFQU0lORyA9ICdjb2xsYXBzaW5nJztcclxuICBjb25zdCBDTEFTU19OQU1FX0NPTExBUFNFRCA9ICdjb2xsYXBzZWQnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfREVFUEVSX0NISUxEUkVOID0gYDpzY29wZSAuJHtDTEFTU19OQU1FX0NPTExBUFNFfSAuJHtDTEFTU19OQU1FX0NPTExBUFNFfWA7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9IT1JJWk9OVEFMID0gJ2NvbGxhcHNlLWhvcml6b250YWwnO1xyXG4gIGNvbnN0IFdJRFRIID0gJ3dpZHRoJztcclxuICBjb25zdCBIRUlHSFQgPSAnaGVpZ2h0JztcclxuICBjb25zdCBTRUxFQ1RPUl9BQ1RJVkVTID0gJy5jb2xsYXBzZS5zaG93LCAuY29sbGFwc2UuY29sbGFwc2luZyc7XHJcbiAgY29uc3QgU0VMRUNUT1JfREFUQV9UT0dHTEUkNCA9ICdbZGF0YS1icy10b2dnbGU9XCJjb2xsYXBzZVwiXSc7XHJcbiAgY29uc3QgRGVmYXVsdCRhID0ge1xyXG4gICAgcGFyZW50OiBudWxsLFxyXG4gICAgdG9nZ2xlOiB0cnVlXHJcbiAgfTtcclxuICBjb25zdCBEZWZhdWx0VHlwZSRhID0ge1xyXG4gICAgcGFyZW50OiAnKG51bGx8ZWxlbWVudCknLFxyXG4gICAgdG9nZ2xlOiAnYm9vbGVhbidcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIENvbGxhcHNlIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcclxuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcclxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX3RyaWdnZXJBcnJheSA9IFtdO1xyXG4gICAgICBjb25zdCB0b2dnbGVMaXN0ID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1RPR0dMRSQ0KTtcclxuICAgICAgZm9yIChjb25zdCBlbGVtIG9mIHRvZ2dsZUxpc3QpIHtcclxuICAgICAgICBjb25zdCBzZWxlY3RvciA9IFNlbGVjdG9yRW5naW5lLmdldFNlbGVjdG9yRnJvbUVsZW1lbnQoZWxlbSk7XHJcbiAgICAgICAgY29uc3QgZmlsdGVyRWxlbWVudCA9IFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IpLmZpbHRlcihmb3VuZEVsZW1lbnQgPT4gZm91bmRFbGVtZW50ID09PSB0aGlzLl9lbGVtZW50KTtcclxuICAgICAgICBpZiAoc2VsZWN0b3IgIT09IG51bGwgJiYgZmlsdGVyRWxlbWVudC5sZW5ndGgpIHtcclxuICAgICAgICAgIHRoaXMuX3RyaWdnZXJBcnJheS5wdXNoKGVsZW0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9pbml0aWFsaXplQ2hpbGRyZW4oKTtcclxuICAgICAgaWYgKCF0aGlzLl9jb25maWcucGFyZW50KSB7XHJcbiAgICAgICAgdGhpcy5fYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRoaXMuX3RyaWdnZXJBcnJheSwgdGhpcy5faXNTaG93bigpKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnRvZ2dsZSkge1xyXG4gICAgICAgIHRoaXMudG9nZ2xlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXR0ZXJzXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0JGE7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkYTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcclxuICAgICAgcmV0dXJuIE5BTUUkYjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQdWJsaWNcclxuICAgIHRvZ2dsZSgpIHtcclxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24oKSkge1xyXG4gICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuc2hvdygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBzaG93KCkge1xyXG4gICAgICBpZiAodGhpcy5faXNUcmFuc2l0aW9uaW5nIHx8IHRoaXMuX2lzU2hvd24oKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBsZXQgYWN0aXZlQ2hpbGRyZW4gPSBbXTtcclxuXHJcbiAgICAgIC8vIGZpbmQgYWN0aXZlIGNoaWxkcmVuXHJcbiAgICAgIGlmICh0aGlzLl9jb25maWcucGFyZW50KSB7XHJcbiAgICAgICAgYWN0aXZlQ2hpbGRyZW4gPSB0aGlzLl9nZXRGaXJzdExldmVsQ2hpbGRyZW4oU0VMRUNUT1JfQUNUSVZFUykuZmlsdGVyKGVsZW1lbnQgPT4gZWxlbWVudCAhPT0gdGhpcy5fZWxlbWVudCkubWFwKGVsZW1lbnQgPT4gQ29sbGFwc2UuZ2V0T3JDcmVhdGVJbnN0YW5jZShlbGVtZW50LCB7XHJcbiAgICAgICAgICB0b2dnbGU6IGZhbHNlXHJcbiAgICAgICAgfSkpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChhY3RpdmVDaGlsZHJlbi5sZW5ndGggJiYgYWN0aXZlQ2hpbGRyZW5bMF0uX2lzVHJhbnNpdGlvbmluZykge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBzdGFydEV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ2KTtcclxuICAgICAgaWYgKHN0YXJ0RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGNvbnN0IGFjdGl2ZUluc3RhbmNlIG9mIGFjdGl2ZUNoaWxkcmVuKSB7XHJcbiAgICAgICAgYWN0aXZlSW5zdGFuY2UuaGlkZSgpO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGRpbWVuc2lvbiA9IHRoaXMuX2dldERpbWVuc2lvbigpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9DT0xMQVBTRSk7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAwO1xyXG4gICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3ModGhpcy5fdHJpZ2dlckFycmF5LCB0cnVlKTtcclxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcclxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0lORyk7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQ09MTEFQU0UsIENMQVNTX05BTUVfU0hPVyQ3KTtcclxuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSAnJztcclxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQ2KTtcclxuICAgICAgfTtcclxuICAgICAgY29uc3QgY2FwaXRhbGl6ZWREaW1lbnNpb24gPSBkaW1lbnNpb25bMF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSgxKTtcclxuICAgICAgY29uc3Qgc2Nyb2xsU2l6ZSA9IGBzY3JvbGwke2NhcGl0YWxpemVkRGltZW5zaW9ufWA7XHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRydWUpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlW2RpbWVuc2lvbl0gPSBgJHt0aGlzLl9lbGVtZW50W3Njcm9sbFNpemVdfXB4YDtcclxuICAgIH1cclxuICAgIGhpZGUoKSB7XHJcbiAgICAgIGlmICh0aGlzLl9pc1RyYW5zaXRpb25pbmcgfHwgIXRoaXMuX2lzU2hvd24oKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBzdGFydEV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQ2KTtcclxuICAgICAgaWYgKHN0YXJ0RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBkaW1lbnNpb24gPSB0aGlzLl9nZXREaW1lbnNpb24oKTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZVtkaW1lbnNpb25dID0gYCR7dGhpcy5fZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVtkaW1lbnNpb25dfXB4YDtcclxuICAgICAgcmVmbG93KHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9DT0xMQVBTSU5HKTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfQ09MTEFQU0UsIENMQVNTX05BTUVfU0hPVyQ3KTtcclxuICAgICAgZm9yIChjb25zdCB0cmlnZ2VyIG9mIHRoaXMuX3RyaWdnZXJBcnJheSkge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5nZXRFbGVtZW50RnJvbVNlbGVjdG9yKHRyaWdnZXIpO1xyXG4gICAgICAgIGlmIChlbGVtZW50ICYmICF0aGlzLl9pc1Nob3duKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICB0aGlzLl9hZGRBcmlhQW5kQ29sbGFwc2VkQ2xhc3MoW3RyaWdnZXJdLCBmYWxzZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IHRydWU7XHJcbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0NPTExBUFNJTkcpO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0NPTExBUFNFKTtcclxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kNik7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbZGltZW5zaW9uXSA9ICcnO1xyXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCB0aGlzLl9lbGVtZW50LCB0cnVlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcml2YXRlXHJcbiAgICBfaXNTaG93bihlbGVtZW50ID0gdGhpcy5fZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9TSE9XJDcpO1xyXG4gICAgfVxyXG4gICAgX2NvbmZpZ0FmdGVyTWVyZ2UoY29uZmlnKSB7XHJcbiAgICAgIGNvbmZpZy50b2dnbGUgPSBCb29sZWFuKGNvbmZpZy50b2dnbGUpOyAvLyBDb2VyY2Ugc3RyaW5nIHZhbHVlc1xyXG4gICAgICBjb25maWcucGFyZW50ID0gZ2V0RWxlbWVudChjb25maWcucGFyZW50KTtcclxuICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgIH1cclxuICAgIF9nZXREaW1lbnNpb24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0hPUklaT05UQUwpID8gV0lEVEggOiBIRUlHSFQ7XHJcbiAgICB9XHJcbiAgICBfaW5pdGlhbGl6ZUNoaWxkcmVuKCkge1xyXG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5wYXJlbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgY2hpbGRyZW4gPSB0aGlzLl9nZXRGaXJzdExldmVsQ2hpbGRyZW4oU0VMRUNUT1JfREFUQV9UT0dHTEUkNCk7XHJcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBjaGlsZHJlbikge1xyXG4gICAgICAgIGNvbnN0IHNlbGVjdGVkID0gU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KTtcclxuICAgICAgICBpZiAoc2VsZWN0ZWQpIHtcclxuICAgICAgICAgIHRoaXMuX2FkZEFyaWFBbmRDb2xsYXBzZWRDbGFzcyhbZWxlbWVudF0sIHRoaXMuX2lzU2hvd24oc2VsZWN0ZWQpKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIF9nZXRGaXJzdExldmVsQ2hpbGRyZW4oc2VsZWN0b3IpIHtcclxuICAgICAgY29uc3QgY2hpbGRyZW4gPSBTZWxlY3RvckVuZ2luZS5maW5kKENMQVNTX05BTUVfREVFUEVSX0NISUxEUkVOLCB0aGlzLl9jb25maWcucGFyZW50KTtcclxuICAgICAgLy8gcmVtb3ZlIGNoaWxkcmVuIGlmIGdyZWF0ZXIgZGVwdGhcclxuICAgICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IsIHRoaXMuX2NvbmZpZy5wYXJlbnQpLmZpbHRlcihlbGVtZW50ID0+ICFjaGlsZHJlbi5pbmNsdWRlcyhlbGVtZW50KSk7XHJcbiAgICB9XHJcbiAgICBfYWRkQXJpYUFuZENvbGxhcHNlZENsYXNzKHRyaWdnZXJBcnJheSwgaXNPcGVuKSB7XHJcbiAgICAgIGlmICghdHJpZ2dlckFycmF5Lmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgdHJpZ2dlckFycmF5KSB7XHJcbiAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKENMQVNTX05BTUVfQ09MTEFQU0VELCAhaXNPcGVuKTtcclxuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsIGlzT3Blbik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGF0aWNcclxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XHJcbiAgICAgIGNvbnN0IF9jb25maWcgPSB7fTtcclxuICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnICYmIC9zaG93fGhpZGUvLnRlc3QoY29uZmlnKSkge1xyXG4gICAgICAgIF9jb25maWcudG9nZ2xlID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IENvbGxhcHNlLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgX2NvbmZpZyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGRhdGFbY29uZmlnXSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxyXG4gICAqL1xyXG5cclxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0NMSUNLX0RBVEFfQVBJJDQsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDQsIGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgLy8gcHJldmVudERlZmF1bHQgb25seSBmb3IgPGE+IGVsZW1lbnRzICh3aGljaCBjaGFuZ2UgdGhlIFVSTCkgbm90IGluc2lkZSB0aGUgY29sbGFwc2libGUgZWxlbWVudFxyXG4gICAgaWYgKGV2ZW50LnRhcmdldC50YWdOYW1lID09PSAnQScgfHwgZXZlbnQuZGVsZWdhdGVUYXJnZXQgJiYgZXZlbnQuZGVsZWdhdGVUYXJnZXQudGFnTmFtZSA9PT0gJ0EnKSB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgU2VsZWN0b3JFbmdpbmUuZ2V0TXVsdGlwbGVFbGVtZW50c0Zyb21TZWxlY3Rvcih0aGlzKSkge1xyXG4gICAgICBDb2xsYXBzZS5nZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQsIHtcclxuICAgICAgICB0b2dnbGU6IGZhbHNlXHJcbiAgICAgIH0pLnRvZ2dsZSgpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICAvKipcclxuICAgKiBqUXVlcnlcclxuICAgKi9cclxuXHJcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKENvbGxhcHNlKTtcclxuXHJcbiAgdmFyIHRvcCA9ICd0b3AnO1xyXG4gIHZhciBib3R0b20gPSAnYm90dG9tJztcclxuICB2YXIgcmlnaHQgPSAncmlnaHQnO1xyXG4gIHZhciBsZWZ0ID0gJ2xlZnQnO1xyXG4gIHZhciBhdXRvID0gJ2F1dG8nO1xyXG4gIHZhciBiYXNlUGxhY2VtZW50cyA9IFt0b3AsIGJvdHRvbSwgcmlnaHQsIGxlZnRdO1xyXG4gIHZhciBzdGFydCA9ICdzdGFydCc7XHJcbiAgdmFyIGVuZCA9ICdlbmQnO1xyXG4gIHZhciBjbGlwcGluZ1BhcmVudHMgPSAnY2xpcHBpbmdQYXJlbnRzJztcclxuICB2YXIgdmlld3BvcnQgPSAndmlld3BvcnQnO1xyXG4gIHZhciBwb3BwZXIgPSAncG9wcGVyJztcclxuICB2YXIgcmVmZXJlbmNlID0gJ3JlZmVyZW5jZSc7XHJcbiAgdmFyIHZhcmlhdGlvblBsYWNlbWVudHMgPSAvKiNfX1BVUkVfXyovYmFzZVBsYWNlbWVudHMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIHBsYWNlbWVudCkge1xyXG4gICAgcmV0dXJuIGFjYy5jb25jYXQoW3BsYWNlbWVudCArIFwiLVwiICsgc3RhcnQsIHBsYWNlbWVudCArIFwiLVwiICsgZW5kXSk7XHJcbiAgfSwgW10pO1xyXG4gIHZhciBwbGFjZW1lbnRzID0gLyojX19QVVJFX18qL1tdLmNvbmNhdChiYXNlUGxhY2VtZW50cywgW2F1dG9dKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XHJcbiAgICByZXR1cm4gYWNjLmNvbmNhdChbcGxhY2VtZW50LCBwbGFjZW1lbnQgKyBcIi1cIiArIHN0YXJ0LCBwbGFjZW1lbnQgKyBcIi1cIiArIGVuZF0pO1xyXG4gIH0sIFtdKTsgLy8gbW9kaWZpZXJzIHRoYXQgbmVlZCB0byByZWFkIHRoZSBET01cclxuXHJcbiAgdmFyIGJlZm9yZVJlYWQgPSAnYmVmb3JlUmVhZCc7XHJcbiAgdmFyIHJlYWQgPSAncmVhZCc7XHJcbiAgdmFyIGFmdGVyUmVhZCA9ICdhZnRlclJlYWQnOyAvLyBwdXJlLWxvZ2ljIG1vZGlmaWVyc1xyXG5cclxuICB2YXIgYmVmb3JlTWFpbiA9ICdiZWZvcmVNYWluJztcclxuICB2YXIgbWFpbiA9ICdtYWluJztcclxuICB2YXIgYWZ0ZXJNYWluID0gJ2FmdGVyTWFpbic7IC8vIG1vZGlmaWVyIHdpdGggdGhlIHB1cnBvc2UgdG8gd3JpdGUgdG8gdGhlIERPTSAob3Igd3JpdGUgaW50byBhIGZyYW1ld29yayBzdGF0ZSlcclxuXHJcbiAgdmFyIGJlZm9yZVdyaXRlID0gJ2JlZm9yZVdyaXRlJztcclxuICB2YXIgd3JpdGUgPSAnd3JpdGUnO1xyXG4gIHZhciBhZnRlcldyaXRlID0gJ2FmdGVyV3JpdGUnO1xyXG4gIHZhciBtb2RpZmllclBoYXNlcyA9IFtiZWZvcmVSZWFkLCByZWFkLCBhZnRlclJlYWQsIGJlZm9yZU1haW4sIG1haW4sIGFmdGVyTWFpbiwgYmVmb3JlV3JpdGUsIHdyaXRlLCBhZnRlcldyaXRlXTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0Tm9kZU5hbWUoZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIGVsZW1lbnQgPyAoZWxlbWVudC5ub2RlTmFtZSB8fCAnJykudG9Mb3dlckNhc2UoKSA6IG51bGw7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRXaW5kb3cobm9kZSkge1xyXG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm4gd2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChub2RlLnRvU3RyaW5nKCkgIT09ICdbb2JqZWN0IFdpbmRvd10nKSB7XHJcbiAgICAgIHZhciBvd25lckRvY3VtZW50ID0gbm9kZS5vd25lckRvY3VtZW50O1xyXG4gICAgICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgfHwgd2luZG93IDogd2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBub2RlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaXNFbGVtZW50KG5vZGUpIHtcclxuICAgIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkVsZW1lbnQ7XHJcbiAgICByZXR1cm4gbm9kZSBpbnN0YW5jZW9mIE93bkVsZW1lbnQgfHwgbm9kZSBpbnN0YW5jZW9mIEVsZW1lbnQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc0hUTUxFbGVtZW50KG5vZGUpIHtcclxuICAgIHZhciBPd25FbGVtZW50ID0gZ2V0V2luZG93KG5vZGUpLkhUTUxFbGVtZW50O1xyXG4gICAgcmV0dXJuIG5vZGUgaW5zdGFuY2VvZiBPd25FbGVtZW50IHx8IG5vZGUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzU2hhZG93Um9vdChub2RlKSB7XHJcbiAgICAvLyBJRSAxMSBoYXMgbm8gU2hhZG93Um9vdFxyXG4gICAgaWYgKHR5cGVvZiBTaGFkb3dSb290ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIE93bkVsZW1lbnQgPSBnZXRXaW5kb3cobm9kZSkuU2hhZG93Um9vdDtcclxuICAgIHJldHVybiBub2RlIGluc3RhbmNlb2YgT3duRWxlbWVudCB8fCBub2RlIGluc3RhbmNlb2YgU2hhZG93Um9vdDtcclxuICB9XHJcblxyXG4gIC8vIGFuZCBhcHBsaWVzIHRoZW0gdG8gdGhlIEhUTUxFbGVtZW50cyBzdWNoIGFzIHBvcHBlciBhbmQgYXJyb3dcclxuXHJcbiAgZnVuY3Rpb24gYXBwbHlTdHlsZXMoX3JlZikge1xyXG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZTtcclxuICAgIE9iamVjdC5rZXlzKHN0YXRlLmVsZW1lbnRzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgIHZhciBzdHlsZSA9IHN0YXRlLnN0eWxlc1tuYW1lXSB8fCB7fTtcclxuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSBzdGF0ZS5hdHRyaWJ1dGVzW25hbWVdIHx8IHt9O1xyXG4gICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcclxuXHJcbiAgICAgIGlmICghaXNIVE1MRWxlbWVudChlbGVtZW50KSB8fCAhZ2V0Tm9kZU5hbWUoZWxlbWVudCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH0gLy8gRmxvdyBkb2Vzbid0IHN1cHBvcnQgdG8gZXh0ZW5kIHRoaXMgcHJvcGVydHksIGJ1dCBpdCdzIHRoZSBtb3N0XHJcbiAgICAgIC8vIGVmZmVjdGl2ZSB3YXkgdG8gYXBwbHkgc3R5bGVzIHRvIGFuIEhUTUxFbGVtZW50XHJcbiAgICAgIC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXVxyXG5cclxuXHJcbiAgICAgIE9iamVjdC5hc3NpZ24oZWxlbWVudC5zdHlsZSwgc3R5bGUpO1xyXG4gICAgICBPYmplY3Qua2V5cyhhdHRyaWJ1dGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gYXR0cmlidXRlc1tuYW1lXTtcclxuXHJcbiAgICAgICAgaWYgKHZhbHVlID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUobmFtZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKG5hbWUsIHZhbHVlID09PSB0cnVlID8gJycgOiB2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZWZmZWN0JDIoX3JlZjIpIHtcclxuICAgIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlO1xyXG4gICAgdmFyIGluaXRpYWxTdHlsZXMgPSB7XHJcbiAgICAgIHBvcHBlcjoge1xyXG4gICAgICAgIHBvc2l0aW9uOiBzdGF0ZS5vcHRpb25zLnN0cmF0ZWd5LFxyXG4gICAgICAgIGxlZnQ6ICcwJyxcclxuICAgICAgICB0b3A6ICcwJyxcclxuICAgICAgICBtYXJnaW46ICcwJ1xyXG4gICAgICB9LFxyXG4gICAgICBhcnJvdzoge1xyXG4gICAgICAgIHBvc2l0aW9uOiAnYWJzb2x1dGUnXHJcbiAgICAgIH0sXHJcbiAgICAgIHJlZmVyZW5jZToge31cclxuICAgIH07XHJcbiAgICBPYmplY3QuYXNzaWduKHN0YXRlLmVsZW1lbnRzLnBvcHBlci5zdHlsZSwgaW5pdGlhbFN0eWxlcy5wb3BwZXIpO1xyXG4gICAgc3RhdGUuc3R5bGVzID0gaW5pdGlhbFN0eWxlcztcclxuXHJcbiAgICBpZiAoc3RhdGUuZWxlbWVudHMuYXJyb3cpIHtcclxuICAgICAgT2JqZWN0LmFzc2lnbihzdGF0ZS5lbGVtZW50cy5hcnJvdy5zdHlsZSwgaW5pdGlhbFN0eWxlcy5hcnJvdyk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgT2JqZWN0LmtleXMoc3RhdGUuZWxlbWVudHMpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzW25hbWVdO1xyXG4gICAgICAgIHZhciBhdHRyaWJ1dGVzID0gc3RhdGUuYXR0cmlidXRlc1tuYW1lXSB8fCB7fTtcclxuICAgICAgICB2YXIgc3R5bGVQcm9wZXJ0aWVzID0gT2JqZWN0LmtleXMoc3RhdGUuc3R5bGVzLmhhc093blByb3BlcnR5KG5hbWUpID8gc3RhdGUuc3R5bGVzW25hbWVdIDogaW5pdGlhbFN0eWxlc1tuYW1lXSk7IC8vIFNldCBhbGwgdmFsdWVzIHRvIGFuIGVtcHR5IHN0cmluZyB0byB1bnNldCB0aGVtXHJcblxyXG4gICAgICAgIHZhciBzdHlsZSA9IHN0eWxlUHJvcGVydGllcy5yZWR1Y2UoZnVuY3Rpb24gKHN0eWxlLCBwcm9wZXJ0eSkge1xyXG4gICAgICAgICAgc3R5bGVbcHJvcGVydHldID0gJyc7XHJcbiAgICAgICAgICByZXR1cm4gc3R5bGU7XHJcbiAgICAgICAgfSwge30pOyAvLyBhcnJvdyBpcyBvcHRpb25hbCArIHZpcnR1YWwgZWxlbWVudHNcclxuXHJcbiAgICAgICAgaWYgKCFpc0hUTUxFbGVtZW50KGVsZW1lbnQpIHx8ICFnZXROb2RlTmFtZShlbGVtZW50KSkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihlbGVtZW50LnN0eWxlLCBzdHlsZSk7XHJcbiAgICAgICAgT2JqZWN0LmtleXMoYXR0cmlidXRlcykuZm9yRWFjaChmdW5jdGlvbiAoYXR0cmlidXRlKSB7XHJcbiAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShhdHRyaWJ1dGUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9KTtcclxuICAgIH07XHJcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXHJcblxyXG5cclxuICBjb25zdCBhcHBseVN0eWxlcyQxID0ge1xyXG4gICAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcclxuICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICBwaGFzZTogJ3dyaXRlJyxcclxuICAgIGZuOiBhcHBseVN0eWxlcyxcclxuICAgIGVmZmVjdDogZWZmZWN0JDIsXHJcbiAgICByZXF1aXJlczogWydjb21wdXRlU3R5bGVzJ11cclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkge1xyXG4gICAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xyXG4gIH1cclxuXHJcbiAgdmFyIG1heCA9IE1hdGgubWF4O1xyXG4gIHZhciBtaW4gPSBNYXRoLm1pbjtcclxuICB2YXIgcm91bmQgPSBNYXRoLnJvdW5kO1xyXG5cclxuICBmdW5jdGlvbiBnZXRVQVN0cmluZygpIHtcclxuICAgIHZhciB1YURhdGEgPSBuYXZpZ2F0b3IudXNlckFnZW50RGF0YTtcclxuXHJcbiAgICBpZiAodWFEYXRhICE9IG51bGwgJiYgdWFEYXRhLmJyYW5kcyAmJiBBcnJheS5pc0FycmF5KHVhRGF0YS5icmFuZHMpKSB7XHJcbiAgICAgIHJldHVybiB1YURhdGEuYnJhbmRzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHJldHVybiBpdGVtLmJyYW5kICsgXCIvXCIgKyBpdGVtLnZlcnNpb247XHJcbiAgICAgIH0pLmpvaW4oJyAnKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbmF2aWdhdG9yLnVzZXJBZ2VudDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzTGF5b3V0Vmlld3BvcnQoKSB7XHJcbiAgICByZXR1cm4gIS9eKCg/IWNocm9tZXxhbmRyb2lkKS4pKnNhZmFyaS9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgaW5jbHVkZVNjYWxlLCBpc0ZpeGVkU3RyYXRlZ3kpIHtcclxuICAgIGlmIChpbmNsdWRlU2NhbGUgPT09IHZvaWQgMCkge1xyXG4gICAgICBpbmNsdWRlU2NhbGUgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNGaXhlZFN0cmF0ZWd5ID09PSB2b2lkIDApIHtcclxuICAgICAgaXNGaXhlZFN0cmF0ZWd5ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGNsaWVudFJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgdmFyIHNjYWxlWCA9IDE7XHJcbiAgICB2YXIgc2NhbGVZID0gMTtcclxuXHJcbiAgICBpZiAoaW5jbHVkZVNjYWxlICYmIGlzSFRNTEVsZW1lbnQoZWxlbWVudCkpIHtcclxuICAgICAgc2NhbGVYID0gZWxlbWVudC5vZmZzZXRXaWR0aCA+IDAgPyByb3VuZChjbGllbnRSZWN0LndpZHRoKSAvIGVsZW1lbnQub2Zmc2V0V2lkdGggfHwgMSA6IDE7XHJcbiAgICAgIHNjYWxlWSA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0ID4gMCA/IHJvdW5kKGNsaWVudFJlY3QuaGVpZ2h0KSAvIGVsZW1lbnQub2Zmc2V0SGVpZ2h0IHx8IDEgOiAxO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBfcmVmID0gaXNFbGVtZW50KGVsZW1lbnQpID8gZ2V0V2luZG93KGVsZW1lbnQpIDogd2luZG93LFxyXG4gICAgICAgIHZpc3VhbFZpZXdwb3J0ID0gX3JlZi52aXN1YWxWaWV3cG9ydDtcclxuXHJcbiAgICB2YXIgYWRkVmlzdWFsT2Zmc2V0cyA9ICFpc0xheW91dFZpZXdwb3J0KCkgJiYgaXNGaXhlZFN0cmF0ZWd5O1xyXG4gICAgdmFyIHggPSAoY2xpZW50UmVjdC5sZWZ0ICsgKGFkZFZpc3VhbE9mZnNldHMgJiYgdmlzdWFsVmlld3BvcnQgPyB2aXN1YWxWaWV3cG9ydC5vZmZzZXRMZWZ0IDogMCkpIC8gc2NhbGVYO1xyXG4gICAgdmFyIHkgPSAoY2xpZW50UmVjdC50b3AgKyAoYWRkVmlzdWFsT2Zmc2V0cyAmJiB2aXN1YWxWaWV3cG9ydCA/IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcCA6IDApKSAvIHNjYWxlWTtcclxuICAgIHZhciB3aWR0aCA9IGNsaWVudFJlY3Qud2lkdGggLyBzY2FsZVg7XHJcbiAgICB2YXIgaGVpZ2h0ID0gY2xpZW50UmVjdC5oZWlnaHQgLyBzY2FsZVk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICB0b3A6IHksXHJcbiAgICAgIHJpZ2h0OiB4ICsgd2lkdGgsXHJcbiAgICAgIGJvdHRvbTogeSArIGhlaWdodCxcclxuICAgICAgbGVmdDogeCxcclxuICAgICAgeDogeCxcclxuICAgICAgeTogeVxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8vIG1lYW5zIGl0IGRvZXNuJ3QgdGFrZSBpbnRvIGFjY291bnQgdHJhbnNmb3Jtcy5cclxuXHJcbiAgZnVuY3Rpb24gZ2V0TGF5b3V0UmVjdChlbGVtZW50KSB7XHJcbiAgICB2YXIgY2xpZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChlbGVtZW50KTsgLy8gVXNlIHRoZSBjbGllbnRSZWN0IHNpemVzIGlmIGl0J3Mgbm90IGJlZW4gdHJhbnNmb3JtZWQuXHJcbiAgICAvLyBGaXhlcyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEyMjNcclxuXHJcbiAgICB2YXIgd2lkdGggPSBlbGVtZW50Lm9mZnNldFdpZHRoO1xyXG4gICAgdmFyIGhlaWdodCA9IGVsZW1lbnQub2Zmc2V0SGVpZ2h0O1xyXG5cclxuICAgIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LndpZHRoIC0gd2lkdGgpIDw9IDEpIHtcclxuICAgICAgd2lkdGggPSBjbGllbnRSZWN0LndpZHRoO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChNYXRoLmFicyhjbGllbnRSZWN0LmhlaWdodCAtIGhlaWdodCkgPD0gMSkge1xyXG4gICAgICBoZWlnaHQgPSBjbGllbnRSZWN0LmhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiBlbGVtZW50Lm9mZnNldExlZnQsXHJcbiAgICAgIHk6IGVsZW1lbnQub2Zmc2V0VG9wLFxyXG4gICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgIGhlaWdodDogaGVpZ2h0XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29udGFpbnMocGFyZW50LCBjaGlsZCkge1xyXG4gICAgdmFyIHJvb3ROb2RlID0gY2hpbGQuZ2V0Um9vdE5vZGUgJiYgY2hpbGQuZ2V0Um9vdE5vZGUoKTsgLy8gRmlyc3QsIGF0dGVtcHQgd2l0aCBmYXN0ZXIgbmF0aXZlIG1ldGhvZFxyXG5cclxuICAgIGlmIChwYXJlbnQuY29udGFpbnMoY2hpbGQpKSB7XHJcbiAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfSAvLyB0aGVuIGZhbGxiYWNrIHRvIGN1c3RvbSBpbXBsZW1lbnRhdGlvbiB3aXRoIFNoYWRvdyBET00gc3VwcG9ydFxyXG4gICAgZWxzZSBpZiAocm9vdE5vZGUgJiYgaXNTaGFkb3dSb290KHJvb3ROb2RlKSkge1xyXG4gICAgICAgIHZhciBuZXh0ID0gY2hpbGQ7XHJcblxyXG4gICAgICAgIGRvIHtcclxuICAgICAgICAgIGlmIChuZXh0ICYmIHBhcmVudC5pc1NhbWVOb2RlKG5leHQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgfSAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ106IG5lZWQgYSBiZXR0ZXIgd2F5IHRvIGhhbmRsZSB0aGlzLi4uXHJcblxyXG5cclxuICAgICAgICAgIG5leHQgPSBuZXh0LnBhcmVudE5vZGUgfHwgbmV4dC5ob3N0O1xyXG4gICAgICAgIH0gd2hpbGUgKG5leHQpO1xyXG4gICAgICB9IC8vIEdpdmUgdXAsIHRoZSByZXN1bHQgaXMgZmFsc2VcclxuXHJcblxyXG4gICAgcmV0dXJuIGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpIHtcclxuICAgIHJldHVybiBnZXRXaW5kb3coZWxlbWVudCkuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzVGFibGVFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgIHJldHVybiBbJ3RhYmxlJywgJ3RkJywgJ3RoJ10uaW5kZXhPZihnZXROb2RlTmFtZShlbGVtZW50KSkgPj0gMDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KSB7XHJcbiAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXHJcbiAgICByZXR1cm4gKChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50Lm93bmVyRG9jdW1lbnQgOiAvLyAkRmxvd0ZpeE1lW3Byb3AtbWlzc2luZ11cclxuICAgIGVsZW1lbnQuZG9jdW1lbnQpIHx8IHdpbmRvdy5kb2N1bWVudCkuZG9jdW1lbnRFbGVtZW50O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0UGFyZW50Tm9kZShlbGVtZW50KSB7XHJcbiAgICBpZiAoZ2V0Tm9kZU5hbWUoZWxlbWVudCkgPT09ICdodG1sJykge1xyXG4gICAgICByZXR1cm4gZWxlbWVudDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gKC8vIHRoaXMgaXMgYSBxdWlja2VyIChidXQgbGVzcyB0eXBlIHNhZmUpIHdheSB0byBzYXZlIHF1aXRlIHNvbWUgYnl0ZXMgZnJvbSB0aGUgYnVuZGxlXHJcbiAgICAgIC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXJldHVybl1cclxuICAgICAgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXHJcbiAgICAgIGVsZW1lbnQuYXNzaWduZWRTbG90IHx8IC8vIHN0ZXAgaW50byB0aGUgc2hhZG93IERPTSBvZiB0aGUgcGFyZW50IG9mIGEgc2xvdHRlZCBub2RlXHJcbiAgICAgIGVsZW1lbnQucGFyZW50Tm9kZSB8fCAoIC8vIERPTSBFbGVtZW50IGRldGVjdGVkXHJcbiAgICAgIGlzU2hhZG93Um9vdChlbGVtZW50KSA/IGVsZW1lbnQuaG9zdCA6IG51bGwpIHx8IC8vIFNoYWRvd1Jvb3QgZGV0ZWN0ZWRcclxuICAgICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FsbF06IEhUTUxFbGVtZW50IGlzIGEgTm9kZVxyXG4gICAgICBnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkgLy8gZmFsbGJhY2tcclxuXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0VHJ1ZU9mZnNldFBhcmVudChlbGVtZW50KSB7XHJcbiAgICBpZiAoIWlzSFRNTEVsZW1lbnQoZWxlbWVudCkgfHwgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BvcHBlcmpzL3BvcHBlci1jb3JlL2lzc3Vlcy84MzdcclxuICAgIGdldENvbXB1dGVkU3R5bGUkMShlbGVtZW50KS5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xyXG4gICAgICByZXR1cm4gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZWxlbWVudC5vZmZzZXRQYXJlbnQ7XHJcbiAgfSAvLyBgLm9mZnNldFBhcmVudGAgcmVwb3J0cyBgbnVsbGAgZm9yIGZpeGVkIGVsZW1lbnRzLCB3aGlsZSBhYnNvbHV0ZSBlbGVtZW50c1xyXG4gIC8vIHJldHVybiB0aGUgY29udGFpbmluZyBibG9ja1xyXG5cclxuXHJcbiAgZnVuY3Rpb24gZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHtcclxuICAgIHZhciBpc0ZpcmVmb3ggPSAvZmlyZWZveC9pLnRlc3QoZ2V0VUFTdHJpbmcoKSk7XHJcbiAgICB2YXIgaXNJRSA9IC9UcmlkZW50L2kudGVzdChnZXRVQVN0cmluZygpKTtcclxuXHJcbiAgICBpZiAoaXNJRSAmJiBpc0hUTUxFbGVtZW50KGVsZW1lbnQpKSB7XHJcbiAgICAgIC8vIEluIElFIDksIDEwIGFuZCAxMSBmaXhlZCBlbGVtZW50cyBjb250YWluaW5nIGJsb2NrIGlzIGFsd2F5cyBlc3RhYmxpc2hlZCBieSB0aGUgdmlld3BvcnRcclxuICAgICAgdmFyIGVsZW1lbnRDc3MgPSBnZXRDb21wdXRlZFN0eWxlJDEoZWxlbWVudCk7XHJcblxyXG4gICAgICBpZiAoZWxlbWVudENzcy5wb3NpdGlvbiA9PT0gJ2ZpeGVkJykge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGN1cnJlbnROb2RlID0gZ2V0UGFyZW50Tm9kZShlbGVtZW50KTtcclxuXHJcbiAgICBpZiAoaXNTaGFkb3dSb290KGN1cnJlbnROb2RlKSkge1xyXG4gICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlLmhvc3Q7XHJcbiAgICB9XHJcblxyXG4gICAgd2hpbGUgKGlzSFRNTEVsZW1lbnQoY3VycmVudE5vZGUpICYmIFsnaHRtbCcsICdib2R5J10uaW5kZXhPZihnZXROb2RlTmFtZShjdXJyZW50Tm9kZSkpIDwgMCkge1xyXG4gICAgICB2YXIgY3NzID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGN1cnJlbnROb2RlKTsgLy8gVGhpcyBpcyBub24tZXhoYXVzdGl2ZSBidXQgY292ZXJzIHRoZSBtb3N0IGNvbW1vbiBDU1MgcHJvcGVydGllcyB0aGF0XHJcbiAgICAgIC8vIGNyZWF0ZSBhIGNvbnRhaW5pbmcgYmxvY2suXHJcbiAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0NTUy9Db250YWluaW5nX2Jsb2NrI2lkZW50aWZ5aW5nX3RoZV9jb250YWluaW5nX2Jsb2NrXHJcblxyXG4gICAgICBpZiAoY3NzLnRyYW5zZm9ybSAhPT0gJ25vbmUnIHx8IGNzcy5wZXJzcGVjdGl2ZSAhPT0gJ25vbmUnIHx8IGNzcy5jb250YWluID09PSAncGFpbnQnIHx8IFsndHJhbnNmb3JtJywgJ3BlcnNwZWN0aXZlJ10uaW5kZXhPZihjc3Mud2lsbENoYW5nZSkgIT09IC0xIHx8IGlzRmlyZWZveCAmJiBjc3Mud2lsbENoYW5nZSA9PT0gJ2ZpbHRlcicgfHwgaXNGaXJlZm94ICYmIGNzcy5maWx0ZXIgJiYgY3NzLmZpbHRlciAhPT0gJ25vbmUnKSB7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnROb2RlO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUucGFyZW50Tm9kZTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBudWxsO1xyXG4gIH0gLy8gR2V0cyB0aGUgY2xvc2VzdCBhbmNlc3RvciBwb3NpdGlvbmVkIGVsZW1lbnQuIEhhbmRsZXMgc29tZSBlZGdlIGNhc2VzLFxyXG4gIC8vIHN1Y2ggYXMgdGFibGUgYW5jZXN0b3JzIGFuZCBjcm9zcyBicm93c2VyIGJ1Z3MuXHJcblxyXG5cclxuICBmdW5jdGlvbiBnZXRPZmZzZXRQYXJlbnQoZWxlbWVudCkge1xyXG4gICAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhlbGVtZW50KTtcclxuICAgIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRUcnVlT2Zmc2V0UGFyZW50KGVsZW1lbnQpO1xyXG5cclxuICAgIHdoaWxlIChvZmZzZXRQYXJlbnQgJiYgaXNUYWJsZUVsZW1lbnQob2Zmc2V0UGFyZW50KSAmJiBnZXRDb21wdXRlZFN0eWxlJDEob2Zmc2V0UGFyZW50KS5wb3NpdGlvbiA9PT0gJ3N0YXRpYycpIHtcclxuICAgICAgb2Zmc2V0UGFyZW50ID0gZ2V0VHJ1ZU9mZnNldFBhcmVudChvZmZzZXRQYXJlbnQpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChvZmZzZXRQYXJlbnQgJiYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgPT09ICdodG1sJyB8fCBnZXROb2RlTmFtZShvZmZzZXRQYXJlbnQpID09PSAnYm9keScgJiYgZ2V0Q29tcHV0ZWRTdHlsZSQxKG9mZnNldFBhcmVudCkucG9zaXRpb24gPT09ICdzdGF0aWMnKSkge1xyXG4gICAgICByZXR1cm4gd2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBvZmZzZXRQYXJlbnQgfHwgZ2V0Q29udGFpbmluZ0Jsb2NrKGVsZW1lbnQpIHx8IHdpbmRvdztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChwbGFjZW1lbnQpIHtcclxuICAgIHJldHVybiBbJ3RvcCcsICdib3R0b20nXS5pbmRleE9mKHBsYWNlbWVudCkgPj0gMCA/ICd4JyA6ICd5JztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHdpdGhpbihtaW4kMSwgdmFsdWUsIG1heCQxKSB7XHJcbiAgICByZXR1cm4gbWF4KG1pbiQxLCBtaW4odmFsdWUsIG1heCQxKSk7XHJcbiAgfVxyXG4gIGZ1bmN0aW9uIHdpdGhpbk1heENsYW1wKG1pbiwgdmFsdWUsIG1heCkge1xyXG4gICAgdmFyIHYgPSB3aXRoaW4obWluLCB2YWx1ZSwgbWF4KTtcclxuICAgIHJldHVybiB2ID4gbWF4ID8gbWF4IDogdjtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldEZyZXNoU2lkZU9iamVjdCgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIHRvcDogMCxcclxuICAgICAgcmlnaHQ6IDAsXHJcbiAgICAgIGJvdHRvbTogMCxcclxuICAgICAgbGVmdDogMFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIG1lcmdlUGFkZGluZ09iamVjdChwYWRkaW5nT2JqZWN0KSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgZ2V0RnJlc2hTaWRlT2JqZWN0KCksIHBhZGRpbmdPYmplY3QpO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZXhwYW5kVG9IYXNoTWFwKHZhbHVlLCBrZXlzKSB7XHJcbiAgICByZXR1cm4ga2V5cy5yZWR1Y2UoZnVuY3Rpb24gKGhhc2hNYXAsIGtleSkge1xyXG4gICAgICBoYXNoTWFwW2tleV0gPSB2YWx1ZTtcclxuICAgICAgcmV0dXJuIGhhc2hNYXA7XHJcbiAgICB9LCB7fSk7XHJcbiAgfVxyXG5cclxuICB2YXIgdG9QYWRkaW5nT2JqZWN0ID0gZnVuY3Rpb24gdG9QYWRkaW5nT2JqZWN0KHBhZGRpbmcsIHN0YXRlKSB7XHJcbiAgICBwYWRkaW5nID0gdHlwZW9mIHBhZGRpbmcgPT09ICdmdW5jdGlvbicgPyBwYWRkaW5nKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLnJlY3RzLCB7XHJcbiAgICAgIHBsYWNlbWVudDogc3RhdGUucGxhY2VtZW50XHJcbiAgICB9KSkgOiBwYWRkaW5nO1xyXG4gICAgcmV0dXJuIG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gYXJyb3coX3JlZikge1xyXG4gICAgdmFyIF9zdGF0ZSRtb2RpZmllcnNEYXRhJDtcclxuXHJcbiAgICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxyXG4gICAgICAgIG5hbWUgPSBfcmVmLm5hbWUsXHJcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcclxuICAgIHZhciBhcnJvd0VsZW1lbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdztcclxuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gc3RhdGUubW9kaWZpZXJzRGF0YS5wb3BwZXJPZmZzZXRzO1xyXG4gICAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHN0YXRlLnBsYWNlbWVudCk7XHJcbiAgICB2YXIgYXhpcyA9IGdldE1haW5BeGlzRnJvbVBsYWNlbWVudChiYXNlUGxhY2VtZW50KTtcclxuICAgIHZhciBpc1ZlcnRpY2FsID0gW2xlZnQsIHJpZ2h0XS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpID49IDA7XHJcbiAgICB2YXIgbGVuID0gaXNWZXJ0aWNhbCA/ICdoZWlnaHQnIDogJ3dpZHRoJztcclxuXHJcbiAgICBpZiAoIWFycm93RWxlbWVudCB8fCAhcG9wcGVyT2Zmc2V0cykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIHBhZGRpbmdPYmplY3QgPSB0b1BhZGRpbmdPYmplY3Qob3B0aW9ucy5wYWRkaW5nLCBzdGF0ZSk7XHJcbiAgICB2YXIgYXJyb3dSZWN0ID0gZ2V0TGF5b3V0UmVjdChhcnJvd0VsZW1lbnQpO1xyXG4gICAgdmFyIG1pblByb3AgPSBheGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xyXG4gICAgdmFyIG1heFByb3AgPSBheGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcclxuICAgIHZhciBlbmREaWZmID0gc3RhdGUucmVjdHMucmVmZXJlbmNlW2xlbl0gKyBzdGF0ZS5yZWN0cy5yZWZlcmVuY2VbYXhpc10gLSBwb3BwZXJPZmZzZXRzW2F4aXNdIC0gc3RhdGUucmVjdHMucG9wcGVyW2xlbl07XHJcbiAgICB2YXIgc3RhcnREaWZmID0gcG9wcGVyT2Zmc2V0c1theGlzXSAtIHN0YXRlLnJlY3RzLnJlZmVyZW5jZVtheGlzXTtcclxuICAgIHZhciBhcnJvd09mZnNldFBhcmVudCA9IGdldE9mZnNldFBhcmVudChhcnJvd0VsZW1lbnQpO1xyXG4gICAgdmFyIGNsaWVudFNpemUgPSBhcnJvd09mZnNldFBhcmVudCA/IGF4aXMgPT09ICd5JyA/IGFycm93T2Zmc2V0UGFyZW50LmNsaWVudEhlaWdodCB8fCAwIDogYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50V2lkdGggfHwgMCA6IDA7XHJcbiAgICB2YXIgY2VudGVyVG9SZWZlcmVuY2UgPSBlbmREaWZmIC8gMiAtIHN0YXJ0RGlmZiAvIDI7IC8vIE1ha2Ugc3VyZSB0aGUgYXJyb3cgZG9lc24ndCBvdmVyZmxvdyB0aGUgcG9wcGVyIGlmIHRoZSBjZW50ZXIgcG9pbnQgaXNcclxuICAgIC8vIG91dHNpZGUgb2YgdGhlIHBvcHBlciBib3VuZHNcclxuXHJcbiAgICB2YXIgbWluID0gcGFkZGluZ09iamVjdFttaW5Qcm9wXTtcclxuICAgIHZhciBtYXggPSBjbGllbnRTaXplIC0gYXJyb3dSZWN0W2xlbl0gLSBwYWRkaW5nT2JqZWN0W21heFByb3BdO1xyXG4gICAgdmFyIGNlbnRlciA9IGNsaWVudFNpemUgLyAyIC0gYXJyb3dSZWN0W2xlbl0gLyAyICsgY2VudGVyVG9SZWZlcmVuY2U7XHJcbiAgICB2YXIgb2Zmc2V0ID0gd2l0aGluKG1pbiwgY2VudGVyLCBtYXgpOyAvLyBQcmV2ZW50cyBicmVha2luZyBzeW50YXggaGlnaGxpZ2h0aW5nLi4uXHJcblxyXG4gICAgdmFyIGF4aXNQcm9wID0gYXhpcztcclxuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSAoX3N0YXRlJG1vZGlmaWVyc0RhdGEkID0ge30sIF9zdGF0ZSRtb2RpZmllcnNEYXRhJFtheGlzUHJvcF0gPSBvZmZzZXQsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJC5jZW50ZXJPZmZzZXQgPSBvZmZzZXQgLSBjZW50ZXIsIF9zdGF0ZSRtb2RpZmllcnNEYXRhJCk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBlZmZlY3QkMShfcmVmMikge1xyXG4gICAgdmFyIHN0YXRlID0gX3JlZjIuc3RhdGUsXHJcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYyLm9wdGlvbnM7XHJcbiAgICB2YXIgX29wdGlvbnMkZWxlbWVudCA9IG9wdGlvbnMuZWxlbWVudCxcclxuICAgICAgICBhcnJvd0VsZW1lbnQgPSBfb3B0aW9ucyRlbGVtZW50ID09PSB2b2lkIDAgPyAnW2RhdGEtcG9wcGVyLWFycm93XScgOiBfb3B0aW9ucyRlbGVtZW50O1xyXG5cclxuICAgIGlmIChhcnJvd0VsZW1lbnQgPT0gbnVsbCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9IC8vIENTUyBzZWxlY3RvclxyXG5cclxuXHJcbiAgICBpZiAodHlwZW9mIGFycm93RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgYXJyb3dFbGVtZW50ID0gc3RhdGUuZWxlbWVudHMucG9wcGVyLnF1ZXJ5U2VsZWN0b3IoYXJyb3dFbGVtZW50KTtcclxuXHJcbiAgICAgIGlmICghYXJyb3dFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFjb250YWlucyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIsIGFycm93RWxlbWVudCkpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLmVsZW1lbnRzLmFycm93ID0gYXJyb3dFbGVtZW50O1xyXG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xyXG5cclxuXHJcbiAgY29uc3QgYXJyb3ckMSA9IHtcclxuICAgIG5hbWU6ICdhcnJvdycsXHJcbiAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgcGhhc2U6ICdtYWluJyxcclxuICAgIGZuOiBhcnJvdyxcclxuICAgIGVmZmVjdDogZWZmZWN0JDEsXHJcbiAgICByZXF1aXJlczogWydwb3BwZXJPZmZzZXRzJ10sXHJcbiAgICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddXHJcbiAgfTtcclxuXHJcbiAgZnVuY3Rpb24gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkge1xyXG4gICAgcmV0dXJuIHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xyXG4gIH1cclxuXHJcbiAgdmFyIHVuc2V0U2lkZXMgPSB7XHJcbiAgICB0b3A6ICdhdXRvJyxcclxuICAgIHJpZ2h0OiAnYXV0bycsXHJcbiAgICBib3R0b206ICdhdXRvJyxcclxuICAgIGxlZnQ6ICdhdXRvJ1xyXG4gIH07IC8vIFJvdW5kIHRoZSBvZmZzZXRzIHRvIHRoZSBuZWFyZXN0IHN1aXRhYmxlIHN1YnBpeGVsIGJhc2VkIG9uIHRoZSBEUFIuXHJcbiAgLy8gWm9vbWluZyBjYW4gY2hhbmdlIHRoZSBEUFIsIGJ1dCBpdCBzZWVtcyB0byByZXBvcnQgYSB2YWx1ZSB0aGF0IHdpbGxcclxuICAvLyBjbGVhbmx5IGRpdmlkZSB0aGUgdmFsdWVzIGludG8gdGhlIGFwcHJvcHJpYXRlIHN1YnBpeGVscy5cclxuXHJcbiAgZnVuY3Rpb24gcm91bmRPZmZzZXRzQnlEUFIoX3JlZiwgd2luKSB7XHJcbiAgICB2YXIgeCA9IF9yZWYueCxcclxuICAgICAgICB5ID0gX3JlZi55O1xyXG4gICAgdmFyIGRwciA9IHdpbi5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB4OiByb3VuZCh4ICogZHByKSAvIGRwciB8fCAwLFxyXG4gICAgICB5OiByb3VuZCh5ICogZHByKSAvIGRwciB8fCAwXHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gbWFwVG9TdHlsZXMoX3JlZjIpIHtcclxuICAgIHZhciBfT2JqZWN0JGFzc2lnbjI7XHJcblxyXG4gICAgdmFyIHBvcHBlciA9IF9yZWYyLnBvcHBlcixcclxuICAgICAgICBwb3BwZXJSZWN0ID0gX3JlZjIucG9wcGVyUmVjdCxcclxuICAgICAgICBwbGFjZW1lbnQgPSBfcmVmMi5wbGFjZW1lbnQsXHJcbiAgICAgICAgdmFyaWF0aW9uID0gX3JlZjIudmFyaWF0aW9uLFxyXG4gICAgICAgIG9mZnNldHMgPSBfcmVmMi5vZmZzZXRzLFxyXG4gICAgICAgIHBvc2l0aW9uID0gX3JlZjIucG9zaXRpb24sXHJcbiAgICAgICAgZ3B1QWNjZWxlcmF0aW9uID0gX3JlZjIuZ3B1QWNjZWxlcmF0aW9uLFxyXG4gICAgICAgIGFkYXB0aXZlID0gX3JlZjIuYWRhcHRpdmUsXHJcbiAgICAgICAgcm91bmRPZmZzZXRzID0gX3JlZjIucm91bmRPZmZzZXRzLFxyXG4gICAgICAgIGlzRml4ZWQgPSBfcmVmMi5pc0ZpeGVkO1xyXG4gICAgdmFyIF9vZmZzZXRzJHggPSBvZmZzZXRzLngsXHJcbiAgICAgICAgeCA9IF9vZmZzZXRzJHggPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR4LFxyXG4gICAgICAgIF9vZmZzZXRzJHkgPSBvZmZzZXRzLnksXHJcbiAgICAgICAgeSA9IF9vZmZzZXRzJHkgPT09IHZvaWQgMCA/IDAgOiBfb2Zmc2V0cyR5O1xyXG5cclxuICAgIHZhciBfcmVmMyA9IHR5cGVvZiByb3VuZE9mZnNldHMgPT09ICdmdW5jdGlvbicgPyByb3VuZE9mZnNldHMoe1xyXG4gICAgICB4OiB4LFxyXG4gICAgICB5OiB5XHJcbiAgICB9KSA6IHtcclxuICAgICAgeDogeCxcclxuICAgICAgeTogeVxyXG4gICAgfTtcclxuXHJcbiAgICB4ID0gX3JlZjMueDtcclxuICAgIHkgPSBfcmVmMy55O1xyXG4gICAgdmFyIGhhc1ggPSBvZmZzZXRzLmhhc093blByb3BlcnR5KCd4Jyk7XHJcbiAgICB2YXIgaGFzWSA9IG9mZnNldHMuaGFzT3duUHJvcGVydHkoJ3knKTtcclxuICAgIHZhciBzaWRlWCA9IGxlZnQ7XHJcbiAgICB2YXIgc2lkZVkgPSB0b3A7XHJcbiAgICB2YXIgd2luID0gd2luZG93O1xyXG5cclxuICAgIGlmIChhZGFwdGl2ZSkge1xyXG4gICAgICB2YXIgb2Zmc2V0UGFyZW50ID0gZ2V0T2Zmc2V0UGFyZW50KHBvcHBlcik7XHJcbiAgICAgIHZhciBoZWlnaHRQcm9wID0gJ2NsaWVudEhlaWdodCc7XHJcbiAgICAgIHZhciB3aWR0aFByb3AgPSAnY2xpZW50V2lkdGgnO1xyXG5cclxuICAgICAgaWYgKG9mZnNldFBhcmVudCA9PT0gZ2V0V2luZG93KHBvcHBlcikpIHtcclxuICAgICAgICBvZmZzZXRQYXJlbnQgPSBnZXREb2N1bWVudEVsZW1lbnQocG9wcGVyKTtcclxuXHJcbiAgICAgICAgaWYgKGdldENvbXB1dGVkU3R5bGUkMShvZmZzZXRQYXJlbnQpLnBvc2l0aW9uICE9PSAnc3RhdGljJyAmJiBwb3NpdGlvbiA9PT0gJ2Fic29sdXRlJykge1xyXG4gICAgICAgICAgaGVpZ2h0UHJvcCA9ICdzY3JvbGxIZWlnaHQnO1xyXG4gICAgICAgICAgd2lkdGhQcm9wID0gJ3Njcm9sbFdpZHRoJztcclxuICAgICAgICB9XHJcbiAgICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtY2FzdF06IGZvcmNlIHR5cGUgcmVmaW5lbWVudCwgd2UgY29tcGFyZSBvZmZzZXRQYXJlbnQgd2l0aCB3aW5kb3cgYWJvdmUsIGJ1dCBGbG93IGRvZXNuJ3QgZGV0ZWN0IGl0XHJcblxyXG5cclxuICAgICAgb2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50O1xyXG5cclxuICAgICAgaWYgKHBsYWNlbWVudCA9PT0gdG9wIHx8IChwbGFjZW1lbnQgPT09IGxlZnQgfHwgcGxhY2VtZW50ID09PSByaWdodCkgJiYgdmFyaWF0aW9uID09PSBlbmQpIHtcclxuICAgICAgICBzaWRlWSA9IGJvdHRvbTtcclxuICAgICAgICB2YXIgb2Zmc2V0WSA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LmhlaWdodCA6IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxyXG4gICAgICAgIG9mZnNldFBhcmVudFtoZWlnaHRQcm9wXTtcclxuICAgICAgICB5IC09IG9mZnNldFkgLSBwb3BwZXJSZWN0LmhlaWdodDtcclxuICAgICAgICB5ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHBsYWNlbWVudCA9PT0gbGVmdCB8fCAocGxhY2VtZW50ID09PSB0b3AgfHwgcGxhY2VtZW50ID09PSBib3R0b20pICYmIHZhcmlhdGlvbiA9PT0gZW5kKSB7XHJcbiAgICAgICAgc2lkZVggPSByaWdodDtcclxuICAgICAgICB2YXIgb2Zmc2V0WCA9IGlzRml4ZWQgJiYgb2Zmc2V0UGFyZW50ID09PSB3aW4gJiYgd2luLnZpc3VhbFZpZXdwb3J0ID8gd2luLnZpc3VhbFZpZXdwb3J0LndpZHRoIDogLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXHJcbiAgICAgICAgb2Zmc2V0UGFyZW50W3dpZHRoUHJvcF07XHJcbiAgICAgICAgeCAtPSBvZmZzZXRYIC0gcG9wcGVyUmVjdC53aWR0aDtcclxuICAgICAgICB4ICo9IGdwdUFjY2VsZXJhdGlvbiA/IDEgOiAtMTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBjb21tb25TdHlsZXMgPSBPYmplY3QuYXNzaWduKHtcclxuICAgICAgcG9zaXRpb246IHBvc2l0aW9uXHJcbiAgICB9LCBhZGFwdGl2ZSAmJiB1bnNldFNpZGVzKTtcclxuXHJcbiAgICB2YXIgX3JlZjQgPSByb3VuZE9mZnNldHMgPT09IHRydWUgPyByb3VuZE9mZnNldHNCeURQUih7XHJcbiAgICAgIHg6IHgsXHJcbiAgICAgIHk6IHlcclxuICAgIH0sIGdldFdpbmRvdyhwb3BwZXIpKSA6IHtcclxuICAgICAgeDogeCxcclxuICAgICAgeTogeVxyXG4gICAgfTtcclxuXHJcbiAgICB4ID0gX3JlZjQueDtcclxuICAgIHkgPSBfcmVmNC55O1xyXG5cclxuICAgIGlmIChncHVBY2NlbGVyYXRpb24pIHtcclxuICAgICAgdmFyIF9PYmplY3QkYXNzaWduO1xyXG5cclxuICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduID0ge30sIF9PYmplY3QkYXNzaWduW3NpZGVZXSA9IGhhc1kgPyAnMCcgOiAnJywgX09iamVjdCRhc3NpZ25bc2lkZVhdID0gaGFzWCA/ICcwJyA6ICcnLCBfT2JqZWN0JGFzc2lnbi50cmFuc2Zvcm0gPSAod2luLmRldmljZVBpeGVsUmF0aW8gfHwgMSkgPD0gMSA/IFwidHJhbnNsYXRlKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgpXCIgOiBcInRyYW5zbGF0ZTNkKFwiICsgeCArIFwicHgsIFwiICsgeSArIFwicHgsIDApXCIsIF9PYmplY3QkYXNzaWduKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywgKF9PYmplY3QkYXNzaWduMiA9IHt9LCBfT2JqZWN0JGFzc2lnbjJbc2lkZVldID0gaGFzWSA/IHkgKyBcInB4XCIgOiAnJywgX09iamVjdCRhc3NpZ24yW3NpZGVYXSA9IGhhc1ggPyB4ICsgXCJweFwiIDogJycsIF9PYmplY3QkYXNzaWduMi50cmFuc2Zvcm0gPSAnJywgX09iamVjdCRhc3NpZ24yKSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBjb21wdXRlU3R5bGVzKF9yZWY1KSB7XHJcbiAgICB2YXIgc3RhdGUgPSBfcmVmNS5zdGF0ZSxcclxuICAgICAgICBvcHRpb25zID0gX3JlZjUub3B0aW9ucztcclxuICAgIHZhciBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPSBvcHRpb25zLmdwdUFjY2VsZXJhdGlvbixcclxuICAgICAgICBncHVBY2NlbGVyYXRpb24gPSBfb3B0aW9ucyRncHVBY2NlbGVyYXQgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRncHVBY2NlbGVyYXQsXHJcbiAgICAgICAgX29wdGlvbnMkYWRhcHRpdmUgPSBvcHRpb25zLmFkYXB0aXZlLFxyXG4gICAgICAgIGFkYXB0aXZlID0gX29wdGlvbnMkYWRhcHRpdmUgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhZGFwdGl2ZSxcclxuICAgICAgICBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPSBvcHRpb25zLnJvdW5kT2Zmc2V0cyxcclxuICAgICAgICByb3VuZE9mZnNldHMgPSBfb3B0aW9ucyRyb3VuZE9mZnNldHMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRyb3VuZE9mZnNldHM7XHJcbiAgICB2YXIgY29tbW9uU3R5bGVzID0ge1xyXG4gICAgICBwbGFjZW1lbnQ6IGdldEJhc2VQbGFjZW1lbnQoc3RhdGUucGxhY2VtZW50KSxcclxuICAgICAgdmFyaWF0aW9uOiBnZXRWYXJpYXRpb24oc3RhdGUucGxhY2VtZW50KSxcclxuICAgICAgcG9wcGVyOiBzdGF0ZS5lbGVtZW50cy5wb3BwZXIsXHJcbiAgICAgIHBvcHBlclJlY3Q6IHN0YXRlLnJlY3RzLnBvcHBlcixcclxuICAgICAgZ3B1QWNjZWxlcmF0aW9uOiBncHVBY2NlbGVyYXRpb24sXHJcbiAgICAgIGlzRml4ZWQ6IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCdcclxuICAgIH07XHJcblxyXG4gICAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEucG9wcGVyT2Zmc2V0cyAhPSBudWxsKSB7XHJcbiAgICAgIHN0YXRlLnN0eWxlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMucG9wcGVyLCBtYXBUb1N0eWxlcyhPYmplY3QuYXNzaWduKHt9LCBjb21tb25TdHlsZXMsIHtcclxuICAgICAgICBvZmZzZXRzOiBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMsXHJcbiAgICAgICAgcG9zaXRpb246IHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3ksXHJcbiAgICAgICAgYWRhcHRpdmU6IGFkYXB0aXZlLFxyXG4gICAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXHJcbiAgICAgIH0pKSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3cgIT0gbnVsbCkge1xyXG4gICAgICBzdGF0ZS5zdHlsZXMuYXJyb3cgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5zdHlsZXMuYXJyb3csIG1hcFRvU3R5bGVzKE9iamVjdC5hc3NpZ24oe30sIGNvbW1vblN0eWxlcywge1xyXG4gICAgICAgIG9mZnNldHM6IHN0YXRlLm1vZGlmaWVyc0RhdGEuYXJyb3csXHJcbiAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgYWRhcHRpdmU6IGZhbHNlLFxyXG4gICAgICAgIHJvdW5kT2Zmc2V0czogcm91bmRPZmZzZXRzXHJcbiAgICAgIH0pKSk7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xyXG4gICAgICAnZGF0YS1wb3BwZXItcGxhY2VtZW50Jzogc3RhdGUucGxhY2VtZW50XHJcbiAgICB9KTtcclxuICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcclxuXHJcblxyXG4gIGNvbnN0IGNvbXB1dGVTdHlsZXMkMSA9IHtcclxuICAgIG5hbWU6ICdjb21wdXRlU3R5bGVzJyxcclxuICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICBwaGFzZTogJ2JlZm9yZVdyaXRlJyxcclxuICAgIGZuOiBjb21wdXRlU3R5bGVzLFxyXG4gICAgZGF0YToge31cclxuICB9O1xyXG5cclxuICB2YXIgcGFzc2l2ZSA9IHtcclxuICAgIHBhc3NpdmU6IHRydWVcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBlZmZlY3QoX3JlZikge1xyXG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcclxuICAgICAgICBpbnN0YW5jZSA9IF9yZWYuaW5zdGFuY2UsXHJcbiAgICAgICAgb3B0aW9ucyA9IF9yZWYub3B0aW9ucztcclxuICAgIHZhciBfb3B0aW9ucyRzY3JvbGwgPSBvcHRpb25zLnNjcm9sbCxcclxuICAgICAgICBzY3JvbGwgPSBfb3B0aW9ucyRzY3JvbGwgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRzY3JvbGwsXHJcbiAgICAgICAgX29wdGlvbnMkcmVzaXplID0gb3B0aW9ucy5yZXNpemUsXHJcbiAgICAgICAgcmVzaXplID0gX29wdGlvbnMkcmVzaXplID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkcmVzaXplO1xyXG4gICAgdmFyIHdpbmRvdyA9IGdldFdpbmRvdyhzdGF0ZS5lbGVtZW50cy5wb3BwZXIpO1xyXG4gICAgdmFyIHNjcm9sbFBhcmVudHMgPSBbXS5jb25jYXQoc3RhdGUuc2Nyb2xsUGFyZW50cy5yZWZlcmVuY2UsIHN0YXRlLnNjcm9sbFBhcmVudHMucG9wcGVyKTtcclxuXHJcbiAgICBpZiAoc2Nyb2xsKSB7XHJcbiAgICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XHJcbiAgICAgICAgc2Nyb2xsUGFyZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChyZXNpemUpIHtcclxuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGluc3RhbmNlLnVwZGF0ZSwgcGFzc2l2ZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKHNjcm9sbCkge1xyXG4gICAgICAgIHNjcm9sbFBhcmVudHMuZm9yRWFjaChmdW5jdGlvbiAoc2Nyb2xsUGFyZW50KSB7XHJcbiAgICAgICAgICBzY3JvbGxQYXJlbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgaW5zdGFuY2UudXBkYXRlLCBwYXNzaXZlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJlc2l6ZSkge1xyXG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBpbnN0YW5jZS51cGRhdGUsIHBhc3NpdmUpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xyXG5cclxuXHJcbiAgY29uc3QgZXZlbnRMaXN0ZW5lcnMgPSB7XHJcbiAgICBuYW1lOiAnZXZlbnRMaXN0ZW5lcnMnLFxyXG4gICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgIHBoYXNlOiAnd3JpdGUnLFxyXG4gICAgZm46IGZ1bmN0aW9uIGZuKCkge30sXHJcbiAgICBlZmZlY3Q6IGVmZmVjdCxcclxuICAgIGRhdGE6IHt9XHJcbiAgfTtcclxuXHJcbiAgdmFyIGhhc2gkMSA9IHtcclxuICAgIGxlZnQ6ICdyaWdodCcsXHJcbiAgICByaWdodDogJ2xlZnQnLFxyXG4gICAgYm90dG9tOiAndG9wJyxcclxuICAgIHRvcDogJ2JvdHRvbSdcclxuICB9O1xyXG4gIGZ1bmN0aW9uIGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCkge1xyXG4gICAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcclxuICAgICAgcmV0dXJuIGhhc2gkMVttYXRjaGVkXTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgdmFyIGhhc2ggPSB7XHJcbiAgICBzdGFydDogJ2VuZCcsXHJcbiAgICBlbmQ6ICdzdGFydCdcclxuICB9O1xyXG4gIGZ1bmN0aW9uIGdldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCkge1xyXG4gICAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9zdGFydHxlbmQvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcclxuICAgICAgcmV0dXJuIGhhc2hbbWF0Y2hlZF07XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFdpbmRvd1Njcm9sbChub2RlKSB7XHJcbiAgICB2YXIgd2luID0gZ2V0V2luZG93KG5vZGUpO1xyXG4gICAgdmFyIHNjcm9sbExlZnQgPSB3aW4ucGFnZVhPZmZzZXQ7XHJcbiAgICB2YXIgc2Nyb2xsVG9wID0gd2luLnBhZ2VZT2Zmc2V0O1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc2Nyb2xsTGVmdDogc2Nyb2xsTGVmdCxcclxuICAgICAgc2Nyb2xsVG9wOiBzY3JvbGxUb3BcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpIHtcclxuICAgIC8vIElmIDxodG1sPiBoYXMgYSBDU1Mgd2lkdGggZ3JlYXRlciB0aGFuIHRoZSB2aWV3cG9ydCwgdGhlbiB0aGlzIHdpbGwgYmVcclxuICAgIC8vIGluY29ycmVjdCBmb3IgUlRMLlxyXG4gICAgLy8gUG9wcGVyIDEgaXMgYnJva2VuIGluIHRoaXMgY2FzZSBhbmQgbmV2ZXIgaGFkIGEgYnVnIHJlcG9ydCBzbyBsZXQncyBhc3N1bWVcclxuICAgIC8vIGl0J3Mgbm90IGFuIGlzc3VlLiBJIGRvbid0IHRoaW5rIGFueW9uZSBldmVyIHNwZWNpZmllcyB3aWR0aCBvbiA8aHRtbD5cclxuICAgIC8vIGFueXdheS5cclxuICAgIC8vIEJyb3dzZXJzIHdoZXJlIHRoZSBsZWZ0IHNjcm9sbGJhciBkb2Vzbid0IGNhdXNlIGFuIGlzc3VlIHJlcG9ydCBgMGAgZm9yXHJcbiAgICAvLyB0aGlzIChlLmcuIEVkZ2UgMjAxOSwgSUUxMSwgU2FmYXJpKVxyXG4gICAgcmV0dXJuIGdldEJvdW5kaW5nQ2xpZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpLmxlZnQgKyBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCkuc2Nyb2xsTGVmdDtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkge1xyXG4gICAgdmFyIHdpbiA9IGdldFdpbmRvdyhlbGVtZW50KTtcclxuICAgIHZhciBodG1sID0gZ2V0RG9jdW1lbnRFbGVtZW50KGVsZW1lbnQpO1xyXG4gICAgdmFyIHZpc3VhbFZpZXdwb3J0ID0gd2luLnZpc3VhbFZpZXdwb3J0O1xyXG4gICAgdmFyIHdpZHRoID0gaHRtbC5jbGllbnRXaWR0aDtcclxuICAgIHZhciBoZWlnaHQgPSBodG1sLmNsaWVudEhlaWdodDtcclxuICAgIHZhciB4ID0gMDtcclxuICAgIHZhciB5ID0gMDtcclxuXHJcbiAgICBpZiAodmlzdWFsVmlld3BvcnQpIHtcclxuICAgICAgd2lkdGggPSB2aXN1YWxWaWV3cG9ydC53aWR0aDtcclxuICAgICAgaGVpZ2h0ID0gdmlzdWFsVmlld3BvcnQuaGVpZ2h0O1xyXG4gICAgICB2YXIgbGF5b3V0Vmlld3BvcnQgPSBpc0xheW91dFZpZXdwb3J0KCk7XHJcblxyXG4gICAgICBpZiAobGF5b3V0Vmlld3BvcnQgfHwgIWxheW91dFZpZXdwb3J0ICYmIHN0cmF0ZWd5ID09PSAnZml4ZWQnKSB7XHJcbiAgICAgICAgeCA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldExlZnQ7XHJcbiAgICAgICAgeSA9IHZpc3VhbFZpZXdwb3J0Lm9mZnNldFRvcDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB7XHJcbiAgICAgIHdpZHRoOiB3aWR0aCxcclxuICAgICAgaGVpZ2h0OiBoZWlnaHQsXHJcbiAgICAgIHg6IHggKyBnZXRXaW5kb3dTY3JvbGxCYXJYKGVsZW1lbnQpLFxyXG4gICAgICB5OiB5XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgLy8gb2YgdGhlIGA8aHRtbD5gIGFuZCBgPGJvZHk+YCByZWN0IGJvdW5kcyBpZiBob3Jpem9udGFsbHkgc2Nyb2xsYWJsZVxyXG5cclxuICBmdW5jdGlvbiBnZXREb2N1bWVudFJlY3QoZWxlbWVudCkge1xyXG4gICAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcclxuXHJcbiAgICB2YXIgaHRtbCA9IGdldERvY3VtZW50RWxlbWVudChlbGVtZW50KTtcclxuICAgIHZhciB3aW5TY3JvbGwgPSBnZXRXaW5kb3dTY3JvbGwoZWxlbWVudCk7XHJcbiAgICB2YXIgYm9keSA9IChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keTtcclxuICAgIHZhciB3aWR0aCA9IG1heChodG1sLnNjcm9sbFdpZHRoLCBodG1sLmNsaWVudFdpZHRoLCBib2R5ID8gYm9keS5zY3JvbGxXaWR0aCA6IDAsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCk7XHJcbiAgICB2YXIgaGVpZ2h0ID0gbWF4KGh0bWwuc2Nyb2xsSGVpZ2h0LCBodG1sLmNsaWVudEhlaWdodCwgYm9keSA/IGJvZHkuc2Nyb2xsSGVpZ2h0IDogMCwgYm9keSA/IGJvZHkuY2xpZW50SGVpZ2h0IDogMCk7XHJcbiAgICB2YXIgeCA9IC13aW5TY3JvbGwuc2Nyb2xsTGVmdCArIGdldFdpbmRvd1Njcm9sbEJhclgoZWxlbWVudCk7XHJcbiAgICB2YXIgeSA9IC13aW5TY3JvbGwuc2Nyb2xsVG9wO1xyXG5cclxuICAgIGlmIChnZXRDb21wdXRlZFN0eWxlJDEoYm9keSB8fCBodG1sKS5kaXJlY3Rpb24gPT09ICdydGwnKSB7XHJcbiAgICAgIHggKz0gbWF4KGh0bWwuY2xpZW50V2lkdGgsIGJvZHkgPyBib2R5LmNsaWVudFdpZHRoIDogMCkgLSB3aWR0aDtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICB3aWR0aDogd2lkdGgsXHJcbiAgICAgIGhlaWdodDogaGVpZ2h0LFxyXG4gICAgICB4OiB4LFxyXG4gICAgICB5OiB5XHJcbiAgICB9O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gaXNTY3JvbGxQYXJlbnQoZWxlbWVudCkge1xyXG4gICAgLy8gRmlyZWZveCB3YW50cyB1cyB0byBjaGVjayBgLXhgIGFuZCBgLXlgIHZhcmlhdGlvbnMgYXMgd2VsbFxyXG4gICAgdmFyIF9nZXRDb21wdXRlZFN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpLFxyXG4gICAgICAgIG92ZXJmbG93ID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3csXHJcbiAgICAgICAgb3ZlcmZsb3dYID0gX2dldENvbXB1dGVkU3R5bGUub3ZlcmZsb3dYLFxyXG4gICAgICAgIG92ZXJmbG93WSA9IF9nZXRDb21wdXRlZFN0eWxlLm92ZXJmbG93WTtcclxuXHJcbiAgICByZXR1cm4gL2F1dG98c2Nyb2xsfG92ZXJsYXl8aGlkZGVuLy50ZXN0KG92ZXJmbG93ICsgb3ZlcmZsb3dZICsgb3ZlcmZsb3dYKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGdldFNjcm9sbFBhcmVudChub2RlKSB7XHJcbiAgICBpZiAoWydodG1sJywgJ2JvZHknLCAnI2RvY3VtZW50J10uaW5kZXhPZihnZXROb2RlTmFtZShub2RlKSkgPj0gMCkge1xyXG4gICAgICAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dOiBhc3N1bWUgYm9keSBpcyBhbHdheXMgYXZhaWxhYmxlXHJcbiAgICAgIHJldHVybiBub2RlLm93bmVyRG9jdW1lbnQuYm9keTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaXNIVE1MRWxlbWVudChub2RlKSAmJiBpc1Njcm9sbFBhcmVudChub2RlKSkge1xyXG4gICAgICByZXR1cm4gbm9kZTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUobm9kZSkpO1xyXG4gIH1cclxuXHJcbiAgLypcclxuICBnaXZlbiBhIERPTSBlbGVtZW50LCByZXR1cm4gdGhlIGxpc3Qgb2YgYWxsIHNjcm9sbCBwYXJlbnRzLCB1cCB0aGUgbGlzdCBvZiBhbmNlc29yc1xyXG4gIHVudGlsIHdlIGdldCB0byB0aGUgdG9wIHdpbmRvdyBvYmplY3QuIFRoaXMgbGlzdCBpcyB3aGF0IHdlIGF0dGFjaCBzY3JvbGwgbGlzdGVuZXJzXHJcbiAgdG8sIGJlY2F1c2UgaWYgYW55IG9mIHRoZXNlIHBhcmVudCBlbGVtZW50cyBzY3JvbGwsIHdlJ2xsIG5lZWQgdG8gcmUtY2FsY3VsYXRlIHRoZVxyXG4gIHJlZmVyZW5jZSBlbGVtZW50J3MgcG9zaXRpb24uXHJcbiAgKi9cclxuXHJcbiAgZnVuY3Rpb24gbGlzdFNjcm9sbFBhcmVudHMoZWxlbWVudCwgbGlzdCkge1xyXG4gICAgdmFyIF9lbGVtZW50JG93bmVyRG9jdW1lbjtcclxuXHJcbiAgICBpZiAobGlzdCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIGxpc3QgPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgc2Nyb2xsUGFyZW50ID0gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpO1xyXG4gICAgdmFyIGlzQm9keSA9IHNjcm9sbFBhcmVudCA9PT0gKChfZWxlbWVudCRvd25lckRvY3VtZW4gPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZWxlbWVudCRvd25lckRvY3VtZW4uYm9keSk7XHJcbiAgICB2YXIgd2luID0gZ2V0V2luZG93KHNjcm9sbFBhcmVudCk7XHJcbiAgICB2YXIgdGFyZ2V0ID0gaXNCb2R5ID8gW3dpbl0uY29uY2F0KHdpbi52aXN1YWxWaWV3cG9ydCB8fCBbXSwgaXNTY3JvbGxQYXJlbnQoc2Nyb2xsUGFyZW50KSA/IHNjcm9sbFBhcmVudCA6IFtdKSA6IHNjcm9sbFBhcmVudDtcclxuICAgIHZhciB1cGRhdGVkTGlzdCA9IGxpc3QuY29uY2F0KHRhcmdldCk7XHJcbiAgICByZXR1cm4gaXNCb2R5ID8gdXBkYXRlZExpc3QgOiAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1jYWxsXTogaXNCb2R5IHRlbGxzIHVzIHRhcmdldCB3aWxsIGJlIGFuIEhUTUxFbGVtZW50IGhlcmVcclxuICAgIHVwZGF0ZWRMaXN0LmNvbmNhdChsaXN0U2Nyb2xsUGFyZW50cyhnZXRQYXJlbnROb2RlKHRhcmdldCkpKTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHJlY3RUb0NsaWVudFJlY3QocmVjdCkge1xyXG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIHJlY3QsIHtcclxuICAgICAgbGVmdDogcmVjdC54LFxyXG4gICAgICB0b3A6IHJlY3QueSxcclxuICAgICAgcmlnaHQ6IHJlY3QueCArIHJlY3Qud2lkdGgsXHJcbiAgICAgIGJvdHRvbTogcmVjdC55ICsgcmVjdC5oZWlnaHRcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZ2V0SW5uZXJCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCwgc3RyYXRlZ3kpIHtcclxuICAgIHZhciByZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGVsZW1lbnQsIGZhbHNlLCBzdHJhdGVneSA9PT0gJ2ZpeGVkJyk7XHJcbiAgICByZWN0LnRvcCA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRUb3A7XHJcbiAgICByZWN0LmxlZnQgPSByZWN0LmxlZnQgKyBlbGVtZW50LmNsaWVudExlZnQ7XHJcbiAgICByZWN0LmJvdHRvbSA9IHJlY3QudG9wICsgZWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgICByZWN0LnJpZ2h0ID0gcmVjdC5sZWZ0ICsgZWxlbWVudC5jbGllbnRXaWR0aDtcclxuICAgIHJlY3Qud2lkdGggPSBlbGVtZW50LmNsaWVudFdpZHRoO1xyXG4gICAgcmVjdC5oZWlnaHQgPSBlbGVtZW50LmNsaWVudEhlaWdodDtcclxuICAgIHJlY3QueCA9IHJlY3QubGVmdDtcclxuICAgIHJlY3QueSA9IHJlY3QudG9wO1xyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpIHtcclxuICAgIHJldHVybiBjbGlwcGluZ1BhcmVudCA9PT0gdmlld3BvcnQgPyByZWN0VG9DbGllbnRSZWN0KGdldFZpZXdwb3J0UmVjdChlbGVtZW50LCBzdHJhdGVneSkpIDogaXNFbGVtZW50KGNsaXBwaW5nUGFyZW50KSA/IGdldElubmVyQm91bmRpbmdDbGllbnRSZWN0KGNsaXBwaW5nUGFyZW50LCBzdHJhdGVneSkgOiByZWN0VG9DbGllbnRSZWN0KGdldERvY3VtZW50UmVjdChnZXREb2N1bWVudEVsZW1lbnQoZWxlbWVudCkpKTtcclxuICB9IC8vIEEgXCJjbGlwcGluZyBwYXJlbnRcIiBpcyBhbiBvdmVyZmxvd2FibGUgY29udGFpbmVyIHdpdGggdGhlIGNoYXJhY3RlcmlzdGljIG9mXHJcbiAgLy8gY2xpcHBpbmcgKG9yIGhpZGluZykgb3ZlcmZsb3dpbmcgZWxlbWVudHMgd2l0aCBhIHBvc2l0aW9uIGRpZmZlcmVudCBmcm9tXHJcbiAgLy8gYGluaXRpYWxgXHJcblxyXG5cclxuICBmdW5jdGlvbiBnZXRDbGlwcGluZ1BhcmVudHMoZWxlbWVudCkge1xyXG4gICAgdmFyIGNsaXBwaW5nUGFyZW50cyA9IGxpc3RTY3JvbGxQYXJlbnRzKGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xyXG4gICAgdmFyIGNhbkVzY2FwZUNsaXBwaW5nID0gWydhYnNvbHV0ZScsICdmaXhlZCddLmluZGV4T2YoZ2V0Q29tcHV0ZWRTdHlsZSQxKGVsZW1lbnQpLnBvc2l0aW9uKSA+PSAwO1xyXG4gICAgdmFyIGNsaXBwZXJFbGVtZW50ID0gY2FuRXNjYXBlQ2xpcHBpbmcgJiYgaXNIVE1MRWxlbWVudChlbGVtZW50KSA/IGdldE9mZnNldFBhcmVudChlbGVtZW50KSA6IGVsZW1lbnQ7XHJcblxyXG4gICAgaWYgKCFpc0VsZW1lbnQoY2xpcHBlckVsZW1lbnQpKSB7XHJcbiAgICAgIHJldHVybiBbXTtcclxuICAgIH0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL2Zsb3cvaXNzdWVzLzE0MTRcclxuXHJcblxyXG4gICAgcmV0dXJuIGNsaXBwaW5nUGFyZW50cy5maWx0ZXIoZnVuY3Rpb24gKGNsaXBwaW5nUGFyZW50KSB7XHJcbiAgICAgIHJldHVybiBpc0VsZW1lbnQoY2xpcHBpbmdQYXJlbnQpICYmIGNvbnRhaW5zKGNsaXBwaW5nUGFyZW50LCBjbGlwcGVyRWxlbWVudCkgJiYgZ2V0Tm9kZU5hbWUoY2xpcHBpbmdQYXJlbnQpICE9PSAnYm9keSc7XHJcbiAgICB9KTtcclxuICB9IC8vIEdldHMgdGhlIG1heGltdW0gYXJlYSB0aGF0IHRoZSBlbGVtZW50IGlzIHZpc2libGUgaW4gZHVlIHRvIGFueSBudW1iZXIgb2ZcclxuICAvLyBjbGlwcGluZyBwYXJlbnRzXHJcblxyXG5cclxuICBmdW5jdGlvbiBnZXRDbGlwcGluZ1JlY3QoZWxlbWVudCwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSwgc3RyYXRlZ3kpIHtcclxuICAgIHZhciBtYWluQ2xpcHBpbmdQYXJlbnRzID0gYm91bmRhcnkgPT09ICdjbGlwcGluZ1BhcmVudHMnID8gZ2V0Q2xpcHBpbmdQYXJlbnRzKGVsZW1lbnQpIDogW10uY29uY2F0KGJvdW5kYXJ5KTtcclxuICAgIHZhciBjbGlwcGluZ1BhcmVudHMgPSBbXS5jb25jYXQobWFpbkNsaXBwaW5nUGFyZW50cywgW3Jvb3RCb3VuZGFyeV0pO1xyXG4gICAgdmFyIGZpcnN0Q2xpcHBpbmdQYXJlbnQgPSBjbGlwcGluZ1BhcmVudHNbMF07XHJcbiAgICB2YXIgY2xpcHBpbmdSZWN0ID0gY2xpcHBpbmdQYXJlbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjUmVjdCwgY2xpcHBpbmdQYXJlbnQpIHtcclxuICAgICAgdmFyIHJlY3QgPSBnZXRDbGllbnRSZWN0RnJvbU1peGVkVHlwZShlbGVtZW50LCBjbGlwcGluZ1BhcmVudCwgc3RyYXRlZ3kpO1xyXG4gICAgICBhY2NSZWN0LnRvcCA9IG1heChyZWN0LnRvcCwgYWNjUmVjdC50b3ApO1xyXG4gICAgICBhY2NSZWN0LnJpZ2h0ID0gbWluKHJlY3QucmlnaHQsIGFjY1JlY3QucmlnaHQpO1xyXG4gICAgICBhY2NSZWN0LmJvdHRvbSA9IG1pbihyZWN0LmJvdHRvbSwgYWNjUmVjdC5ib3R0b20pO1xyXG4gICAgICBhY2NSZWN0LmxlZnQgPSBtYXgocmVjdC5sZWZ0LCBhY2NSZWN0LmxlZnQpO1xyXG4gICAgICByZXR1cm4gYWNjUmVjdDtcclxuICAgIH0sIGdldENsaWVudFJlY3RGcm9tTWl4ZWRUeXBlKGVsZW1lbnQsIGZpcnN0Q2xpcHBpbmdQYXJlbnQsIHN0cmF0ZWd5KSk7XHJcbiAgICBjbGlwcGluZ1JlY3Qud2lkdGggPSBjbGlwcGluZ1JlY3QucmlnaHQgLSBjbGlwcGluZ1JlY3QubGVmdDtcclxuICAgIGNsaXBwaW5nUmVjdC5oZWlnaHQgPSBjbGlwcGluZ1JlY3QuYm90dG9tIC0gY2xpcHBpbmdSZWN0LnRvcDtcclxuICAgIGNsaXBwaW5nUmVjdC54ID0gY2xpcHBpbmdSZWN0LmxlZnQ7XHJcbiAgICBjbGlwcGluZ1JlY3QueSA9IGNsaXBwaW5nUmVjdC50b3A7XHJcbiAgICByZXR1cm4gY2xpcHBpbmdSZWN0O1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gY29tcHV0ZU9mZnNldHMoX3JlZikge1xyXG4gICAgdmFyIHJlZmVyZW5jZSA9IF9yZWYucmVmZXJlbmNlLFxyXG4gICAgICAgIGVsZW1lbnQgPSBfcmVmLmVsZW1lbnQsXHJcbiAgICAgICAgcGxhY2VtZW50ID0gX3JlZi5wbGFjZW1lbnQ7XHJcbiAgICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudCA/IGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA6IG51bGw7XHJcbiAgICB2YXIgdmFyaWF0aW9uID0gcGxhY2VtZW50ID8gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgOiBudWxsO1xyXG4gICAgdmFyIGNvbW1vblggPSByZWZlcmVuY2UueCArIHJlZmVyZW5jZS53aWR0aCAvIDIgLSBlbGVtZW50LndpZHRoIC8gMjtcclxuICAgIHZhciBjb21tb25ZID0gcmVmZXJlbmNlLnkgKyByZWZlcmVuY2UuaGVpZ2h0IC8gMiAtIGVsZW1lbnQuaGVpZ2h0IC8gMjtcclxuICAgIHZhciBvZmZzZXRzO1xyXG5cclxuICAgIHN3aXRjaCAoYmFzZVBsYWNlbWVudCkge1xyXG4gICAgICBjYXNlIHRvcDpcclxuICAgICAgICBvZmZzZXRzID0ge1xyXG4gICAgICAgICAgeDogY29tbW9uWCxcclxuICAgICAgICAgIHk6IHJlZmVyZW5jZS55IC0gZWxlbWVudC5oZWlnaHRcclxuICAgICAgICB9O1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSBib3R0b206XHJcbiAgICAgICAgb2Zmc2V0cyA9IHtcclxuICAgICAgICAgIHg6IGNvbW1vblgsXHJcbiAgICAgICAgICB5OiByZWZlcmVuY2UueSArIHJlZmVyZW5jZS5oZWlnaHRcclxuICAgICAgICB9O1xyXG4gICAgICAgIGJyZWFrO1xyXG5cclxuICAgICAgY2FzZSByaWdodDpcclxuICAgICAgICBvZmZzZXRzID0ge1xyXG4gICAgICAgICAgeDogcmVmZXJlbmNlLnggKyByZWZlcmVuY2Uud2lkdGgsXHJcbiAgICAgICAgICB5OiBjb21tb25ZXHJcbiAgICAgICAgfTtcclxuICAgICAgICBicmVhaztcclxuXHJcbiAgICAgIGNhc2UgbGVmdDpcclxuICAgICAgICBvZmZzZXRzID0ge1xyXG4gICAgICAgICAgeDogcmVmZXJlbmNlLnggLSBlbGVtZW50LndpZHRoLFxyXG4gICAgICAgICAgeTogY29tbW9uWVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgYnJlYWs7XHJcblxyXG4gICAgICBkZWZhdWx0OlxyXG4gICAgICAgIG9mZnNldHMgPSB7XHJcbiAgICAgICAgICB4OiByZWZlcmVuY2UueCxcclxuICAgICAgICAgIHk6IHJlZmVyZW5jZS55XHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgbWFpbkF4aXMgPSBiYXNlUGxhY2VtZW50ID8gZ2V0TWFpbkF4aXNGcm9tUGxhY2VtZW50KGJhc2VQbGFjZW1lbnQpIDogbnVsbDtcclxuXHJcbiAgICBpZiAobWFpbkF4aXMgIT0gbnVsbCkge1xyXG4gICAgICB2YXIgbGVuID0gbWFpbkF4aXMgPT09ICd5JyA/ICdoZWlnaHQnIDogJ3dpZHRoJztcclxuXHJcbiAgICAgIHN3aXRjaCAodmFyaWF0aW9uKSB7XHJcbiAgICAgICAgY2FzZSBzdGFydDpcclxuICAgICAgICAgIG9mZnNldHNbbWFpbkF4aXNdID0gb2Zmc2V0c1ttYWluQXhpc10gLSAocmVmZXJlbmNlW2xlbl0gLyAyIC0gZWxlbWVudFtsZW5dIC8gMik7XHJcbiAgICAgICAgICBicmVhaztcclxuXHJcbiAgICAgICAgY2FzZSBlbmQ6XHJcbiAgICAgICAgICBvZmZzZXRzW21haW5BeGlzXSA9IG9mZnNldHNbbWFpbkF4aXNdICsgKHJlZmVyZW5jZVtsZW5dIC8gMiAtIGVsZW1lbnRbbGVuXSAvIDIpO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gb2Zmc2V0cztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGRldGVjdE92ZXJmbG93KHN0YXRlLCBvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxyXG4gICAgICAgIF9vcHRpb25zJHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcclxuICAgICAgICBwbGFjZW1lbnQgPSBfb3B0aW9ucyRwbGFjZW1lbnQgPT09IHZvaWQgMCA/IHN0YXRlLnBsYWNlbWVudCA6IF9vcHRpb25zJHBsYWNlbWVudCxcclxuICAgICAgICBfb3B0aW9ucyRzdHJhdGVneSA9IF9vcHRpb25zLnN0cmF0ZWd5LFxyXG4gICAgICAgIHN0cmF0ZWd5ID0gX29wdGlvbnMkc3RyYXRlZ3kgPT09IHZvaWQgMCA/IHN0YXRlLnN0cmF0ZWd5IDogX29wdGlvbnMkc3RyYXRlZ3ksXHJcbiAgICAgICAgX29wdGlvbnMkYm91bmRhcnkgPSBfb3B0aW9ucy5ib3VuZGFyeSxcclxuICAgICAgICBib3VuZGFyeSA9IF9vcHRpb25zJGJvdW5kYXJ5ID09PSB2b2lkIDAgPyBjbGlwcGluZ1BhcmVudHMgOiBfb3B0aW9ucyRib3VuZGFyeSxcclxuICAgICAgICBfb3B0aW9ucyRyb290Qm91bmRhcnkgPSBfb3B0aW9ucy5yb290Qm91bmRhcnksXHJcbiAgICAgICAgcm9vdEJvdW5kYXJ5ID0gX29wdGlvbnMkcm9vdEJvdW5kYXJ5ID09PSB2b2lkIDAgPyB2aWV3cG9ydCA6IF9vcHRpb25zJHJvb3RCb3VuZGFyeSxcclxuICAgICAgICBfb3B0aW9ucyRlbGVtZW50Q29udGUgPSBfb3B0aW9ucy5lbGVtZW50Q29udGV4dCxcclxuICAgICAgICBlbGVtZW50Q29udGV4dCA9IF9vcHRpb25zJGVsZW1lbnRDb250ZSA9PT0gdm9pZCAwID8gcG9wcGVyIDogX29wdGlvbnMkZWxlbWVudENvbnRlLFxyXG4gICAgICAgIF9vcHRpb25zJGFsdEJvdW5kYXJ5ID0gX29wdGlvbnMuYWx0Qm91bmRhcnksXHJcbiAgICAgICAgYWx0Qm91bmRhcnkgPSBfb3B0aW9ucyRhbHRCb3VuZGFyeSA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRCb3VuZGFyeSxcclxuICAgICAgICBfb3B0aW9ucyRwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcclxuICAgICAgICBwYWRkaW5nID0gX29wdGlvbnMkcGFkZGluZyA9PT0gdm9pZCAwID8gMCA6IF9vcHRpb25zJHBhZGRpbmc7XHJcbiAgICB2YXIgcGFkZGluZ09iamVjdCA9IG1lcmdlUGFkZGluZ09iamVjdCh0eXBlb2YgcGFkZGluZyAhPT0gJ251bWJlcicgPyBwYWRkaW5nIDogZXhwYW5kVG9IYXNoTWFwKHBhZGRpbmcsIGJhc2VQbGFjZW1lbnRzKSk7XHJcbiAgICB2YXIgYWx0Q29udGV4dCA9IGVsZW1lbnRDb250ZXh0ID09PSBwb3BwZXIgPyByZWZlcmVuY2UgOiBwb3BwZXI7XHJcbiAgICB2YXIgcG9wcGVyUmVjdCA9IHN0YXRlLnJlY3RzLnBvcHBlcjtcclxuICAgIHZhciBlbGVtZW50ID0gc3RhdGUuZWxlbWVudHNbYWx0Qm91bmRhcnkgPyBhbHRDb250ZXh0IDogZWxlbWVudENvbnRleHRdO1xyXG4gICAgdmFyIGNsaXBwaW5nQ2xpZW50UmVjdCA9IGdldENsaXBwaW5nUmVjdChpc0VsZW1lbnQoZWxlbWVudCkgPyBlbGVtZW50IDogZWxlbWVudC5jb250ZXh0RWxlbWVudCB8fCBnZXREb2N1bWVudEVsZW1lbnQoc3RhdGUuZWxlbWVudHMucG9wcGVyKSwgYm91bmRhcnksIHJvb3RCb3VuZGFyeSwgc3RyYXRlZ3kpO1xyXG4gICAgdmFyIHJlZmVyZW5jZUNsaWVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qoc3RhdGUuZWxlbWVudHMucmVmZXJlbmNlKTtcclxuICAgIHZhciBwb3BwZXJPZmZzZXRzID0gY29tcHV0ZU9mZnNldHMoe1xyXG4gICAgICByZWZlcmVuY2U6IHJlZmVyZW5jZUNsaWVudFJlY3QsXHJcbiAgICAgIGVsZW1lbnQ6IHBvcHBlclJlY3QsXHJcbiAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50XHJcbiAgICB9KTtcclxuICAgIHZhciBwb3BwZXJDbGllbnRSZWN0ID0gcmVjdFRvQ2xpZW50UmVjdChPYmplY3QuYXNzaWduKHt9LCBwb3BwZXJSZWN0LCBwb3BwZXJPZmZzZXRzKSk7XHJcbiAgICB2YXIgZWxlbWVudENsaWVudFJlY3QgPSBlbGVtZW50Q29udGV4dCA9PT0gcG9wcGVyID8gcG9wcGVyQ2xpZW50UmVjdCA6IHJlZmVyZW5jZUNsaWVudFJlY3Q7IC8vIHBvc2l0aXZlID0gb3ZlcmZsb3dpbmcgdGhlIGNsaXBwaW5nIHJlY3RcclxuICAgIC8vIDAgb3IgbmVnYXRpdmUgPSB3aXRoaW4gdGhlIGNsaXBwaW5nIHJlY3RcclxuXHJcbiAgICB2YXIgb3ZlcmZsb3dPZmZzZXRzID0ge1xyXG4gICAgICB0b3A6IGNsaXBwaW5nQ2xpZW50UmVjdC50b3AgLSBlbGVtZW50Q2xpZW50UmVjdC50b3AgKyBwYWRkaW5nT2JqZWN0LnRvcCxcclxuICAgICAgYm90dG9tOiBlbGVtZW50Q2xpZW50UmVjdC5ib3R0b20gLSBjbGlwcGluZ0NsaWVudFJlY3QuYm90dG9tICsgcGFkZGluZ09iamVjdC5ib3R0b20sXHJcbiAgICAgIGxlZnQ6IGNsaXBwaW5nQ2xpZW50UmVjdC5sZWZ0IC0gZWxlbWVudENsaWVudFJlY3QubGVmdCArIHBhZGRpbmdPYmplY3QubGVmdCxcclxuICAgICAgcmlnaHQ6IGVsZW1lbnRDbGllbnRSZWN0LnJpZ2h0IC0gY2xpcHBpbmdDbGllbnRSZWN0LnJpZ2h0ICsgcGFkZGluZ09iamVjdC5yaWdodFxyXG4gICAgfTtcclxuICAgIHZhciBvZmZzZXREYXRhID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQ7IC8vIE9mZnNldHMgY2FuIGJlIGFwcGxpZWQgb25seSB0byB0aGUgcG9wcGVyIGVsZW1lbnRcclxuXHJcbiAgICBpZiAoZWxlbWVudENvbnRleHQgPT09IHBvcHBlciAmJiBvZmZzZXREYXRhKSB7XHJcbiAgICAgIHZhciBvZmZzZXQgPSBvZmZzZXREYXRhW3BsYWNlbWVudF07XHJcbiAgICAgIE9iamVjdC5rZXlzKG92ZXJmbG93T2Zmc2V0cykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XHJcbiAgICAgICAgdmFyIG11bHRpcGx5ID0gW3JpZ2h0LCBib3R0b21dLmluZGV4T2Yoa2V5KSA+PSAwID8gMSA6IC0xO1xyXG4gICAgICAgIHZhciBheGlzID0gW3RvcCwgYm90dG9tXS5pbmRleE9mKGtleSkgPj0gMCA/ICd5JyA6ICd4JztcclxuICAgICAgICBvdmVyZmxvd09mZnNldHNba2V5XSArPSBvZmZzZXRbYXhpc10gKiBtdWx0aXBseTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG92ZXJmbG93T2Zmc2V0cztcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCBvcHRpb25zKSB7XHJcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIG9wdGlvbnMgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgX29wdGlvbnMgPSBvcHRpb25zLFxyXG4gICAgICAgIHBsYWNlbWVudCA9IF9vcHRpb25zLnBsYWNlbWVudCxcclxuICAgICAgICBib3VuZGFyeSA9IF9vcHRpb25zLmJvdW5kYXJ5LFxyXG4gICAgICAgIHJvb3RCb3VuZGFyeSA9IF9vcHRpb25zLnJvb3RCb3VuZGFyeSxcclxuICAgICAgICBwYWRkaW5nID0gX29wdGlvbnMucGFkZGluZyxcclxuICAgICAgICBmbGlwVmFyaWF0aW9ucyA9IF9vcHRpb25zLmZsaXBWYXJpYXRpb25zLFxyXG4gICAgICAgIF9vcHRpb25zJGFsbG93ZWRBdXRvUCA9IF9vcHRpb25zLmFsbG93ZWRBdXRvUGxhY2VtZW50cyxcclxuICAgICAgICBhbGxvd2VkQXV0b1BsYWNlbWVudHMgPSBfb3B0aW9ucyRhbGxvd2VkQXV0b1AgPT09IHZvaWQgMCA/IHBsYWNlbWVudHMgOiBfb3B0aW9ucyRhbGxvd2VkQXV0b1A7XHJcbiAgICB2YXIgdmFyaWF0aW9uID0gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCk7XHJcbiAgICB2YXIgcGxhY2VtZW50cyQxID0gdmFyaWF0aW9uID8gZmxpcFZhcmlhdGlvbnMgPyB2YXJpYXRpb25QbGFjZW1lbnRzIDogdmFyaWF0aW9uUGxhY2VtZW50cy5maWx0ZXIoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xyXG4gICAgICByZXR1cm4gZ2V0VmFyaWF0aW9uKHBsYWNlbWVudCkgPT09IHZhcmlhdGlvbjtcclxuICAgIH0pIDogYmFzZVBsYWNlbWVudHM7XHJcbiAgICB2YXIgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzJDEuZmlsdGVyKGZ1bmN0aW9uIChwbGFjZW1lbnQpIHtcclxuICAgICAgcmV0dXJuIGFsbG93ZWRBdXRvUGxhY2VtZW50cy5pbmRleE9mKHBsYWNlbWVudCkgPj0gMDtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmIChhbGxvd2VkUGxhY2VtZW50cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgYWxsb3dlZFBsYWNlbWVudHMgPSBwbGFjZW1lbnRzJDE7XHJcbiAgICB9IC8vICRGbG93Rml4TWVbaW5jb21wYXRpYmxlLXR5cGVdOiBGbG93IHNlZW1zIHRvIGhhdmUgcHJvYmxlbXMgd2l0aCB0d28gYXJyYXkgdW5pb25zLi4uXHJcblxyXG5cclxuICAgIHZhciBvdmVyZmxvd3MgPSBhbGxvd2VkUGxhY2VtZW50cy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XHJcbiAgICAgIGFjY1twbGFjZW1lbnRdID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcclxuICAgICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudCxcclxuICAgICAgICBib3VuZGFyeTogYm91bmRhcnksXHJcbiAgICAgICAgcm9vdEJvdW5kYXJ5OiByb290Qm91bmRhcnksXHJcbiAgICAgICAgcGFkZGluZzogcGFkZGluZ1xyXG4gICAgICB9KVtnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCldO1xyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwge30pO1xyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG92ZXJmbG93cykuc29ydChmdW5jdGlvbiAoYSwgYikge1xyXG4gICAgICByZXR1cm4gb3ZlcmZsb3dzW2FdIC0gb3ZlcmZsb3dzW2JdO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXRFeHBhbmRlZEZhbGxiYWNrUGxhY2VtZW50cyhwbGFjZW1lbnQpIHtcclxuICAgIGlmIChnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCkgPT09IGF1dG8pIHtcclxuICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHZhciBvcHBvc2l0ZVBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XHJcbiAgICByZXR1cm4gW2dldE9wcG9zaXRlVmFyaWF0aW9uUGxhY2VtZW50KHBsYWNlbWVudCksIG9wcG9zaXRlUGxhY2VtZW50LCBnZXRPcHBvc2l0ZVZhcmlhdGlvblBsYWNlbWVudChvcHBvc2l0ZVBsYWNlbWVudCldO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZmxpcChfcmVmKSB7XHJcbiAgICB2YXIgc3RhdGUgPSBfcmVmLnN0YXRlLFxyXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXHJcbiAgICAgICAgbmFtZSA9IF9yZWYubmFtZTtcclxuXHJcbiAgICBpZiAoc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIF9vcHRpb25zJG1haW5BeGlzID0gb3B0aW9ucy5tYWluQXhpcyxcclxuICAgICAgICBjaGVja01haW5BeGlzID0gX29wdGlvbnMkbWFpbkF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRtYWluQXhpcyxcclxuICAgICAgICBfb3B0aW9ucyRhbHRBeGlzID0gb3B0aW9ucy5hbHRBeGlzLFxyXG4gICAgICAgIGNoZWNrQWx0QXhpcyA9IF9vcHRpb25zJGFsdEF4aXMgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyRhbHRBeGlzLFxyXG4gICAgICAgIHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyA9IG9wdGlvbnMuZmFsbGJhY2tQbGFjZW1lbnRzLFxyXG4gICAgICAgIHBhZGRpbmcgPSBvcHRpb25zLnBhZGRpbmcsXHJcbiAgICAgICAgYm91bmRhcnkgPSBvcHRpb25zLmJvdW5kYXJ5LFxyXG4gICAgICAgIHJvb3RCb3VuZGFyeSA9IG9wdGlvbnMucm9vdEJvdW5kYXJ5LFxyXG4gICAgICAgIGFsdEJvdW5kYXJ5ID0gb3B0aW9ucy5hbHRCb3VuZGFyeSxcclxuICAgICAgICBfb3B0aW9ucyRmbGlwVmFyaWF0aW8gPSBvcHRpb25zLmZsaXBWYXJpYXRpb25zLFxyXG4gICAgICAgIGZsaXBWYXJpYXRpb25zID0gX29wdGlvbnMkZmxpcFZhcmlhdGlvID09PSB2b2lkIDAgPyB0cnVlIDogX29wdGlvbnMkZmxpcFZhcmlhdGlvLFxyXG4gICAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50cyA9IG9wdGlvbnMuYWxsb3dlZEF1dG9QbGFjZW1lbnRzO1xyXG4gICAgdmFyIHByZWZlcnJlZFBsYWNlbWVudCA9IHN0YXRlLm9wdGlvbnMucGxhY2VtZW50O1xyXG4gICAgdmFyIGJhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHByZWZlcnJlZFBsYWNlbWVudCk7XHJcbiAgICB2YXIgaXNCYXNlUGxhY2VtZW50ID0gYmFzZVBsYWNlbWVudCA9PT0gcHJlZmVycmVkUGxhY2VtZW50O1xyXG4gICAgdmFyIGZhbGxiYWNrUGxhY2VtZW50cyA9IHNwZWNpZmllZEZhbGxiYWNrUGxhY2VtZW50cyB8fCAoaXNCYXNlUGxhY2VtZW50IHx8ICFmbGlwVmFyaWF0aW9ucyA/IFtnZXRPcHBvc2l0ZVBsYWNlbWVudChwcmVmZXJyZWRQbGFjZW1lbnQpXSA6IGdldEV4cGFuZGVkRmFsbGJhY2tQbGFjZW1lbnRzKHByZWZlcnJlZFBsYWNlbWVudCkpO1xyXG4gICAgdmFyIHBsYWNlbWVudHMgPSBbcHJlZmVycmVkUGxhY2VtZW50XS5jb25jYXQoZmFsbGJhY2tQbGFjZW1lbnRzKS5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGxhY2VtZW50KSB7XHJcbiAgICAgIHJldHVybiBhY2MuY29uY2F0KGdldEJhc2VQbGFjZW1lbnQocGxhY2VtZW50KSA9PT0gYXV0byA/IGNvbXB1dGVBdXRvUGxhY2VtZW50KHN0YXRlLCB7XHJcbiAgICAgICAgcGxhY2VtZW50OiBwbGFjZW1lbnQsXHJcbiAgICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxyXG4gICAgICAgIHJvb3RCb3VuZGFyeTogcm9vdEJvdW5kYXJ5LFxyXG4gICAgICAgIHBhZGRpbmc6IHBhZGRpbmcsXHJcbiAgICAgICAgZmxpcFZhcmlhdGlvbnM6IGZsaXBWYXJpYXRpb25zLFxyXG4gICAgICAgIGFsbG93ZWRBdXRvUGxhY2VtZW50czogYWxsb3dlZEF1dG9QbGFjZW1lbnRzXHJcbiAgICAgIH0pIDogcGxhY2VtZW50KTtcclxuICAgIH0sIFtdKTtcclxuICAgIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xyXG4gICAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XHJcbiAgICB2YXIgY2hlY2tzTWFwID0gbmV3IE1hcCgpO1xyXG4gICAgdmFyIG1ha2VGYWxsYmFja0NoZWNrcyA9IHRydWU7XHJcbiAgICB2YXIgZmlyc3RGaXR0aW5nUGxhY2VtZW50ID0gcGxhY2VtZW50c1swXTtcclxuXHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWNlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgdmFyIHBsYWNlbWVudCA9IHBsYWNlbWVudHNbaV07XHJcblxyXG4gICAgICB2YXIgX2Jhc2VQbGFjZW1lbnQgPSBnZXRCYXNlUGxhY2VtZW50KHBsYWNlbWVudCk7XHJcblxyXG4gICAgICB2YXIgaXNTdGFydFZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihwbGFjZW1lbnQpID09PSBzdGFydDtcclxuICAgICAgdmFyIGlzVmVydGljYWwgPSBbdG9wLCBib3R0b21dLmluZGV4T2YoX2Jhc2VQbGFjZW1lbnQpID49IDA7XHJcbiAgICAgIHZhciBsZW4gPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xyXG4gICAgICB2YXIgb3ZlcmZsb3cgPSBkZXRlY3RPdmVyZmxvdyhzdGF0ZSwge1xyXG4gICAgICAgIHBsYWNlbWVudDogcGxhY2VtZW50LFxyXG4gICAgICAgIGJvdW5kYXJ5OiBib3VuZGFyeSxcclxuICAgICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcclxuICAgICAgICBhbHRCb3VuZGFyeTogYWx0Qm91bmRhcnksXHJcbiAgICAgICAgcGFkZGluZzogcGFkZGluZ1xyXG4gICAgICB9KTtcclxuICAgICAgdmFyIG1haW5WYXJpYXRpb25TaWRlID0gaXNWZXJ0aWNhbCA/IGlzU3RhcnRWYXJpYXRpb24gPyByaWdodCA6IGxlZnQgOiBpc1N0YXJ0VmFyaWF0aW9uID8gYm90dG9tIDogdG9wO1xyXG5cclxuICAgICAgaWYgKHJlZmVyZW5jZVJlY3RbbGVuXSA+IHBvcHBlclJlY3RbbGVuXSkge1xyXG4gICAgICAgIG1haW5WYXJpYXRpb25TaWRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQobWFpblZhcmlhdGlvblNpZGUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB2YXIgYWx0VmFyaWF0aW9uU2lkZSA9IGdldE9wcG9zaXRlUGxhY2VtZW50KG1haW5WYXJpYXRpb25TaWRlKTtcclxuICAgICAgdmFyIGNoZWNrcyA9IFtdO1xyXG5cclxuICAgICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcclxuICAgICAgICBjaGVja3MucHVzaChvdmVyZmxvd1tfYmFzZVBsYWNlbWVudF0gPD0gMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjaGVja0FsdEF4aXMpIHtcclxuICAgICAgICBjaGVja3MucHVzaChvdmVyZmxvd1ttYWluVmFyaWF0aW9uU2lkZV0gPD0gMCwgb3ZlcmZsb3dbYWx0VmFyaWF0aW9uU2lkZV0gPD0gMCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChjaGVja3MuZXZlcnkoZnVuY3Rpb24gKGNoZWNrKSB7XHJcbiAgICAgICAgcmV0dXJuIGNoZWNrO1xyXG4gICAgICB9KSkge1xyXG4gICAgICAgIGZpcnN0Rml0dGluZ1BsYWNlbWVudCA9IHBsYWNlbWVudDtcclxuICAgICAgICBtYWtlRmFsbGJhY2tDaGVja3MgPSBmYWxzZTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgY2hlY2tzTWFwLnNldChwbGFjZW1lbnQsIGNoZWNrcyk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKG1ha2VGYWxsYmFja0NoZWNrcykge1xyXG4gICAgICAvLyBgMmAgbWF5IGJlIGRlc2lyZWQgaW4gc29tZSBjYXNlcyDigJMgcmVzZWFyY2ggbGF0ZXJcclxuICAgICAgdmFyIG51bWJlck9mQ2hlY2tzID0gZmxpcFZhcmlhdGlvbnMgPyAzIDogMTtcclxuXHJcbiAgICAgIHZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKF9pKSB7XHJcbiAgICAgICAgdmFyIGZpdHRpbmdQbGFjZW1lbnQgPSBwbGFjZW1lbnRzLmZpbmQoZnVuY3Rpb24gKHBsYWNlbWVudCkge1xyXG4gICAgICAgICAgdmFyIGNoZWNrcyA9IGNoZWNrc01hcC5nZXQocGxhY2VtZW50KTtcclxuXHJcbiAgICAgICAgICBpZiAoY2hlY2tzKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjaGVja3Muc2xpY2UoMCwgX2kpLmV2ZXJ5KGZ1bmN0aW9uIChjaGVjaykge1xyXG4gICAgICAgICAgICAgIHJldHVybiBjaGVjaztcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGlmIChmaXR0aW5nUGxhY2VtZW50KSB7XHJcbiAgICAgICAgICBmaXJzdEZpdHRpbmdQbGFjZW1lbnQgPSBmaXR0aW5nUGxhY2VtZW50O1xyXG4gICAgICAgICAgcmV0dXJuIFwiYnJlYWtcIjtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcblxyXG4gICAgICBmb3IgKHZhciBfaSA9IG51bWJlck9mQ2hlY2tzOyBfaSA+IDA7IF9pLS0pIHtcclxuICAgICAgICB2YXIgX3JldCA9IF9sb29wKF9pKTtcclxuXHJcbiAgICAgICAgaWYgKF9yZXQgPT09IFwiYnJlYWtcIikgYnJlYWs7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RhdGUucGxhY2VtZW50ICE9PSBmaXJzdEZpdHRpbmdQbGFjZW1lbnQpIHtcclxuICAgICAgc3RhdGUubW9kaWZpZXJzRGF0YVtuYW1lXS5fc2tpcCA9IHRydWU7XHJcbiAgICAgIHN0YXRlLnBsYWNlbWVudCA9IGZpcnN0Rml0dGluZ1BsYWNlbWVudDtcclxuICAgICAgc3RhdGUucmVzZXQgPSB0cnVlO1xyXG4gICAgfVxyXG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xyXG5cclxuXHJcbiAgY29uc3QgZmxpcCQxID0ge1xyXG4gICAgbmFtZTogJ2ZsaXAnLFxyXG4gICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgIHBoYXNlOiAnbWFpbicsXHJcbiAgICBmbjogZmxpcCxcclxuICAgIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J10sXHJcbiAgICBkYXRhOiB7XHJcbiAgICAgIF9za2lwOiBmYWxzZVxyXG4gICAgfVxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGdldFNpZGVPZmZzZXRzKG92ZXJmbG93LCByZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKSB7XHJcbiAgICBpZiAocHJldmVudGVkT2Zmc2V0cyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIHByZXZlbnRlZE9mZnNldHMgPSB7XHJcbiAgICAgICAgeDogMCxcclxuICAgICAgICB5OiAwXHJcbiAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgdG9wOiBvdmVyZmxvdy50b3AgLSByZWN0LmhlaWdodCAtIHByZXZlbnRlZE9mZnNldHMueSxcclxuICAgICAgcmlnaHQ6IG92ZXJmbG93LnJpZ2h0IC0gcmVjdC53aWR0aCArIHByZXZlbnRlZE9mZnNldHMueCxcclxuICAgICAgYm90dG9tOiBvdmVyZmxvdy5ib3R0b20gLSByZWN0LmhlaWdodCArIHByZXZlbnRlZE9mZnNldHMueSxcclxuICAgICAgbGVmdDogb3ZlcmZsb3cubGVmdCAtIHJlY3Qud2lkdGggLSBwcmV2ZW50ZWRPZmZzZXRzLnhcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBpc0FueVNpZGVGdWxseUNsaXBwZWQob3ZlcmZsb3cpIHtcclxuICAgIHJldHVybiBbdG9wLCByaWdodCwgYm90dG9tLCBsZWZ0XS5zb21lKGZ1bmN0aW9uIChzaWRlKSB7XHJcbiAgICAgIHJldHVybiBvdmVyZmxvd1tzaWRlXSA+PSAwO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBoaWRlKF9yZWYpIHtcclxuICAgIHZhciBzdGF0ZSA9IF9yZWYuc3RhdGUsXHJcbiAgICAgICAgbmFtZSA9IF9yZWYubmFtZTtcclxuICAgIHZhciByZWZlcmVuY2VSZWN0ID0gc3RhdGUucmVjdHMucmVmZXJlbmNlO1xyXG4gICAgdmFyIHBvcHBlclJlY3QgPSBzdGF0ZS5yZWN0cy5wb3BwZXI7XHJcbiAgICB2YXIgcHJldmVudGVkT2Zmc2V0cyA9IHN0YXRlLm1vZGlmaWVyc0RhdGEucHJldmVudE92ZXJmbG93O1xyXG4gICAgdmFyIHJlZmVyZW5jZU92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcclxuICAgICAgZWxlbWVudENvbnRleHQ6ICdyZWZlcmVuY2UnXHJcbiAgICB9KTtcclxuICAgIHZhciBwb3BwZXJBbHRPdmVyZmxvdyA9IGRldGVjdE92ZXJmbG93KHN0YXRlLCB7XHJcbiAgICAgIGFsdEJvdW5kYXJ5OiB0cnVlXHJcbiAgICB9KTtcclxuICAgIHZhciByZWZlcmVuY2VDbGlwcGluZ09mZnNldHMgPSBnZXRTaWRlT2Zmc2V0cyhyZWZlcmVuY2VPdmVyZmxvdywgcmVmZXJlbmNlUmVjdCk7XHJcbiAgICB2YXIgcG9wcGVyRXNjYXBlT2Zmc2V0cyA9IGdldFNpZGVPZmZzZXRzKHBvcHBlckFsdE92ZXJmbG93LCBwb3BwZXJSZWN0LCBwcmV2ZW50ZWRPZmZzZXRzKTtcclxuICAgIHZhciBpc1JlZmVyZW5jZUhpZGRlbiA9IGlzQW55U2lkZUZ1bGx5Q2xpcHBlZChyZWZlcmVuY2VDbGlwcGluZ09mZnNldHMpO1xyXG4gICAgdmFyIGhhc1BvcHBlckVzY2FwZWQgPSBpc0FueVNpZGVGdWxseUNsaXBwZWQocG9wcGVyRXNjYXBlT2Zmc2V0cyk7XHJcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0ge1xyXG4gICAgICByZWZlcmVuY2VDbGlwcGluZ09mZnNldHM6IHJlZmVyZW5jZUNsaXBwaW5nT2Zmc2V0cyxcclxuICAgICAgcG9wcGVyRXNjYXBlT2Zmc2V0czogcG9wcGVyRXNjYXBlT2Zmc2V0cyxcclxuICAgICAgaXNSZWZlcmVuY2VIaWRkZW46IGlzUmVmZXJlbmNlSGlkZGVuLFxyXG4gICAgICBoYXNQb3BwZXJFc2NhcGVkOiBoYXNQb3BwZXJFc2NhcGVkXHJcbiAgICB9O1xyXG4gICAgc3RhdGUuYXR0cmlidXRlcy5wb3BwZXIgPSBPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5hdHRyaWJ1dGVzLnBvcHBlciwge1xyXG4gICAgICAnZGF0YS1wb3BwZXItcmVmZXJlbmNlLWhpZGRlbic6IGlzUmVmZXJlbmNlSGlkZGVuLFxyXG4gICAgICAnZGF0YS1wb3BwZXItZXNjYXBlZCc6IGhhc1BvcHBlckVzY2FwZWRcclxuICAgIH0pO1xyXG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xyXG5cclxuXHJcbiAgY29uc3QgaGlkZSQxID0ge1xyXG4gICAgbmFtZTogJ2hpZGUnLFxyXG4gICAgZW5hYmxlZDogdHJ1ZSxcclxuICAgIHBoYXNlOiAnbWFpbicsXHJcbiAgICByZXF1aXJlc0lmRXhpc3RzOiBbJ3ByZXZlbnRPdmVyZmxvdyddLFxyXG4gICAgZm46IGhpZGVcclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHJlY3RzLCBvZmZzZXQpIHtcclxuICAgIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChwbGFjZW1lbnQpO1xyXG4gICAgdmFyIGludmVydERpc3RhbmNlID0gW2xlZnQsIHRvcF0uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA+PSAwID8gLTEgOiAxO1xyXG5cclxuICAgIHZhciBfcmVmID0gdHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IG9mZnNldChPYmplY3QuYXNzaWduKHt9LCByZWN0cywge1xyXG4gICAgICBwbGFjZW1lbnQ6IHBsYWNlbWVudFxyXG4gICAgfSkpIDogb2Zmc2V0LFxyXG4gICAgICAgIHNraWRkaW5nID0gX3JlZlswXSxcclxuICAgICAgICBkaXN0YW5jZSA9IF9yZWZbMV07XHJcblxyXG4gICAgc2tpZGRpbmcgPSBza2lkZGluZyB8fCAwO1xyXG4gICAgZGlzdGFuY2UgPSAoZGlzdGFuY2UgfHwgMCkgKiBpbnZlcnREaXN0YW5jZTtcclxuICAgIHJldHVybiBbbGVmdCwgcmlnaHRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgPj0gMCA/IHtcclxuICAgICAgeDogZGlzdGFuY2UsXHJcbiAgICAgIHk6IHNraWRkaW5nXHJcbiAgICB9IDoge1xyXG4gICAgICB4OiBza2lkZGluZyxcclxuICAgICAgeTogZGlzdGFuY2VcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvZmZzZXQoX3JlZjIpIHtcclxuICAgIHZhciBzdGF0ZSA9IF9yZWYyLnN0YXRlLFxyXG4gICAgICAgIG9wdGlvbnMgPSBfcmVmMi5vcHRpb25zLFxyXG4gICAgICAgIG5hbWUgPSBfcmVmMi5uYW1lO1xyXG4gICAgdmFyIF9vcHRpb25zJG9mZnNldCA9IG9wdGlvbnMub2Zmc2V0LFxyXG4gICAgICAgIG9mZnNldCA9IF9vcHRpb25zJG9mZnNldCA9PT0gdm9pZCAwID8gWzAsIDBdIDogX29wdGlvbnMkb2Zmc2V0O1xyXG4gICAgdmFyIGRhdGEgPSBwbGFjZW1lbnRzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBwbGFjZW1lbnQpIHtcclxuICAgICAgYWNjW3BsYWNlbWVudF0gPSBkaXN0YW5jZUFuZFNraWRkaW5nVG9YWShwbGFjZW1lbnQsIHN0YXRlLnJlY3RzLCBvZmZzZXQpO1xyXG4gICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwge30pO1xyXG4gICAgdmFyIF9kYXRhJHN0YXRlJHBsYWNlbWVudCA9IGRhdGFbc3RhdGUucGxhY2VtZW50XSxcclxuICAgICAgICB4ID0gX2RhdGEkc3RhdGUkcGxhY2VtZW50LngsXHJcbiAgICAgICAgeSA9IF9kYXRhJHN0YXRlJHBsYWNlbWVudC55O1xyXG5cclxuICAgIGlmIChzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMgIT0gbnVsbCkge1xyXG4gICAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueCArPSB4O1xyXG4gICAgICBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHMueSArPSB5O1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xyXG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xyXG5cclxuXHJcbiAgY29uc3Qgb2Zmc2V0JDEgPSB7XHJcbiAgICBuYW1lOiAnb2Zmc2V0JyxcclxuICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICBwaGFzZTogJ21haW4nLFxyXG4gICAgcmVxdWlyZXM6IFsncG9wcGVyT2Zmc2V0cyddLFxyXG4gICAgZm46IG9mZnNldFxyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIHBvcHBlck9mZnNldHMoX3JlZikge1xyXG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcclxuICAgICAgICBuYW1lID0gX3JlZi5uYW1lO1xyXG4gICAgLy8gT2Zmc2V0cyBhcmUgdGhlIGFjdHVhbCBwb3NpdGlvbiB0aGUgcG9wcGVyIG5lZWRzIHRvIGhhdmUgdG8gYmVcclxuICAgIC8vIHByb3Blcmx5IHBvc2l0aW9uZWQgbmVhciBpdHMgcmVmZXJlbmNlIGVsZW1lbnRcclxuICAgIC8vIFRoaXMgaXMgdGhlIG1vc3QgYmFzaWMgcGxhY2VtZW50LCBhbmQgd2lsbCBiZSBhZGp1c3RlZCBieVxyXG4gICAgLy8gdGhlIG1vZGlmaWVycyBpbiB0aGUgbmV4dCBzdGVwXHJcbiAgICBzdGF0ZS5tb2RpZmllcnNEYXRhW25hbWVdID0gY29tcHV0ZU9mZnNldHMoe1xyXG4gICAgICByZWZlcmVuY2U6IHN0YXRlLnJlY3RzLnJlZmVyZW5jZSxcclxuICAgICAgZWxlbWVudDogc3RhdGUucmVjdHMucG9wcGVyLFxyXG4gICAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxyXG4gICAgfSk7XHJcbiAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgaW1wb3J0L25vLXVudXNlZC1tb2R1bGVzXHJcblxyXG5cclxuICBjb25zdCBwb3BwZXJPZmZzZXRzJDEgPSB7XHJcbiAgICBuYW1lOiAncG9wcGVyT2Zmc2V0cycsXHJcbiAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgcGhhc2U6ICdyZWFkJyxcclxuICAgIGZuOiBwb3BwZXJPZmZzZXRzLFxyXG4gICAgZGF0YToge31cclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBnZXRBbHRBeGlzKGF4aXMpIHtcclxuICAgIHJldHVybiBheGlzID09PSAneCcgPyAneScgOiAneCc7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBwcmV2ZW50T3ZlcmZsb3coX3JlZikge1xyXG4gICAgdmFyIHN0YXRlID0gX3JlZi5zdGF0ZSxcclxuICAgICAgICBvcHRpb25zID0gX3JlZi5vcHRpb25zLFxyXG4gICAgICAgIG5hbWUgPSBfcmVmLm5hbWU7XHJcbiAgICB2YXIgX29wdGlvbnMkbWFpbkF4aXMgPSBvcHRpb25zLm1haW5BeGlzLFxyXG4gICAgICAgIGNoZWNrTWFpbkF4aXMgPSBfb3B0aW9ucyRtYWluQXhpcyA9PT0gdm9pZCAwID8gdHJ1ZSA6IF9vcHRpb25zJG1haW5BeGlzLFxyXG4gICAgICAgIF9vcHRpb25zJGFsdEF4aXMgPSBvcHRpb25zLmFsdEF4aXMsXHJcbiAgICAgICAgY2hlY2tBbHRBeGlzID0gX29wdGlvbnMkYWx0QXhpcyA9PT0gdm9pZCAwID8gZmFsc2UgOiBfb3B0aW9ucyRhbHRBeGlzLFxyXG4gICAgICAgIGJvdW5kYXJ5ID0gb3B0aW9ucy5ib3VuZGFyeSxcclxuICAgICAgICByb290Qm91bmRhcnkgPSBvcHRpb25zLnJvb3RCb3VuZGFyeSxcclxuICAgICAgICBhbHRCb3VuZGFyeSA9IG9wdGlvbnMuYWx0Qm91bmRhcnksXHJcbiAgICAgICAgcGFkZGluZyA9IG9wdGlvbnMucGFkZGluZyxcclxuICAgICAgICBfb3B0aW9ucyR0ZXRoZXIgPSBvcHRpb25zLnRldGhlcixcclxuICAgICAgICB0ZXRoZXIgPSBfb3B0aW9ucyR0ZXRoZXIgPT09IHZvaWQgMCA/IHRydWUgOiBfb3B0aW9ucyR0ZXRoZXIsXHJcbiAgICAgICAgX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID0gb3B0aW9ucy50ZXRoZXJPZmZzZXQsXHJcbiAgICAgICAgdGV0aGVyT2Zmc2V0ID0gX29wdGlvbnMkdGV0aGVyT2Zmc2V0ID09PSB2b2lkIDAgPyAwIDogX29wdGlvbnMkdGV0aGVyT2Zmc2V0O1xyXG4gICAgdmFyIG92ZXJmbG93ID0gZGV0ZWN0T3ZlcmZsb3coc3RhdGUsIHtcclxuICAgICAgYm91bmRhcnk6IGJvdW5kYXJ5LFxyXG4gICAgICByb290Qm91bmRhcnk6IHJvb3RCb3VuZGFyeSxcclxuICAgICAgcGFkZGluZzogcGFkZGluZyxcclxuICAgICAgYWx0Qm91bmRhcnk6IGFsdEJvdW5kYXJ5XHJcbiAgICB9KTtcclxuICAgIHZhciBiYXNlUGxhY2VtZW50ID0gZ2V0QmFzZVBsYWNlbWVudChzdGF0ZS5wbGFjZW1lbnQpO1xyXG4gICAgdmFyIHZhcmlhdGlvbiA9IGdldFZhcmlhdGlvbihzdGF0ZS5wbGFjZW1lbnQpO1xyXG4gICAgdmFyIGlzQmFzZVBsYWNlbWVudCA9ICF2YXJpYXRpb247XHJcbiAgICB2YXIgbWFpbkF4aXMgPSBnZXRNYWluQXhpc0Zyb21QbGFjZW1lbnQoYmFzZVBsYWNlbWVudCk7XHJcbiAgICB2YXIgYWx0QXhpcyA9IGdldEFsdEF4aXMobWFpbkF4aXMpO1xyXG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSBzdGF0ZS5tb2RpZmllcnNEYXRhLnBvcHBlck9mZnNldHM7XHJcbiAgICB2YXIgcmVmZXJlbmNlUmVjdCA9IHN0YXRlLnJlY3RzLnJlZmVyZW5jZTtcclxuICAgIHZhciBwb3BwZXJSZWN0ID0gc3RhdGUucmVjdHMucG9wcGVyO1xyXG4gICAgdmFyIHRldGhlck9mZnNldFZhbHVlID0gdHlwZW9mIHRldGhlck9mZnNldCA9PT0gJ2Z1bmN0aW9uJyA/IHRldGhlck9mZnNldChPYmplY3QuYXNzaWduKHt9LCBzdGF0ZS5yZWN0cywge1xyXG4gICAgICBwbGFjZW1lbnQ6IHN0YXRlLnBsYWNlbWVudFxyXG4gICAgfSkpIDogdGV0aGVyT2Zmc2V0O1xyXG4gICAgdmFyIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZSA9IHR5cGVvZiB0ZXRoZXJPZmZzZXRWYWx1ZSA9PT0gJ251bWJlcicgPyB7XHJcbiAgICAgIG1haW5BeGlzOiB0ZXRoZXJPZmZzZXRWYWx1ZSxcclxuICAgICAgYWx0QXhpczogdGV0aGVyT2Zmc2V0VmFsdWVcclxuICAgIH0gOiBPYmplY3QuYXNzaWduKHtcclxuICAgICAgbWFpbkF4aXM6IDAsXHJcbiAgICAgIGFsdEF4aXM6IDBcclxuICAgIH0sIHRldGhlck9mZnNldFZhbHVlKTtcclxuICAgIHZhciBvZmZzZXRNb2RpZmllclN0YXRlID0gc3RhdGUubW9kaWZpZXJzRGF0YS5vZmZzZXQgPyBzdGF0ZS5tb2RpZmllcnNEYXRhLm9mZnNldFtzdGF0ZS5wbGFjZW1lbnRdIDogbnVsbDtcclxuICAgIHZhciBkYXRhID0ge1xyXG4gICAgICB4OiAwLFxyXG4gICAgICB5OiAwXHJcbiAgICB9O1xyXG5cclxuICAgIGlmICghcG9wcGVyT2Zmc2V0cykge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNoZWNrTWFpbkF4aXMpIHtcclxuICAgICAgdmFyIF9vZmZzZXRNb2RpZmllclN0YXRlJDtcclxuXHJcbiAgICAgIHZhciBtYWluU2lkZSA9IG1haW5BeGlzID09PSAneScgPyB0b3AgOiBsZWZ0O1xyXG4gICAgICB2YXIgYWx0U2lkZSA9IG1haW5BeGlzID09PSAneScgPyBib3R0b20gOiByaWdodDtcclxuICAgICAgdmFyIGxlbiA9IG1haW5BeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XHJcbiAgICAgIHZhciBvZmZzZXQgPSBwb3BwZXJPZmZzZXRzW21haW5BeGlzXTtcclxuICAgICAgdmFyIG1pbiQxID0gb2Zmc2V0ICsgb3ZlcmZsb3dbbWFpblNpZGVdO1xyXG4gICAgICB2YXIgbWF4JDEgPSBvZmZzZXQgLSBvdmVyZmxvd1thbHRTaWRlXTtcclxuICAgICAgdmFyIGFkZGl0aXZlID0gdGV0aGVyID8gLXBvcHBlclJlY3RbbGVuXSAvIDIgOiAwO1xyXG4gICAgICB2YXIgbWluTGVuID0gdmFyaWF0aW9uID09PSBzdGFydCA/IHJlZmVyZW5jZVJlY3RbbGVuXSA6IHBvcHBlclJlY3RbbGVuXTtcclxuICAgICAgdmFyIG1heExlbiA9IHZhcmlhdGlvbiA9PT0gc3RhcnQgPyAtcG9wcGVyUmVjdFtsZW5dIDogLXJlZmVyZW5jZVJlY3RbbGVuXTsgLy8gV2UgbmVlZCB0byBpbmNsdWRlIHRoZSBhcnJvdyBpbiB0aGUgY2FsY3VsYXRpb24gc28gdGhlIGFycm93IGRvZXNuJ3QgZ29cclxuICAgICAgLy8gb3V0c2lkZSB0aGUgcmVmZXJlbmNlIGJvdW5kc1xyXG5cclxuICAgICAgdmFyIGFycm93RWxlbWVudCA9IHN0YXRlLmVsZW1lbnRzLmFycm93O1xyXG4gICAgICB2YXIgYXJyb3dSZWN0ID0gdGV0aGVyICYmIGFycm93RWxlbWVudCA/IGdldExheW91dFJlY3QoYXJyb3dFbGVtZW50KSA6IHtcclxuICAgICAgICB3aWR0aDogMCxcclxuICAgICAgICBoZWlnaHQ6IDBcclxuICAgICAgfTtcclxuICAgICAgdmFyIGFycm93UGFkZGluZ09iamVjdCA9IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXSA/IHN0YXRlLm1vZGlmaWVyc0RhdGFbJ2Fycm93I3BlcnNpc3RlbnQnXS5wYWRkaW5nIDogZ2V0RnJlc2hTaWRlT2JqZWN0KCk7XHJcbiAgICAgIHZhciBhcnJvd1BhZGRpbmdNaW4gPSBhcnJvd1BhZGRpbmdPYmplY3RbbWFpblNpZGVdO1xyXG4gICAgICB2YXIgYXJyb3dQYWRkaW5nTWF4ID0gYXJyb3dQYWRkaW5nT2JqZWN0W2FsdFNpZGVdOyAvLyBJZiB0aGUgcmVmZXJlbmNlIGxlbmd0aCBpcyBzbWFsbGVyIHRoYW4gdGhlIGFycm93IGxlbmd0aCwgd2UgZG9uJ3Qgd2FudFxyXG4gICAgICAvLyB0byBpbmNsdWRlIGl0cyBmdWxsIHNpemUgaW4gdGhlIGNhbGN1bGF0aW9uLiBJZiB0aGUgcmVmZXJlbmNlIGlzIHNtYWxsXHJcbiAgICAgIC8vIGFuZCBuZWFyIHRoZSBlZGdlIG9mIGEgYm91bmRhcnksIHRoZSBwb3BwZXIgY2FuIG92ZXJmbG93IGV2ZW4gaWYgdGhlXHJcbiAgICAgIC8vIHJlZmVyZW5jZSBpcyBub3Qgb3ZlcmZsb3dpbmcgYXMgd2VsbCAoZS5nLiB2aXJ0dWFsIGVsZW1lbnRzIHdpdGggbm9cclxuICAgICAgLy8gd2lkdGggb3IgaGVpZ2h0KVxyXG5cclxuICAgICAgdmFyIGFycm93TGVuID0gd2l0aGluKDAsIHJlZmVyZW5jZVJlY3RbbGVuXSwgYXJyb3dSZWN0W2xlbl0pO1xyXG4gICAgICB2YXIgbWluT2Zmc2V0ID0gaXNCYXNlUGxhY2VtZW50ID8gcmVmZXJlbmNlUmVjdFtsZW5dIC8gMiAtIGFkZGl0aXZlIC0gYXJyb3dMZW4gLSBhcnJvd1BhZGRpbmdNaW4gLSBub3JtYWxpemVkVGV0aGVyT2Zmc2V0VmFsdWUubWFpbkF4aXMgOiBtaW5MZW4gLSBhcnJvd0xlbiAtIGFycm93UGFkZGluZ01pbiAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcztcclxuICAgICAgdmFyIG1heE9mZnNldCA9IGlzQmFzZVBsYWNlbWVudCA/IC1yZWZlcmVuY2VSZWN0W2xlbl0gLyAyICsgYWRkaXRpdmUgKyBhcnJvd0xlbiArIGFycm93UGFkZGluZ01heCArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5tYWluQXhpcyA6IG1heExlbiArIGFycm93TGVuICsgYXJyb3dQYWRkaW5nTWF4ICsgbm9ybWFsaXplZFRldGhlck9mZnNldFZhbHVlLm1haW5BeGlzO1xyXG4gICAgICB2YXIgYXJyb3dPZmZzZXRQYXJlbnQgPSBzdGF0ZS5lbGVtZW50cy5hcnJvdyAmJiBnZXRPZmZzZXRQYXJlbnQoc3RhdGUuZWxlbWVudHMuYXJyb3cpO1xyXG4gICAgICB2YXIgY2xpZW50T2Zmc2V0ID0gYXJyb3dPZmZzZXRQYXJlbnQgPyBtYWluQXhpcyA9PT0gJ3knID8gYXJyb3dPZmZzZXRQYXJlbnQuY2xpZW50VG9wIHx8IDAgOiBhcnJvd09mZnNldFBhcmVudC5jbGllbnRMZWZ0IHx8IDAgOiAwO1xyXG4gICAgICB2YXIgb2Zmc2V0TW9kaWZpZXJWYWx1ZSA9IChfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW21haW5BeGlzXSkgIT0gbnVsbCA/IF9vZmZzZXRNb2RpZmllclN0YXRlJCA6IDA7XHJcbiAgICAgIHZhciB0ZXRoZXJNaW4gPSBvZmZzZXQgKyBtaW5PZmZzZXQgLSBvZmZzZXRNb2RpZmllclZhbHVlIC0gY2xpZW50T2Zmc2V0O1xyXG4gICAgICB2YXIgdGV0aGVyTWF4ID0gb2Zmc2V0ICsgbWF4T2Zmc2V0IC0gb2Zmc2V0TW9kaWZpZXJWYWx1ZTtcclxuICAgICAgdmFyIHByZXZlbnRlZE9mZnNldCA9IHdpdGhpbih0ZXRoZXIgPyBtaW4obWluJDEsIHRldGhlck1pbikgOiBtaW4kMSwgb2Zmc2V0LCB0ZXRoZXIgPyBtYXgobWF4JDEsIHRldGhlck1heCkgOiBtYXgkMSk7XHJcbiAgICAgIHBvcHBlck9mZnNldHNbbWFpbkF4aXNdID0gcHJldmVudGVkT2Zmc2V0O1xyXG4gICAgICBkYXRhW21haW5BeGlzXSA9IHByZXZlbnRlZE9mZnNldCAtIG9mZnNldDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2hlY2tBbHRBeGlzKSB7XHJcbiAgICAgIHZhciBfb2Zmc2V0TW9kaWZpZXJTdGF0ZSQyO1xyXG5cclxuICAgICAgdmFyIF9tYWluU2lkZSA9IG1haW5BeGlzID09PSAneCcgPyB0b3AgOiBsZWZ0O1xyXG5cclxuICAgICAgdmFyIF9hbHRTaWRlID0gbWFpbkF4aXMgPT09ICd4JyA/IGJvdHRvbSA6IHJpZ2h0O1xyXG5cclxuICAgICAgdmFyIF9vZmZzZXQgPSBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdO1xyXG5cclxuICAgICAgdmFyIF9sZW4gPSBhbHRBeGlzID09PSAneScgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XHJcblxyXG4gICAgICB2YXIgX21pbiA9IF9vZmZzZXQgKyBvdmVyZmxvd1tfbWFpblNpZGVdO1xyXG5cclxuICAgICAgdmFyIF9tYXggPSBfb2Zmc2V0IC0gb3ZlcmZsb3dbX2FsdFNpZGVdO1xyXG5cclxuICAgICAgdmFyIGlzT3JpZ2luU2lkZSA9IFt0b3AsIGxlZnRdLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xyXG5cclxuICAgICAgdmFyIF9vZmZzZXRNb2RpZmllclZhbHVlID0gKF9vZmZzZXRNb2RpZmllclN0YXRlJDIgPSBvZmZzZXRNb2RpZmllclN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBvZmZzZXRNb2RpZmllclN0YXRlW2FsdEF4aXNdKSAhPSBudWxsID8gX29mZnNldE1vZGlmaWVyU3RhdGUkMiA6IDA7XHJcblxyXG4gICAgICB2YXIgX3RldGhlck1pbiA9IGlzT3JpZ2luU2lkZSA/IF9taW4gOiBfb2Zmc2V0IC0gcmVmZXJlbmNlUmVjdFtfbGVuXSAtIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSArIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzO1xyXG5cclxuICAgICAgdmFyIF90ZXRoZXJNYXggPSBpc09yaWdpblNpZGUgPyBfb2Zmc2V0ICsgcmVmZXJlbmNlUmVjdFtfbGVuXSArIHBvcHBlclJlY3RbX2xlbl0gLSBfb2Zmc2V0TW9kaWZpZXJWYWx1ZSAtIG5vcm1hbGl6ZWRUZXRoZXJPZmZzZXRWYWx1ZS5hbHRBeGlzIDogX21heDtcclxuXHJcbiAgICAgIHZhciBfcHJldmVudGVkT2Zmc2V0ID0gdGV0aGVyICYmIGlzT3JpZ2luU2lkZSA/IHdpdGhpbk1heENsYW1wKF90ZXRoZXJNaW4sIF9vZmZzZXQsIF90ZXRoZXJNYXgpIDogd2l0aGluKHRldGhlciA/IF90ZXRoZXJNaW4gOiBfbWluLCBfb2Zmc2V0LCB0ZXRoZXIgPyBfdGV0aGVyTWF4IDogX21heCk7XHJcblxyXG4gICAgICBwb3BwZXJPZmZzZXRzW2FsdEF4aXNdID0gX3ByZXZlbnRlZE9mZnNldDtcclxuICAgICAgZGF0YVthbHRBeGlzXSA9IF9wcmV2ZW50ZWRPZmZzZXQgLSBfb2Zmc2V0O1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLm1vZGlmaWVyc0RhdGFbbmFtZV0gPSBkYXRhO1xyXG4gIH0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGltcG9ydC9uby11bnVzZWQtbW9kdWxlc1xyXG5cclxuXHJcbiAgY29uc3QgcHJldmVudE92ZXJmbG93JDEgPSB7XHJcbiAgICBuYW1lOiAncHJldmVudE92ZXJmbG93JyxcclxuICAgIGVuYWJsZWQ6IHRydWUsXHJcbiAgICBwaGFzZTogJ21haW4nLFxyXG4gICAgZm46IHByZXZlbnRPdmVyZmxvdyxcclxuICAgIHJlcXVpcmVzSWZFeGlzdHM6IFsnb2Zmc2V0J11cclxuICB9O1xyXG5cclxuICBmdW5jdGlvbiBnZXRIVE1MRWxlbWVudFNjcm9sbChlbGVtZW50KSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBzY3JvbGxMZWZ0OiBlbGVtZW50LnNjcm9sbExlZnQsXHJcbiAgICAgIHNjcm9sbFRvcDogZWxlbWVudC5zY3JvbGxUb3BcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBnZXROb2RlU2Nyb2xsKG5vZGUpIHtcclxuICAgIGlmIChub2RlID09PSBnZXRXaW5kb3cobm9kZSkgfHwgIWlzSFRNTEVsZW1lbnQobm9kZSkpIHtcclxuICAgICAgcmV0dXJuIGdldFdpbmRvd1Njcm9sbChub2RlKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBnZXRIVE1MRWxlbWVudFNjcm9sbChub2RlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIGlzRWxlbWVudFNjYWxlZChlbGVtZW50KSB7XHJcbiAgICB2YXIgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICB2YXIgc2NhbGVYID0gcm91bmQocmVjdC53aWR0aCkgLyBlbGVtZW50Lm9mZnNldFdpZHRoIHx8IDE7XHJcbiAgICB2YXIgc2NhbGVZID0gcm91bmQocmVjdC5oZWlnaHQpIC8gZWxlbWVudC5vZmZzZXRIZWlnaHQgfHwgMTtcclxuICAgIHJldHVybiBzY2FsZVggIT09IDEgfHwgc2NhbGVZICE9PSAxO1xyXG4gIH0gLy8gUmV0dXJucyB0aGUgY29tcG9zaXRlIHJlY3Qgb2YgYW4gZWxlbWVudCByZWxhdGl2ZSB0byBpdHMgb2Zmc2V0UGFyZW50LlxyXG4gIC8vIENvbXBvc2l0ZSBtZWFucyBpdCB0YWtlcyBpbnRvIGFjY291bnQgdHJhbnNmb3JtcyBhcyB3ZWxsIGFzIGxheW91dC5cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGdldENvbXBvc2l0ZVJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudCwgaXNGaXhlZCkge1xyXG4gICAgaWYgKGlzRml4ZWQgPT09IHZvaWQgMCkge1xyXG4gICAgICBpc0ZpeGVkID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGlzT2Zmc2V0UGFyZW50QW5FbGVtZW50ID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpO1xyXG4gICAgdmFyIG9mZnNldFBhcmVudElzU2NhbGVkID0gaXNIVE1MRWxlbWVudChvZmZzZXRQYXJlbnQpICYmIGlzRWxlbWVudFNjYWxlZChvZmZzZXRQYXJlbnQpO1xyXG4gICAgdmFyIGRvY3VtZW50RWxlbWVudCA9IGdldERvY3VtZW50RWxlbWVudChvZmZzZXRQYXJlbnQpO1xyXG4gICAgdmFyIHJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudE9yVmlydHVhbEVsZW1lbnQsIG9mZnNldFBhcmVudElzU2NhbGVkLCBpc0ZpeGVkKTtcclxuICAgIHZhciBzY3JvbGwgPSB7XHJcbiAgICAgIHNjcm9sbExlZnQ6IDAsXHJcbiAgICAgIHNjcm9sbFRvcDogMFxyXG4gICAgfTtcclxuICAgIHZhciBvZmZzZXRzID0ge1xyXG4gICAgICB4OiAwLFxyXG4gICAgICB5OiAwXHJcbiAgICB9O1xyXG5cclxuICAgIGlmIChpc09mZnNldFBhcmVudEFuRWxlbWVudCB8fCAhaXNPZmZzZXRQYXJlbnRBbkVsZW1lbnQgJiYgIWlzRml4ZWQpIHtcclxuICAgICAgaWYgKGdldE5vZGVOYW1lKG9mZnNldFBhcmVudCkgIT09ICdib2R5JyB8fCAvLyBodHRwczovL2dpdGh1Yi5jb20vcG9wcGVyanMvcG9wcGVyLWNvcmUvaXNzdWVzLzEwNzhcclxuICAgICAgaXNTY3JvbGxQYXJlbnQoZG9jdW1lbnRFbGVtZW50KSkge1xyXG4gICAgICAgIHNjcm9sbCA9IGdldE5vZGVTY3JvbGwob2Zmc2V0UGFyZW50KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGlzSFRNTEVsZW1lbnQob2Zmc2V0UGFyZW50KSkge1xyXG4gICAgICAgIG9mZnNldHMgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3Qob2Zmc2V0UGFyZW50LCB0cnVlKTtcclxuICAgICAgICBvZmZzZXRzLnggKz0gb2Zmc2V0UGFyZW50LmNsaWVudExlZnQ7XHJcbiAgICAgICAgb2Zmc2V0cy55ICs9IG9mZnNldFBhcmVudC5jbGllbnRUb3A7XHJcbiAgICAgIH0gZWxzZSBpZiAoZG9jdW1lbnRFbGVtZW50KSB7XHJcbiAgICAgICAgb2Zmc2V0cy54ID0gZ2V0V2luZG93U2Nyb2xsQmFyWChkb2N1bWVudEVsZW1lbnQpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgeDogcmVjdC5sZWZ0ICsgc2Nyb2xsLnNjcm9sbExlZnQgLSBvZmZzZXRzLngsXHJcbiAgICAgIHk6IHJlY3QudG9wICsgc2Nyb2xsLnNjcm9sbFRvcCAtIG9mZnNldHMueSxcclxuICAgICAgd2lkdGg6IHJlY3Qud2lkdGgsXHJcbiAgICAgIGhlaWdodDogcmVjdC5oZWlnaHRcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvcmRlcihtb2RpZmllcnMpIHtcclxuICAgIHZhciBtYXAgPSBuZXcgTWFwKCk7XHJcbiAgICB2YXIgdmlzaXRlZCA9IG5ldyBTZXQoKTtcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIG1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xyXG4gICAgICBtYXAuc2V0KG1vZGlmaWVyLm5hbWUsIG1vZGlmaWVyKTtcclxuICAgIH0pOyAvLyBPbiB2aXNpdGluZyBvYmplY3QsIGNoZWNrIGZvciBpdHMgZGVwZW5kZW5jaWVzIGFuZCB2aXNpdCB0aGVtIHJlY3Vyc2l2ZWx5XHJcblxyXG4gICAgZnVuY3Rpb24gc29ydChtb2RpZmllcikge1xyXG4gICAgICB2aXNpdGVkLmFkZChtb2RpZmllci5uYW1lKTtcclxuICAgICAgdmFyIHJlcXVpcmVzID0gW10uY29uY2F0KG1vZGlmaWVyLnJlcXVpcmVzIHx8IFtdLCBtb2RpZmllci5yZXF1aXJlc0lmRXhpc3RzIHx8IFtdKTtcclxuICAgICAgcmVxdWlyZXMuZm9yRWFjaChmdW5jdGlvbiAoZGVwKSB7XHJcbiAgICAgICAgaWYgKCF2aXNpdGVkLmhhcyhkZXApKSB7XHJcbiAgICAgICAgICB2YXIgZGVwTW9kaWZpZXIgPSBtYXAuZ2V0KGRlcCk7XHJcblxyXG4gICAgICAgICAgaWYgKGRlcE1vZGlmaWVyKSB7XHJcbiAgICAgICAgICAgIHNvcnQoZGVwTW9kaWZpZXIpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIHJlc3VsdC5wdXNoKG1vZGlmaWVyKTtcclxuICAgIH1cclxuXHJcbiAgICBtb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcclxuICAgICAgaWYgKCF2aXNpdGVkLmhhcyhtb2RpZmllci5uYW1lKSkge1xyXG4gICAgICAgIC8vIGNoZWNrIGZvciB2aXNpdGVkIG9iamVjdFxyXG4gICAgICAgIHNvcnQobW9kaWZpZXIpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBvcmRlck1vZGlmaWVycyhtb2RpZmllcnMpIHtcclxuICAgIC8vIG9yZGVyIGJhc2VkIG9uIGRlcGVuZGVuY2llc1xyXG4gICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlcihtb2RpZmllcnMpOyAvLyBvcmRlciBiYXNlZCBvbiBwaGFzZVxyXG5cclxuICAgIHJldHVybiBtb2RpZmllclBoYXNlcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgcGhhc2UpIHtcclxuICAgICAgcmV0dXJuIGFjYy5jb25jYXQob3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XHJcbiAgICAgICAgcmV0dXJuIG1vZGlmaWVyLnBoYXNlID09PSBwaGFzZTtcclxuICAgICAgfSkpO1xyXG4gICAgfSwgW10pO1xyXG4gIH1cclxuXHJcbiAgZnVuY3Rpb24gZGVib3VuY2UoZm4pIHtcclxuICAgIHZhciBwZW5kaW5nO1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgaWYgKCFwZW5kaW5nKSB7XHJcbiAgICAgICAgcGVuZGluZyA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XHJcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUoKS50aGVuKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcGVuZGluZyA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgcmVzb2x2ZShmbigpKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gcGVuZGluZztcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICBmdW5jdGlvbiBtZXJnZUJ5TmFtZShtb2RpZmllcnMpIHtcclxuICAgIHZhciBtZXJnZWQgPSBtb2RpZmllcnMucmVkdWNlKGZ1bmN0aW9uIChtZXJnZWQsIGN1cnJlbnQpIHtcclxuICAgICAgdmFyIGV4aXN0aW5nID0gbWVyZ2VkW2N1cnJlbnQubmFtZV07XHJcbiAgICAgIG1lcmdlZFtjdXJyZW50Lm5hbWVdID0gZXhpc3RpbmcgPyBPYmplY3QuYXNzaWduKHt9LCBleGlzdGluZywgY3VycmVudCwge1xyXG4gICAgICAgIG9wdGlvbnM6IE9iamVjdC5hc3NpZ24oe30sIGV4aXN0aW5nLm9wdGlvbnMsIGN1cnJlbnQub3B0aW9ucyksXHJcbiAgICAgICAgZGF0YTogT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmcuZGF0YSwgY3VycmVudC5kYXRhKVxyXG4gICAgICB9KSA6IGN1cnJlbnQ7XHJcbiAgICAgIHJldHVybiBtZXJnZWQ7XHJcbiAgICB9LCB7fSk7IC8vIElFMTEgZG9lcyBub3Qgc3VwcG9ydCBPYmplY3QudmFsdWVzXHJcblxyXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKG1lcmdlZCkubWFwKGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgcmV0dXJuIG1lcmdlZFtrZXldO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICB2YXIgREVGQVVMVF9PUFRJT05TID0ge1xyXG4gICAgcGxhY2VtZW50OiAnYm90dG9tJyxcclxuICAgIG1vZGlmaWVyczogW10sXHJcbiAgICBzdHJhdGVneTogJ2Fic29sdXRlJ1xyXG4gIH07XHJcblxyXG4gIGZ1bmN0aW9uIGFyZVZhbGlkRWxlbWVudHMoKSB7XHJcbiAgICBmb3IgKHZhciBfbGVuID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuKSwgX2tleSA9IDA7IF9rZXkgPCBfbGVuOyBfa2V5KyspIHtcclxuICAgICAgYXJnc1tfa2V5XSA9IGFyZ3VtZW50c1tfa2V5XTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gIWFyZ3Muc29tZShmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICByZXR1cm4gIShlbGVtZW50ICYmIHR5cGVvZiBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCA9PT0gJ2Z1bmN0aW9uJyk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIGZ1bmN0aW9uIHBvcHBlckdlbmVyYXRvcihnZW5lcmF0b3JPcHRpb25zKSB7XHJcbiAgICBpZiAoZ2VuZXJhdG9yT3B0aW9ucyA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIGdlbmVyYXRvck9wdGlvbnMgPSB7fTtcclxuICAgIH1cclxuXHJcbiAgICB2YXIgX2dlbmVyYXRvck9wdGlvbnMgPSBnZW5lcmF0b3JPcHRpb25zLFxyXG4gICAgICAgIF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRNb2RpZmllcnMsXHJcbiAgICAgICAgZGVmYXVsdE1vZGlmaWVycyA9IF9nZW5lcmF0b3JPcHRpb25zJGRlZiA9PT0gdm9pZCAwID8gW10gOiBfZ2VuZXJhdG9yT3B0aW9ucyRkZWYsXHJcbiAgICAgICAgX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9IF9nZW5lcmF0b3JPcHRpb25zLmRlZmF1bHRPcHRpb25zLFxyXG4gICAgICAgIGRlZmF1bHRPcHRpb25zID0gX2dlbmVyYXRvck9wdGlvbnMkZGVmMiA9PT0gdm9pZCAwID8gREVGQVVMVF9PUFRJT05TIDogX2dlbmVyYXRvck9wdGlvbnMkZGVmMjtcclxuICAgIHJldHVybiBmdW5jdGlvbiBjcmVhdGVQb3BwZXIocmVmZXJlbmNlLCBwb3BwZXIsIG9wdGlvbnMpIHtcclxuICAgICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkge1xyXG4gICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0T3B0aW9ucztcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIHN0YXRlID0ge1xyXG4gICAgICAgIHBsYWNlbWVudDogJ2JvdHRvbScsXHJcbiAgICAgICAgb3JkZXJlZE1vZGlmaWVyczogW10sXHJcbiAgICAgICAgb3B0aW9uczogT2JqZWN0LmFzc2lnbih7fSwgREVGQVVMVF9PUFRJT05TLCBkZWZhdWx0T3B0aW9ucyksXHJcbiAgICAgICAgbW9kaWZpZXJzRGF0YToge30sXHJcbiAgICAgICAgZWxlbWVudHM6IHtcclxuICAgICAgICAgIHJlZmVyZW5jZTogcmVmZXJlbmNlLFxyXG4gICAgICAgICAgcG9wcGVyOiBwb3BwZXJcclxuICAgICAgICB9LFxyXG4gICAgICAgIGF0dHJpYnV0ZXM6IHt9LFxyXG4gICAgICAgIHN0eWxlczoge31cclxuICAgICAgfTtcclxuICAgICAgdmFyIGVmZmVjdENsZWFudXBGbnMgPSBbXTtcclxuICAgICAgdmFyIGlzRGVzdHJveWVkID0gZmFsc2U7XHJcbiAgICAgIHZhciBpbnN0YW5jZSA9IHtcclxuICAgICAgICBzdGF0ZTogc3RhdGUsXHJcbiAgICAgICAgc2V0T3B0aW9uczogZnVuY3Rpb24gc2V0T3B0aW9ucyhzZXRPcHRpb25zQWN0aW9uKSB7XHJcbiAgICAgICAgICB2YXIgb3B0aW9ucyA9IHR5cGVvZiBzZXRPcHRpb25zQWN0aW9uID09PSAnZnVuY3Rpb24nID8gc2V0T3B0aW9uc0FjdGlvbihzdGF0ZS5vcHRpb25zKSA6IHNldE9wdGlvbnNBY3Rpb247XHJcbiAgICAgICAgICBjbGVhbnVwTW9kaWZpZXJFZmZlY3RzKCk7XHJcbiAgICAgICAgICBzdGF0ZS5vcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgZGVmYXVsdE9wdGlvbnMsIHN0YXRlLm9wdGlvbnMsIG9wdGlvbnMpO1xyXG4gICAgICAgICAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IHtcclxuICAgICAgICAgICAgcmVmZXJlbmNlOiBpc0VsZW1lbnQocmVmZXJlbmNlKSA/IGxpc3RTY3JvbGxQYXJlbnRzKHJlZmVyZW5jZSkgOiByZWZlcmVuY2UuY29udGV4dEVsZW1lbnQgPyBsaXN0U2Nyb2xsUGFyZW50cyhyZWZlcmVuY2UuY29udGV4dEVsZW1lbnQpIDogW10sXHJcbiAgICAgICAgICAgIHBvcHBlcjogbGlzdFNjcm9sbFBhcmVudHMocG9wcGVyKVxyXG4gICAgICAgICAgfTsgLy8gT3JkZXJzIHRoZSBtb2RpZmllcnMgYmFzZWQgb24gdGhlaXIgZGVwZW5kZW5jaWVzIGFuZCBgcGhhc2VgXHJcbiAgICAgICAgICAvLyBwcm9wZXJ0aWVzXHJcblxyXG4gICAgICAgICAgdmFyIG9yZGVyZWRNb2RpZmllcnMgPSBvcmRlck1vZGlmaWVycyhtZXJnZUJ5TmFtZShbXS5jb25jYXQoZGVmYXVsdE1vZGlmaWVycywgc3RhdGUub3B0aW9ucy5tb2RpZmllcnMpKSk7IC8vIFN0cmlwIG91dCBkaXNhYmxlZCBtb2RpZmllcnNcclxuXHJcbiAgICAgICAgICBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzID0gb3JkZXJlZE1vZGlmaWVycy5maWx0ZXIoZnVuY3Rpb24gKG0pIHtcclxuICAgICAgICAgICAgcmV0dXJuIG0uZW5hYmxlZDtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgcnVuTW9kaWZpZXJFZmZlY3RzKCk7XHJcbiAgICAgICAgICByZXR1cm4gaW5zdGFuY2UudXBkYXRlKCk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBTeW5jIHVwZGF0ZSDigJMgaXQgd2lsbCBhbHdheXMgYmUgZXhlY3V0ZWQsIGV2ZW4gaWYgbm90IG5lY2Vzc2FyeS4gVGhpc1xyXG4gICAgICAgIC8vIGlzIHVzZWZ1bCBmb3IgbG93IGZyZXF1ZW5jeSB1cGRhdGVzIHdoZXJlIHN5bmMgYmVoYXZpb3Igc2ltcGxpZmllcyB0aGVcclxuICAgICAgICAvLyBsb2dpYy5cclxuICAgICAgICAvLyBGb3IgaGlnaCBmcmVxdWVuY3kgdXBkYXRlcyAoZS5nLiBgcmVzaXplYCBhbmQgYHNjcm9sbGAgZXZlbnRzKSwgYWx3YXlzXHJcbiAgICAgICAgLy8gcHJlZmVyIHRoZSBhc3luYyBQb3BwZXIjdXBkYXRlIG1ldGhvZFxyXG4gICAgICAgIGZvcmNlVXBkYXRlOiBmdW5jdGlvbiBmb3JjZVVwZGF0ZSgpIHtcclxuICAgICAgICAgIGlmIChpc0Rlc3Ryb3llZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgdmFyIF9zdGF0ZSRlbGVtZW50cyA9IHN0YXRlLmVsZW1lbnRzLFxyXG4gICAgICAgICAgICAgIHJlZmVyZW5jZSA9IF9zdGF0ZSRlbGVtZW50cy5yZWZlcmVuY2UsXHJcbiAgICAgICAgICAgICAgcG9wcGVyID0gX3N0YXRlJGVsZW1lbnRzLnBvcHBlcjsgLy8gRG9uJ3QgcHJvY2VlZCBpZiBgcmVmZXJlbmNlYCBvciBgcG9wcGVyYCBhcmUgbm90IHZhbGlkIGVsZW1lbnRzXHJcbiAgICAgICAgICAvLyBhbnltb3JlXHJcblxyXG4gICAgICAgICAgaWYgKCFhcmVWYWxpZEVsZW1lbnRzKHJlZmVyZW5jZSwgcG9wcGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9IC8vIFN0b3JlIHRoZSByZWZlcmVuY2UgYW5kIHBvcHBlciByZWN0cyB0byBiZSByZWFkIGJ5IG1vZGlmaWVyc1xyXG5cclxuXHJcbiAgICAgICAgICBzdGF0ZS5yZWN0cyA9IHtcclxuICAgICAgICAgICAgcmVmZXJlbmNlOiBnZXRDb21wb3NpdGVSZWN0KHJlZmVyZW5jZSwgZ2V0T2Zmc2V0UGFyZW50KHBvcHBlciksIHN0YXRlLm9wdGlvbnMuc3RyYXRlZ3kgPT09ICdmaXhlZCcpLFxyXG4gICAgICAgICAgICBwb3BwZXI6IGdldExheW91dFJlY3QocG9wcGVyKVxyXG4gICAgICAgICAgfTsgLy8gTW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gcmVzZXQgdGhlIGN1cnJlbnQgdXBkYXRlIGN5Y2xlLiBUaGVcclxuICAgICAgICAgIC8vIG1vc3QgY29tbW9uIHVzZSBjYXNlIGZvciB0aGlzIGlzIHRoZSBgZmxpcGAgbW9kaWZpZXIgY2hhbmdpbmcgdGhlXHJcbiAgICAgICAgICAvLyBwbGFjZW1lbnQsIHdoaWNoIHRoZW4gbmVlZHMgdG8gcmUtcnVuIGFsbCB0aGUgbW9kaWZpZXJzLCBiZWNhdXNlIHRoZVxyXG4gICAgICAgICAgLy8gbG9naWMgd2FzIHByZXZpb3VzbHkgcmFuIGZvciB0aGUgcHJldmlvdXMgcGxhY2VtZW50IGFuZCBpcyB0aGVyZWZvcmVcclxuICAgICAgICAgIC8vIHN0YWxlL2luY29ycmVjdFxyXG5cclxuICAgICAgICAgIHN0YXRlLnJlc2V0ID0gZmFsc2U7XHJcbiAgICAgICAgICBzdGF0ZS5wbGFjZW1lbnQgPSBzdGF0ZS5vcHRpb25zLnBsYWNlbWVudDsgLy8gT24gZWFjaCB1cGRhdGUgY3ljbGUsIHRoZSBgbW9kaWZpZXJzRGF0YWAgcHJvcGVydHkgZm9yIGVhY2ggbW9kaWZpZXJcclxuICAgICAgICAgIC8vIGlzIGZpbGxlZCB3aXRoIHRoZSBpbml0aWFsIGRhdGEgc3BlY2lmaWVkIGJ5IHRoZSBtb2RpZmllci4gVGhpcyBtZWFuc1xyXG4gICAgICAgICAgLy8gaXQgZG9lc24ndCBwZXJzaXN0IGFuZCBpcyBmcmVzaCBvbiBlYWNoIHVwZGF0ZS5cclxuICAgICAgICAgIC8vIFRvIGVuc3VyZSBwZXJzaXN0ZW50IGRhdGEsIHVzZSBgJHtuYW1lfSNwZXJzaXN0ZW50YFxyXG5cclxuICAgICAgICAgIHN0YXRlLm9yZGVyZWRNb2RpZmllcnMuZm9yRWFjaChmdW5jdGlvbiAobW9kaWZpZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0YXRlLm1vZGlmaWVyc0RhdGFbbW9kaWZpZXIubmFtZV0gPSBPYmplY3QuYXNzaWduKHt9LCBtb2RpZmllci5kYXRhKTtcclxuICAgICAgICAgIH0pO1xyXG5cclxuICAgICAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzLmxlbmd0aDsgaW5kZXgrKykge1xyXG4gICAgICAgICAgICBpZiAoc3RhdGUucmVzZXQgPT09IHRydWUpIHtcclxuICAgICAgICAgICAgICBzdGF0ZS5yZXNldCA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgIGluZGV4ID0gLTE7XHJcbiAgICAgICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHZhciBfc3RhdGUkb3JkZXJlZE1vZGlmaWUgPSBzdGF0ZS5vcmRlcmVkTW9kaWZpZXJzW2luZGV4XSxcclxuICAgICAgICAgICAgICAgIGZuID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLmZuLFxyXG4gICAgICAgICAgICAgICAgX3N0YXRlJG9yZGVyZWRNb2RpZmllMiA9IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZS5vcHRpb25zLFxyXG4gICAgICAgICAgICAgICAgX29wdGlvbnMgPSBfc3RhdGUkb3JkZXJlZE1vZGlmaWUyID09PSB2b2lkIDAgPyB7fSA6IF9zdGF0ZSRvcmRlcmVkTW9kaWZpZTIsXHJcbiAgICAgICAgICAgICAgICBuYW1lID0gX3N0YXRlJG9yZGVyZWRNb2RpZmllLm5hbWU7XHJcblxyXG4gICAgICAgICAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgc3RhdGUgPSBmbih7XHJcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUsXHJcbiAgICAgICAgICAgICAgICBvcHRpb25zOiBfb3B0aW9ucyxcclxuICAgICAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICBpbnN0YW5jZTogaW5zdGFuY2VcclxuICAgICAgICAgICAgICB9KSB8fCBzdGF0ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgLy8gQXN5bmMgYW5kIG9wdGltaXN0aWNhbGx5IG9wdGltaXplZCB1cGRhdGUg4oCTIGl0IHdpbGwgbm90IGJlIGV4ZWN1dGVkIGlmXHJcbiAgICAgICAgLy8gbm90IG5lY2Vzc2FyeSAoZGVib3VuY2VkIHRvIHJ1biBhdCBtb3N0IG9uY2UtcGVyLXRpY2spXHJcbiAgICAgICAgdXBkYXRlOiBkZWJvdW5jZShmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcclxuICAgICAgICAgICAgaW5zdGFuY2UuZm9yY2VVcGRhdGUoKTtcclxuICAgICAgICAgICAgcmVzb2x2ZShzdGF0ZSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9KSxcclxuICAgICAgICBkZXN0cm95OiBmdW5jdGlvbiBkZXN0cm95KCkge1xyXG4gICAgICAgICAgY2xlYW51cE1vZGlmaWVyRWZmZWN0cygpO1xyXG4gICAgICAgICAgaXNEZXN0cm95ZWQgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIGlmICghYXJlVmFsaWRFbGVtZW50cyhyZWZlcmVuY2UsIHBvcHBlcikpIHtcclxuICAgICAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGluc3RhbmNlLnNldE9wdGlvbnMob3B0aW9ucykudGhlbihmdW5jdGlvbiAoc3RhdGUpIHtcclxuICAgICAgICBpZiAoIWlzRGVzdHJveWVkICYmIG9wdGlvbnMub25GaXJzdFVwZGF0ZSkge1xyXG4gICAgICAgICAgb3B0aW9ucy5vbkZpcnN0VXBkYXRlKHN0YXRlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pOyAvLyBNb2RpZmllcnMgaGF2ZSB0aGUgYWJpbGl0eSB0byBleGVjdXRlIGFyYml0cmFyeSBjb2RlIGJlZm9yZSB0aGUgZmlyc3RcclxuICAgICAgLy8gdXBkYXRlIGN5Y2xlIHJ1bnMuIFRoZXkgd2lsbCBiZSBleGVjdXRlZCBpbiB0aGUgc2FtZSBvcmRlciBhcyB0aGUgdXBkYXRlXHJcbiAgICAgIC8vIGN5Y2xlLiBUaGlzIGlzIHVzZWZ1bCB3aGVuIGEgbW9kaWZpZXIgYWRkcyBzb21lIHBlcnNpc3RlbnQgZGF0YSB0aGF0XHJcbiAgICAgIC8vIG90aGVyIG1vZGlmaWVycyBuZWVkIHRvIHVzZSwgYnV0IHRoZSBtb2RpZmllciBpcyBydW4gYWZ0ZXIgdGhlIGRlcGVuZGVudFxyXG4gICAgICAvLyBvbmUuXHJcblxyXG4gICAgICBmdW5jdGlvbiBydW5Nb2RpZmllckVmZmVjdHMoKSB7XHJcbiAgICAgICAgc3RhdGUub3JkZXJlZE1vZGlmaWVycy5mb3JFYWNoKGZ1bmN0aW9uIChfcmVmKSB7XHJcbiAgICAgICAgICB2YXIgbmFtZSA9IF9yZWYubmFtZSxcclxuICAgICAgICAgICAgICBfcmVmJG9wdGlvbnMgPSBfcmVmLm9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgb3B0aW9ucyA9IF9yZWYkb3B0aW9ucyA9PT0gdm9pZCAwID8ge30gOiBfcmVmJG9wdGlvbnMsXHJcbiAgICAgICAgICAgICAgZWZmZWN0ID0gX3JlZi5lZmZlY3Q7XHJcblxyXG4gICAgICAgICAgaWYgKHR5cGVvZiBlZmZlY3QgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdmFyIGNsZWFudXBGbiA9IGVmZmVjdCh7XHJcbiAgICAgICAgICAgICAgc3RhdGU6IHN0YXRlLFxyXG4gICAgICAgICAgICAgIG5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgaW5zdGFuY2U6IGluc3RhbmNlLFxyXG4gICAgICAgICAgICAgIG9wdGlvbnM6IG9wdGlvbnNcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICB2YXIgbm9vcEZuID0gZnVuY3Rpb24gbm9vcEZuKCkge307XHJcblxyXG4gICAgICAgICAgICBlZmZlY3RDbGVhbnVwRm5zLnB1c2goY2xlYW51cEZuIHx8IG5vb3BGbik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGZ1bmN0aW9uIGNsZWFudXBNb2RpZmllckVmZmVjdHMoKSB7XHJcbiAgICAgICAgZWZmZWN0Q2xlYW51cEZucy5mb3JFYWNoKGZ1bmN0aW9uIChmbikge1xyXG4gICAgICAgICAgcmV0dXJuIGZuKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZWZmZWN0Q2xlYW51cEZucyA9IFtdO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gaW5zdGFuY2U7XHJcbiAgICB9O1xyXG4gIH1cclxuICB2YXIgY3JlYXRlUG9wcGVyJDIgPSAvKiNfX1BVUkVfXyovcG9wcGVyR2VuZXJhdG9yKCk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcclxuXHJcbiAgdmFyIGRlZmF1bHRNb2RpZmllcnMkMSA9IFtldmVudExpc3RlbmVycywgcG9wcGVyT2Zmc2V0cyQxLCBjb21wdXRlU3R5bGVzJDEsIGFwcGx5U3R5bGVzJDFdO1xyXG4gIHZhciBjcmVhdGVQb3BwZXIkMSA9IC8qI19fUFVSRV9fKi9wb3BwZXJHZW5lcmF0b3Ioe1xyXG4gICAgZGVmYXVsdE1vZGlmaWVyczogZGVmYXVsdE1vZGlmaWVycyQxXHJcbiAgfSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcclxuXHJcbiAgdmFyIGRlZmF1bHRNb2RpZmllcnMgPSBbZXZlbnRMaXN0ZW5lcnMsIHBvcHBlck9mZnNldHMkMSwgY29tcHV0ZVN0eWxlcyQxLCBhcHBseVN0eWxlcyQxLCBvZmZzZXQkMSwgZmxpcCQxLCBwcmV2ZW50T3ZlcmZsb3ckMSwgYXJyb3ckMSwgaGlkZSQxXTtcclxuICB2YXIgY3JlYXRlUG9wcGVyID0gLyojX19QVVJFX18qL3BvcHBlckdlbmVyYXRvcih7XHJcbiAgICBkZWZhdWx0TW9kaWZpZXJzOiBkZWZhdWx0TW9kaWZpZXJzXHJcbiAgfSk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBpbXBvcnQvbm8tdW51c2VkLW1vZHVsZXNcclxuXHJcbiAgY29uc3QgUG9wcGVyID0gLyojX19QVVJFX18qL09iamVjdC5mcmVlemUoLyojX19QVVJFX18qL09iamVjdC5kZWZpbmVQcm9wZXJ0eSh7XHJcbiAgICBfX3Byb3RvX186IG51bGwsXHJcbiAgICBhZnRlck1haW4sXHJcbiAgICBhZnRlclJlYWQsXHJcbiAgICBhZnRlcldyaXRlLFxyXG4gICAgYXBwbHlTdHlsZXM6IGFwcGx5U3R5bGVzJDEsXHJcbiAgICBhcnJvdzogYXJyb3ckMSxcclxuICAgIGF1dG8sXHJcbiAgICBiYXNlUGxhY2VtZW50cyxcclxuICAgIGJlZm9yZU1haW4sXHJcbiAgICBiZWZvcmVSZWFkLFxyXG4gICAgYmVmb3JlV3JpdGUsXHJcbiAgICBib3R0b20sXHJcbiAgICBjbGlwcGluZ1BhcmVudHMsXHJcbiAgICBjb21wdXRlU3R5bGVzOiBjb21wdXRlU3R5bGVzJDEsXHJcbiAgICBjcmVhdGVQb3BwZXIsXHJcbiAgICBjcmVhdGVQb3BwZXJCYXNlOiBjcmVhdGVQb3BwZXIkMixcclxuICAgIGNyZWF0ZVBvcHBlckxpdGU6IGNyZWF0ZVBvcHBlciQxLFxyXG4gICAgZGV0ZWN0T3ZlcmZsb3csXHJcbiAgICBlbmQsXHJcbiAgICBldmVudExpc3RlbmVycyxcclxuICAgIGZsaXA6IGZsaXAkMSxcclxuICAgIGhpZGU6IGhpZGUkMSxcclxuICAgIGxlZnQsXHJcbiAgICBtYWluLFxyXG4gICAgbW9kaWZpZXJQaGFzZXMsXHJcbiAgICBvZmZzZXQ6IG9mZnNldCQxLFxyXG4gICAgcGxhY2VtZW50cyxcclxuICAgIHBvcHBlcixcclxuICAgIHBvcHBlckdlbmVyYXRvcixcclxuICAgIHBvcHBlck9mZnNldHM6IHBvcHBlck9mZnNldHMkMSxcclxuICAgIHByZXZlbnRPdmVyZmxvdzogcHJldmVudE92ZXJmbG93JDEsXHJcbiAgICByZWFkLFxyXG4gICAgcmVmZXJlbmNlLFxyXG4gICAgcmlnaHQsXHJcbiAgICBzdGFydCxcclxuICAgIHRvcCxcclxuICAgIHZhcmlhdGlvblBsYWNlbWVudHMsXHJcbiAgICB2aWV3cG9ydCxcclxuICAgIHdyaXRlXHJcbiAgfSwgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwIGRyb3Bkb3duLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBOQU1FJGEgPSAnZHJvcGRvd24nO1xyXG4gIGNvbnN0IERBVEFfS0VZJDYgPSAnYnMuZHJvcGRvd24nO1xyXG4gIGNvbnN0IEVWRU5UX0tFWSQ2ID0gYC4ke0RBVEFfS0VZJDZ9YDtcclxuICBjb25zdCBEQVRBX0FQSV9LRVkkMyA9ICcuZGF0YS1hcGknO1xyXG4gIGNvbnN0IEVTQ0FQRV9LRVkkMiA9ICdFc2NhcGUnO1xyXG4gIGNvbnN0IFRBQl9LRVkkMSA9ICdUYWInO1xyXG4gIGNvbnN0IEFSUk9XX1VQX0tFWSQxID0gJ0Fycm93VXAnO1xyXG4gIGNvbnN0IEFSUk9XX0RPV05fS0VZJDEgPSAnQXJyb3dEb3duJztcclxuICBjb25zdCBSSUdIVF9NT1VTRV9CVVRUT04gPSAyOyAvLyBNb3VzZUV2ZW50LmJ1dHRvbiB2YWx1ZSBmb3IgdGhlIHNlY29uZGFyeSBidXR0b24sIHVzdWFsbHkgdGhlIHJpZ2h0IGJ1dHRvblxyXG5cclxuICBjb25zdCBFVkVOVF9ISURFJDUgPSBgaGlkZSR7RVZFTlRfS0VZJDZ9YDtcclxuICBjb25zdCBFVkVOVF9ISURERU4kNSA9IGBoaWRkZW4ke0VWRU5UX0tFWSQ2fWA7XHJcbiAgY29uc3QgRVZFTlRfU0hPVyQ1ID0gYHNob3cke0VWRU5UX0tFWSQ2fWA7XHJcbiAgY29uc3QgRVZFTlRfU0hPV04kNSA9IGBzaG93biR7RVZFTlRfS0VZJDZ9YDtcclxuICBjb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQzID0gYGNsaWNrJHtFVkVOVF9LRVkkNn0ke0RBVEFfQVBJX0tFWSQzfWA7XHJcbiAgY29uc3QgRVZFTlRfS0VZRE9XTl9EQVRBX0FQSSA9IGBrZXlkb3duJHtFVkVOVF9LRVkkNn0ke0RBVEFfQVBJX0tFWSQzfWA7XHJcbiAgY29uc3QgRVZFTlRfS0VZVVBfREFUQV9BUEkgPSBga2V5dXAke0VWRU5UX0tFWSQ2fSR7REFUQV9BUElfS0VZJDN9YDtcclxuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckNiA9ICdzaG93JztcclxuICBjb25zdCBDTEFTU19OQU1FX0RST1BVUCA9ICdkcm9wdXAnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUEVORCA9ICdkcm9wZW5kJztcclxuICBjb25zdCBDTEFTU19OQU1FX0RST1BTVEFSVCA9ICdkcm9wc3RhcnQnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfRFJPUFVQX0NFTlRFUiA9ICdkcm9wdXAtY2VudGVyJztcclxuICBjb25zdCBDTEFTU19OQU1FX0RST1BET1dOX0NFTlRFUiA9ICdkcm9wZG93bi1jZW50ZXInO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMgPSAnW2RhdGEtYnMtdG9nZ2xlPVwiZHJvcGRvd25cIl06bm90KC5kaXNhYmxlZCk6bm90KDpkaXNhYmxlZCknO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFX1NIT1dOID0gYCR7U0VMRUNUT1JfREFUQV9UT0dHTEUkM30uJHtDTEFTU19OQU1FX1NIT1ckNn1gO1xyXG4gIGNvbnN0IFNFTEVDVE9SX01FTlUgPSAnLmRyb3Bkb3duLW1lbnUnO1xyXG4gIGNvbnN0IFNFTEVDVE9SX05BVkJBUiA9ICcubmF2YmFyJztcclxuICBjb25zdCBTRUxFQ1RPUl9OQVZCQVJfTkFWID0gJy5uYXZiYXItbmF2JztcclxuICBjb25zdCBTRUxFQ1RPUl9WSVNJQkxFX0lURU1TID0gJy5kcm9wZG93bi1tZW51IC5kcm9wZG93bi1pdGVtOm5vdCguZGlzYWJsZWQpOm5vdCg6ZGlzYWJsZWQpJztcclxuICBjb25zdCBQTEFDRU1FTlRfVE9QID0gaXNSVEwoKSA/ICd0b3AtZW5kJyA6ICd0b3Atc3RhcnQnO1xyXG4gIGNvbnN0IFBMQUNFTUVOVF9UT1BFTkQgPSBpc1JUTCgpID8gJ3RvcC1zdGFydCcgOiAndG9wLWVuZCc7XHJcbiAgY29uc3QgUExBQ0VNRU5UX0JPVFRPTSA9IGlzUlRMKCkgPyAnYm90dG9tLWVuZCcgOiAnYm90dG9tLXN0YXJ0JztcclxuICBjb25zdCBQTEFDRU1FTlRfQk9UVE9NRU5EID0gaXNSVEwoKSA/ICdib3R0b20tc3RhcnQnIDogJ2JvdHRvbS1lbmQnO1xyXG4gIGNvbnN0IFBMQUNFTUVOVF9SSUdIVCA9IGlzUlRMKCkgPyAnbGVmdC1zdGFydCcgOiAncmlnaHQtc3RhcnQnO1xyXG4gIGNvbnN0IFBMQUNFTUVOVF9MRUZUID0gaXNSVEwoKSA/ICdyaWdodC1zdGFydCcgOiAnbGVmdC1zdGFydCc7XHJcbiAgY29uc3QgUExBQ0VNRU5UX1RPUENFTlRFUiA9ICd0b3AnO1xyXG4gIGNvbnN0IFBMQUNFTUVOVF9CT1RUT01DRU5URVIgPSAnYm90dG9tJztcclxuICBjb25zdCBEZWZhdWx0JDkgPSB7XHJcbiAgICBhdXRvQ2xvc2U6IHRydWUsXHJcbiAgICBib3VuZGFyeTogJ2NsaXBwaW5nUGFyZW50cycsXHJcbiAgICBkaXNwbGF5OiAnZHluYW1pYycsXHJcbiAgICBvZmZzZXQ6IFswLCAyXSxcclxuICAgIHBvcHBlckNvbmZpZzogbnVsbCxcclxuICAgIHJlZmVyZW5jZTogJ3RvZ2dsZSdcclxuICB9O1xyXG4gIGNvbnN0IERlZmF1bHRUeXBlJDkgPSB7XHJcbiAgICBhdXRvQ2xvc2U6ICcoYm9vbGVhbnxzdHJpbmcpJyxcclxuICAgIGJvdW5kYXJ5OiAnKHN0cmluZ3xlbGVtZW50KScsXHJcbiAgICBkaXNwbGF5OiAnc3RyaW5nJyxcclxuICAgIG9mZnNldDogJyhhcnJheXxzdHJpbmd8ZnVuY3Rpb24pJyxcclxuICAgIHBvcHBlckNvbmZpZzogJyhudWxsfG9iamVjdHxmdW5jdGlvbiknLFxyXG4gICAgcmVmZXJlbmNlOiAnKHN0cmluZ3xlbGVtZW50fG9iamVjdCknXHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBEcm9wZG93biBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCwgY29uZmlnKSB7XHJcbiAgICAgIHN1cGVyKGVsZW1lbnQsIGNvbmZpZyk7XHJcbiAgICAgIHRoaXMuX3BvcHBlciA9IG51bGw7XHJcbiAgICAgIHRoaXMuX3BhcmVudCA9IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZTsgLy8gZHJvcGRvd24gd3JhcHBlclxyXG4gICAgICAvLyBUT0RPOiB2NiByZXZlcnQgIzM3MDExICYgY2hhbmdlIG1hcmt1cCBodHRwczovL2dldGJvb3RzdHJhcC5jb20vZG9jcy81LjMvZm9ybXMvaW5wdXQtZ3JvdXAvXHJcbiAgICAgIHRoaXMuX21lbnUgPSBTZWxlY3RvckVuZ2luZS5uZXh0KHRoaXMuX2VsZW1lbnQsIFNFTEVDVE9SX01FTlUpWzBdIHx8IFNlbGVjdG9yRW5naW5lLnByZXYodGhpcy5fZWxlbWVudCwgU0VMRUNUT1JfTUVOVSlbMF0gfHwgU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9NRU5VLCB0aGlzLl9wYXJlbnQpO1xyXG4gICAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldHRlcnNcclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHQkOTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ5O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgICByZXR1cm4gTkFNRSRhO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFB1YmxpY1xyXG4gICAgdG9nZ2xlKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5faXNTaG93bigpID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3coKTtcclxuICAgIH1cclxuICAgIHNob3coKSB7XHJcbiAgICAgIGlmIChpc0Rpc2FibGVkKHRoaXMuX2VsZW1lbnQpIHx8IHRoaXMuX2lzU2hvd24oKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xyXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcclxuICAgICAgfTtcclxuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQ1LCByZWxhdGVkVGFyZ2V0KTtcclxuICAgICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHBlcigpO1xyXG5cclxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxyXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xyXG4gICAgICAvLyBvbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xyXG4gICAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcclxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiAhdGhpcy5fcGFyZW50LmNsb3Nlc3QoU0VMRUNUT1JfTkFWQkFSX05BVikpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICBFdmVudEhhbmRsZXIub24oZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLWV4cGFuZGVkJywgdHJ1ZSk7XHJcbiAgICAgIHRoaXMuX21lbnUuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNik7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckNik7XHJcbiAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDUsIHJlbGF0ZWRUYXJnZXQpO1xyXG4gICAgfVxyXG4gICAgaGlkZSgpIHtcclxuICAgICAgaWYgKGlzRGlzYWJsZWQodGhpcy5fZWxlbWVudCkgfHwgIXRoaXMuX2lzU2hvd24oKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCByZWxhdGVkVGFyZ2V0ID0ge1xyXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRoaXMuX2VsZW1lbnRcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5fY29tcGxldGVIaWRlKHJlbGF0ZWRUYXJnZXQpO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgaWYgKHRoaXMuX3BvcHBlcikge1xyXG4gICAgICAgIHRoaXMuX3BvcHBlci5kZXN0cm95KCk7XHJcbiAgICAgIH1cclxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG4gICAgdXBkYXRlKCkge1xyXG4gICAgICB0aGlzLl9pbk5hdmJhciA9IHRoaXMuX2RldGVjdE5hdmJhcigpO1xyXG4gICAgICBpZiAodGhpcy5fcG9wcGVyKSB7XHJcbiAgICAgICAgdGhpcy5fcG9wcGVyLnVwZGF0ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJpdmF0ZVxyXG4gICAgX2NvbXBsZXRlSGlkZShyZWxhdGVkVGFyZ2V0KSB7XHJcbiAgICAgIGNvbnN0IGhpZGVFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREUkNSwgcmVsYXRlZFRhcmdldCk7XHJcbiAgICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIHJlbW92ZSB0aGUgZXh0cmFcclxuICAgICAgLy8gZW1wdHkgbW91c2VvdmVyIGxpc3RlbmVycyB3ZSBhZGRlZCBmb3IgaU9TIHN1cHBvcnRcclxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcclxuICAgICAgICAgIEV2ZW50SGFuZGxlci5vZmYoZWxlbWVudCwgJ21vdXNlb3ZlcicsIG5vb3ApO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5fcG9wcGVyKSB7XHJcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9tZW51LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDYpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDYpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1leHBhbmRlZCcsICdmYWxzZScpO1xyXG4gICAgICBNYW5pcHVsYXRvci5yZW1vdmVEYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsICdwb3BwZXInKTtcclxuICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDUsIHJlbGF0ZWRUYXJnZXQpO1xyXG5cclxuICAgICAgLy8gRXhwbGljaXRseSByZXR1cm4gZm9jdXMgdG8gdGhlIHRyaWdnZXIgZWxlbWVudFxyXG4gICAgICB0aGlzLl9lbGVtZW50LmZvY3VzKCk7XHJcbiAgICB9XHJcbiAgICBfZ2V0Q29uZmlnKGNvbmZpZykge1xyXG4gICAgICBjb25maWcgPSBzdXBlci5fZ2V0Q29uZmlnKGNvbmZpZyk7XHJcbiAgICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZmVyZW5jZSA9PT0gJ29iamVjdCcgJiYgIWlzRWxlbWVudCQxKGNvbmZpZy5yZWZlcmVuY2UpICYmIHR5cGVvZiBjb25maWcucmVmZXJlbmNlLmdldEJvdW5kaW5nQ2xpZW50UmVjdCAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIC8vIFBvcHBlciB2aXJ0dWFsIGVsZW1lbnRzIHJlcXVpcmUgYSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgbWV0aG9kXHJcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgJHtOQU1FJGEudG9VcHBlckNhc2UoKX06IE9wdGlvbiBcInJlZmVyZW5jZVwiIHByb3ZpZGVkIHR5cGUgXCJvYmplY3RcIiB3aXRob3V0IGEgcmVxdWlyZWQgXCJnZXRCb3VuZGluZ0NsaWVudFJlY3RcIiBtZXRob2QuYCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgIH1cclxuICAgIF9jcmVhdGVQb3BwZXIoKSB7XHJcbiAgICAgIGlmICh0eXBlb2YgUG9wcGVyID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0Jvb3RzdHJhcFxcJ3MgZHJvcGRvd25zIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcvZG9jcy92Mi8pJyk7XHJcbiAgICAgIH1cclxuICAgICAgbGV0IHJlZmVyZW5jZUVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xyXG4gICAgICBpZiAodGhpcy5fY29uZmlnLnJlZmVyZW5jZSA9PT0gJ3BhcmVudCcpIHtcclxuICAgICAgICByZWZlcmVuY2VFbGVtZW50ID0gdGhpcy5fcGFyZW50O1xyXG4gICAgICB9IGVsc2UgaWYgKGlzRWxlbWVudCQxKHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UpKSB7XHJcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IGdldEVsZW1lbnQodGhpcy5fY29uZmlnLnJlZmVyZW5jZSk7XHJcbiAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHRoaXMuX2NvbmZpZy5yZWZlcmVuY2UgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgcmVmZXJlbmNlRWxlbWVudCA9IHRoaXMuX2NvbmZpZy5yZWZlcmVuY2U7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgcG9wcGVyQ29uZmlnID0gdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKCk7XHJcbiAgICAgIHRoaXMuX3BvcHBlciA9IGNyZWF0ZVBvcHBlcihyZWZlcmVuY2VFbGVtZW50LCB0aGlzLl9tZW51LCBwb3BwZXJDb25maWcpO1xyXG4gICAgfVxyXG4gICAgX2lzU2hvd24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9tZW51LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckNik7XHJcbiAgICB9XHJcbiAgICBfZ2V0UGxhY2VtZW50KCkge1xyXG4gICAgICBjb25zdCBwYXJlbnREcm9wZG93biA9IHRoaXMuX3BhcmVudDtcclxuICAgICAgaWYgKHBhcmVudERyb3Bkb3duLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0RST1BFTkQpKSB7XHJcbiAgICAgICAgcmV0dXJuIFBMQUNFTUVOVF9SSUdIVDtcclxuICAgICAgfVxyXG4gICAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUFNUQVJUKSkge1xyXG4gICAgICAgIHJldHVybiBQTEFDRU1FTlRfTEVGVDtcclxuICAgICAgfVxyXG4gICAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUFVQX0NFTlRFUikpIHtcclxuICAgICAgICByZXR1cm4gUExBQ0VNRU5UX1RPUENFTlRFUjtcclxuICAgICAgfVxyXG4gICAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUERPV05fQ0VOVEVSKSkge1xyXG4gICAgICAgIHJldHVybiBQTEFDRU1FTlRfQk9UVE9NQ0VOVEVSO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBXZSBuZWVkIHRvIHRyaW0gdGhlIHZhbHVlIGJlY2F1c2UgY3VzdG9tIHByb3BlcnRpZXMgY2FuIGFsc28gaW5jbHVkZSBzcGFjZXNcclxuICAgICAgY29uc3QgaXNFbmQgPSBnZXRDb21wdXRlZFN0eWxlKHRoaXMuX21lbnUpLmdldFByb3BlcnR5VmFsdWUoJy0tYnMtcG9zaXRpb24nKS50cmltKCkgPT09ICdlbmQnO1xyXG4gICAgICBpZiAocGFyZW50RHJvcGRvd24uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfRFJPUFVQKSkge1xyXG4gICAgICAgIHJldHVybiBpc0VuZCA/IFBMQUNFTUVOVF9UT1BFTkQgOiBQTEFDRU1FTlRfVE9QO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiBpc0VuZCA/IFBMQUNFTUVOVF9CT1RUT01FTkQgOiBQTEFDRU1FTlRfQk9UVE9NO1xyXG4gICAgfVxyXG4gICAgX2RldGVjdE5hdmJhcigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9OQVZCQVIpICE9PSBudWxsO1xyXG4gICAgfVxyXG4gICAgX2dldE9mZnNldCgpIHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIG9mZnNldFxyXG4gICAgICB9ID0gdGhpcy5fY29uZmlnO1xyXG4gICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICByZXR1cm4gb2Zmc2V0LnNwbGl0KCcsJykubWFwKHZhbHVlID0+IE51bWJlci5wYXJzZUludCh2YWx1ZSwgMTApKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIG9mZnNldCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHJldHVybiBwb3BwZXJEYXRhID0+IG9mZnNldChwb3BwZXJEYXRhLCB0aGlzLl9lbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gb2Zmc2V0O1xyXG4gICAgfVxyXG4gICAgX2dldFBvcHBlckNvbmZpZygpIHtcclxuICAgICAgY29uc3QgZGVmYXVsdEJzUG9wcGVyQ29uZmlnID0ge1xyXG4gICAgICAgIHBsYWNlbWVudDogdGhpcy5fZ2V0UGxhY2VtZW50KCksXHJcbiAgICAgICAgbW9kaWZpZXJzOiBbe1xyXG4gICAgICAgICAgbmFtZTogJ3ByZXZlbnRPdmVyZmxvdycsXHJcbiAgICAgICAgICBvcHRpb25zOiB7XHJcbiAgICAgICAgICAgIGJvdW5kYXJ5OiB0aGlzLl9jb25maWcuYm91bmRhcnlcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcclxuICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLl9nZXRPZmZzZXQoKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1dXHJcbiAgICAgIH07XHJcblxyXG4gICAgICAvLyBEaXNhYmxlIFBvcHBlciBpZiB3ZSBoYXZlIGEgc3RhdGljIGRpc3BsYXkgb3IgRHJvcGRvd24gaXMgaW4gTmF2YmFyXHJcbiAgICAgIGlmICh0aGlzLl9pbk5hdmJhciB8fCB0aGlzLl9jb25maWcuZGlzcGxheSA9PT0gJ3N0YXRpYycpIHtcclxuICAgICAgICBNYW5pcHVsYXRvci5zZXREYXRhQXR0cmlidXRlKHRoaXMuX21lbnUsICdwb3BwZXInLCAnc3RhdGljJyk7IC8vIFRPRE86IHY2IHJlbW92ZVxyXG4gICAgICAgIGRlZmF1bHRCc1BvcHBlckNvbmZpZy5tb2RpZmllcnMgPSBbe1xyXG4gICAgICAgICAgbmFtZTogJ2FwcGx5U3R5bGVzJyxcclxuICAgICAgICAgIGVuYWJsZWQ6IGZhbHNlXHJcbiAgICAgICAgfV07XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICAuLi5kZWZhdWx0QnNQb3BwZXJDb25maWcsXHJcbiAgICAgICAgLi4uZXhlY3V0ZSh0aGlzLl9jb25maWcucG9wcGVyQ29uZmlnLCBbdW5kZWZpbmVkLCBkZWZhdWx0QnNQb3BwZXJDb25maWddKVxyXG4gICAgICB9O1xyXG4gICAgfVxyXG4gICAgX3NlbGVjdE1lbnVJdGVtKHtcclxuICAgICAga2V5LFxyXG4gICAgICB0YXJnZXRcclxuICAgIH0pIHtcclxuICAgICAgY29uc3QgaXRlbXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX1ZJU0lCTEVfSVRFTVMsIHRoaXMuX21lbnUpLmZpbHRlcihlbGVtZW50ID0+IGlzVmlzaWJsZShlbGVtZW50KSk7XHJcbiAgICAgIGlmICghaXRlbXMubGVuZ3RoKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBpZiB0YXJnZXQgaXNuJ3QgaW5jbHVkZWQgaW4gaXRlbXMgKGUuZy4gd2hlbiBleHBhbmRpbmcgdGhlIGRyb3Bkb3duKVxyXG4gICAgICAvLyBhbGxvdyBjeWNsaW5nIHRvIGdldCB0aGUgbGFzdCBpdGVtIGluIGNhc2Uga2V5IGVxdWFscyBBUlJPV19VUF9LRVlcclxuICAgICAgZ2V0TmV4dEFjdGl2ZUVsZW1lbnQoaXRlbXMsIHRhcmdldCwga2V5ID09PSBBUlJPV19ET1dOX0tFWSQxLCAhaXRlbXMuaW5jbHVkZXModGFyZ2V0KSkuZm9jdXMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGF0aWNcclxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBEcm9wZG93bi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0eXBlb2YgZGF0YVtjb25maWddID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YVtjb25maWddKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGNsZWFyTWVudXMoZXZlbnQpIHtcclxuICAgICAgaWYgKGV2ZW50LmJ1dHRvbiA9PT0gUklHSFRfTU9VU0VfQlVUVE9OIHx8IGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQua2V5ICE9PSBUQUJfS0VZJDEpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgb3BlblRvZ2dsZXMgPSBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFX1NIT1dOKTtcclxuICAgICAgZm9yIChjb25zdCB0b2dnbGUgb2Ygb3BlblRvZ2dsZXMpIHtcclxuICAgICAgICBjb25zdCBjb250ZXh0ID0gRHJvcGRvd24uZ2V0SW5zdGFuY2UodG9nZ2xlKTtcclxuICAgICAgICBpZiAoIWNvbnRleHQgfHwgY29udGV4dC5fY29uZmlnLmF1dG9DbG9zZSA9PT0gZmFsc2UpIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjb25zdCBjb21wb3NlZFBhdGggPSBldmVudC5jb21wb3NlZFBhdGgoKTtcclxuICAgICAgICBjb25zdCBpc01lbnVUYXJnZXQgPSBjb21wb3NlZFBhdGguaW5jbHVkZXMoY29udGV4dC5fbWVudSk7XHJcbiAgICAgICAgaWYgKGNvbXBvc2VkUGF0aC5pbmNsdWRlcyhjb250ZXh0Ll9lbGVtZW50KSB8fCBjb250ZXh0Ll9jb25maWcuYXV0b0Nsb3NlID09PSAnaW5zaWRlJyAmJiAhaXNNZW51VGFyZ2V0IHx8IGNvbnRleHQuX2NvbmZpZy5hdXRvQ2xvc2UgPT09ICdvdXRzaWRlJyAmJiBpc01lbnVUYXJnZXQpIHtcclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gVGFiIG5hdmlnYXRpb24gdGhyb3VnaCB0aGUgZHJvcGRvd24gbWVudSBvciBldmVudHMgZnJvbSBjb250YWluZWQgaW5wdXRzIHNob3VsZG4ndCBjbG9zZSB0aGUgbWVudVxyXG4gICAgICAgIGlmIChjb250ZXh0Ll9tZW51LmNvbnRhaW5zKGV2ZW50LnRhcmdldCkgJiYgKGV2ZW50LnR5cGUgPT09ICdrZXl1cCcgJiYgZXZlbnQua2V5ID09PSBUQUJfS0VZJDEgfHwgL2lucHV0fHNlbGVjdHxvcHRpb258dGV4dGFyZWF8Zm9ybS9pLnRlc3QoZXZlbnQudGFyZ2V0LnRhZ05hbWUpKSkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IHJlbGF0ZWRUYXJnZXQgPSB7XHJcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiBjb250ZXh0Ll9lbGVtZW50XHJcbiAgICAgICAgfTtcclxuICAgICAgICBpZiAoZXZlbnQudHlwZSA9PT0gJ2NsaWNrJykge1xyXG4gICAgICAgICAgcmVsYXRlZFRhcmdldC5jbGlja0V2ZW50ID0gZXZlbnQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnRleHQuX2NvbXBsZXRlSGlkZShyZWxhdGVkVGFyZ2V0KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgc3RhdGljIGRhdGFBcGlLZXlkb3duSGFuZGxlcihldmVudCkge1xyXG4gICAgICAvLyBJZiBub3QgYW4gVVAgfCBET1dOIHwgRVNDQVBFIGtleSA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXHJcbiAgICAgIC8vIElmIGlucHV0L3RleHRhcmVhICYmIGlmIGtleSBpcyBvdGhlciB0aGFuIEVTQ0FQRSA9PiBub3QgYSBkcm9wZG93biBjb21tYW5kXHJcblxyXG4gICAgICBjb25zdCBpc0lucHV0ID0gL2lucHV0fHRleHRhcmVhL2kudGVzdChldmVudC50YXJnZXQudGFnTmFtZSk7XHJcbiAgICAgIGNvbnN0IGlzRXNjYXBlRXZlbnQgPSBldmVudC5rZXkgPT09IEVTQ0FQRV9LRVkkMjtcclxuICAgICAgY29uc3QgaXNVcE9yRG93bkV2ZW50ID0gW0FSUk9XX1VQX0tFWSQxLCBBUlJPV19ET1dOX0tFWSQxXS5pbmNsdWRlcyhldmVudC5rZXkpO1xyXG4gICAgICBpZiAoIWlzVXBPckRvd25FdmVudCAmJiAhaXNFc2NhcGVFdmVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNJbnB1dCAmJiAhaXNFc2NhcGVFdmVudCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG5cclxuICAgICAgLy8gVE9ETzogdjYgcmV2ZXJ0ICMzNzAxMSAmIGNoYW5nZSBtYXJrdXAgaHR0cHM6Ly9nZXRib290c3RyYXAuY29tL2RvY3MvNS4zL2Zvcm1zL2lucHV0LWdyb3VwL1xyXG4gICAgICBjb25zdCBnZXRUb2dnbGVCdXR0b24gPSB0aGlzLm1hdGNoZXMoU0VMRUNUT1JfREFUQV9UT0dHTEUkMykgPyB0aGlzIDogU2VsZWN0b3JFbmdpbmUucHJldih0aGlzLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzKVswXSB8fCBTZWxlY3RvckVuZ2luZS5uZXh0KHRoaXMsIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMpWzBdIHx8IFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfREFUQV9UT0dHTEUkMywgZXZlbnQuZGVsZWdhdGVUYXJnZXQucGFyZW50Tm9kZSk7XHJcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gRHJvcGRvd24uZ2V0T3JDcmVhdGVJbnN0YW5jZShnZXRUb2dnbGVCdXR0b24pO1xyXG4gICAgICBpZiAoaXNVcE9yRG93bkV2ZW50KSB7XHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgaW5zdGFuY2Uuc2hvdygpO1xyXG4gICAgICAgIGluc3RhbmNlLl9zZWxlY3RNZW51SXRlbShldmVudCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChpbnN0YW5jZS5faXNTaG93bigpKSB7XHJcbiAgICAgICAgLy8gZWxzZSBpcyBlc2NhcGUgYW5kIHdlIGNoZWNrIGlmIGl0IGlzIHNob3duXHJcbiAgICAgICAgZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgaW5zdGFuY2UuaGlkZSgpO1xyXG4gICAgICAgIGdldFRvZ2dsZUJ1dHRvbi5mb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEYXRhIEFQSSBpbXBsZW1lbnRhdGlvblxyXG4gICAqL1xyXG5cclxuICBFdmVudEhhbmRsZXIub24oZG9jdW1lbnQsIEVWRU5UX0tFWURPV05fREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFJDMsIERyb3Bkb3duLmRhdGFBcGlLZXlkb3duSGFuZGxlcik7XHJcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9LRVlET1dOX0RBVEFfQVBJLCBTRUxFQ1RPUl9NRU5VLCBEcm9wZG93bi5kYXRhQXBpS2V5ZG93bkhhbmRsZXIpO1xyXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEkkMywgRHJvcGRvd24uY2xlYXJNZW51cyk7XHJcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9LRVlVUF9EQVRBX0FQSSwgRHJvcGRvd24uY2xlYXJNZW51cyk7XHJcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQzLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQzLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICBEcm9wZG93bi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpLnRvZ2dsZSgpO1xyXG4gIH0pO1xyXG5cclxuICAvKipcclxuICAgKiBqUXVlcnlcclxuICAgKi9cclxuXHJcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKERyb3Bkb3duKTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgdXRpbC9iYWNrZHJvcC5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcblxyXG5cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgTkFNRSQ5ID0gJ2JhY2tkcm9wJztcclxuICBjb25zdCBDTEFTU19OQU1FX0ZBREUkNCA9ICdmYWRlJztcclxuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckNSA9ICdzaG93JztcclxuICBjb25zdCBFVkVOVF9NT1VTRURPV04gPSBgbW91c2Vkb3duLmJzLiR7TkFNRSQ5fWA7XHJcbiAgY29uc3QgRGVmYXVsdCQ4ID0ge1xyXG4gICAgY2xhc3NOYW1lOiAnbW9kYWwtYmFja2Ryb3AnLFxyXG4gICAgY2xpY2tDYWxsYmFjazogbnVsbCxcclxuICAgIGlzQW5pbWF0ZWQ6IGZhbHNlLFxyXG4gICAgaXNWaXNpYmxlOiB0cnVlLFxyXG4gICAgLy8gaWYgZmFsc2UsIHdlIHVzZSB0aGUgYmFja2Ryb3AgaGVscGVyIHdpdGhvdXQgYWRkaW5nIGFueSBlbGVtZW50IHRvIHRoZSBkb21cclxuICAgIHJvb3RFbGVtZW50OiAnYm9keScgLy8gZ2l2ZSB0aGUgY2hvaWNlIHRvIHBsYWNlIGJhY2tkcm9wIHVuZGVyIGRpZmZlcmVudCBlbGVtZW50c1xyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdFR5cGUkOCA9IHtcclxuICAgIGNsYXNzTmFtZTogJ3N0cmluZycsXHJcbiAgICBjbGlja0NhbGxiYWNrOiAnKGZ1bmN0aW9ufG51bGwpJyxcclxuICAgIGlzQW5pbWF0ZWQ6ICdib29sZWFuJyxcclxuICAgIGlzVmlzaWJsZTogJ2Jvb2xlYW4nLFxyXG4gICAgcm9vdEVsZW1lbnQ6ICcoZWxlbWVudHxzdHJpbmcpJ1xyXG4gIH07XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYXNzIGRlZmluaXRpb25cclxuICAgKi9cclxuXHJcbiAgY2xhc3MgQmFja2Ryb3AgZXh0ZW5kcyBDb25maWcge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xyXG4gICAgICB0aGlzLl9pc0FwcGVuZGVkID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldHRlcnNcclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHQkODtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ4O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgICByZXR1cm4gTkFNRSQ5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFB1YmxpY1xyXG4gICAgc2hvdyhjYWxsYmFjaykge1xyXG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5pc1Zpc2libGUpIHtcclxuICAgICAgICBleGVjdXRlKGNhbGxiYWNrKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fYXBwZW5kKCk7XHJcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSB0aGlzLl9nZXRFbGVtZW50KCk7XHJcbiAgICAgIGlmICh0aGlzLl9jb25maWcuaXNBbmltYXRlZCkge1xyXG4gICAgICAgIHJlZmxvdyhlbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgICBlbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDUpO1xyXG4gICAgICB0aGlzLl9lbXVsYXRlQW5pbWF0aW9uKCgpID0+IHtcclxuICAgICAgICBleGVjdXRlKGNhbGxiYWNrKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgICBoaWRlKGNhbGxiYWNrKSB7XHJcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLmlzVmlzaWJsZSkge1xyXG4gICAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9nZXRFbGVtZW50KCkuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckNSk7XHJcbiAgICAgIHRoaXMuX2VtdWxhdGVBbmltYXRpb24oKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuZGlzcG9zZSgpO1xyXG4gICAgICAgIGV4ZWN1dGUoY2FsbGJhY2spO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgIGlmICghdGhpcy5faXNBcHBlbmRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQsIEVWRU5UX01PVVNFRE9XTik7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlKCk7XHJcbiAgICAgIHRoaXMuX2lzQXBwZW5kZWQgPSBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcml2YXRlXHJcbiAgICBfZ2V0RWxlbWVudCgpIHtcclxuICAgICAgaWYgKCF0aGlzLl9lbGVtZW50KSB7XHJcbiAgICAgICAgY29uc3QgYmFja2Ryb3AgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBiYWNrZHJvcC5jbGFzc05hbWUgPSB0aGlzLl9jb25maWcuY2xhc3NOYW1lO1xyXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcuaXNBbmltYXRlZCkge1xyXG4gICAgICAgICAgYmFja2Ryb3AuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0ZBREUkNCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQgPSBiYWNrZHJvcDtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5fZWxlbWVudDtcclxuICAgIH1cclxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xyXG4gICAgICAvLyB1c2UgZ2V0RWxlbWVudCgpIHdpdGggdGhlIGRlZmF1bHQgXCJib2R5XCIgdG8gZ2V0IGEgZnJlc2ggRWxlbWVudCBvbiBlYWNoIGluc3RhbnRpYXRpb25cclxuICAgICAgY29uZmlnLnJvb3RFbGVtZW50ID0gZ2V0RWxlbWVudChjb25maWcucm9vdEVsZW1lbnQpO1xyXG4gICAgICByZXR1cm4gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgX2FwcGVuZCgpIHtcclxuICAgICAgaWYgKHRoaXMuX2lzQXBwZW5kZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgZWxlbWVudCA9IHRoaXMuX2dldEVsZW1lbnQoKTtcclxuICAgICAgdGhpcy5fY29uZmlnLnJvb3RFbGVtZW50LmFwcGVuZChlbGVtZW50KTtcclxuICAgICAgRXZlbnRIYW5kbGVyLm9uKGVsZW1lbnQsIEVWRU5UX01PVVNFRE9XTiwgKCkgPT4ge1xyXG4gICAgICAgIGV4ZWN1dGUodGhpcy5fY29uZmlnLmNsaWNrQ2FsbGJhY2spO1xyXG4gICAgICB9KTtcclxuICAgICAgdGhpcy5faXNBcHBlbmRlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBfZW11bGF0ZUFuaW1hdGlvbihjYWxsYmFjaykge1xyXG4gICAgICBleGVjdXRlQWZ0ZXJUcmFuc2l0aW9uKGNhbGxiYWNrLCB0aGlzLl9nZXRFbGVtZW50KCksIHRoaXMuX2NvbmZpZy5pc0FuaW1hdGVkKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwIHV0aWwvZm9jdXN0cmFwLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBOQU1FJDggPSAnZm9jdXN0cmFwJztcclxuICBjb25zdCBEQVRBX0tFWSQ1ID0gJ2JzLmZvY3VzdHJhcCc7XHJcbiAgY29uc3QgRVZFTlRfS0VZJDUgPSBgLiR7REFUQV9LRVkkNX1gO1xyXG4gIGNvbnN0IEVWRU5UX0ZPQ1VTSU4kMiA9IGBmb2N1c2luJHtFVkVOVF9LRVkkNX1gO1xyXG4gIGNvbnN0IEVWRU5UX0tFWURPV05fVEFCID0gYGtleWRvd24udGFiJHtFVkVOVF9LRVkkNX1gO1xyXG4gIGNvbnN0IFRBQl9LRVkgPSAnVGFiJztcclxuICBjb25zdCBUQUJfTkFWX0ZPUldBUkQgPSAnZm9yd2FyZCc7XHJcbiAgY29uc3QgVEFCX05BVl9CQUNLV0FSRCA9ICdiYWNrd2FyZCc7XHJcbiAgY29uc3QgRGVmYXVsdCQ3ID0ge1xyXG4gICAgYXV0b2ZvY3VzOiB0cnVlLFxyXG4gICAgdHJhcEVsZW1lbnQ6IG51bGwgLy8gVGhlIGVsZW1lbnQgdG8gdHJhcCBmb2N1cyBpbnNpZGUgb2ZcclxuICB9O1xyXG4gIGNvbnN0IERlZmF1bHRUeXBlJDcgPSB7XHJcbiAgICBhdXRvZm9jdXM6ICdib29sZWFuJyxcclxuICAgIHRyYXBFbGVtZW50OiAnZWxlbWVudCdcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIEZvY3VzVHJhcCBleHRlbmRzIENvbmZpZyB7XHJcbiAgICBjb25zdHJ1Y3Rvcihjb25maWcpIHtcclxuICAgICAgc3VwZXIoKTtcclxuICAgICAgdGhpcy5fY29uZmlnID0gdGhpcy5fZ2V0Q29uZmlnKGNvbmZpZyk7XHJcbiAgICAgIHRoaXMuX2lzQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2xhc3RUYWJOYXZEaXJlY3Rpb24gPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldHRlcnNcclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHQkNztcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ3O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgICByZXR1cm4gTkFNRSQ4O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFB1YmxpY1xyXG4gICAgYWN0aXZhdGUoKSB7XHJcbiAgICAgIGlmICh0aGlzLl9pc0FjdGl2ZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmF1dG9mb2N1cykge1xyXG4gICAgICAgIHRoaXMuX2NvbmZpZy50cmFwRWxlbWVudC5mb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYoZG9jdW1lbnQsIEVWRU5UX0tFWSQ1KTsgLy8gZ3VhcmQgYWdhaW5zdCBpbmZpbml0ZSBmb2N1cyBsb29wXHJcbiAgICAgIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfRk9DVVNJTiQyLCBldmVudCA9PiB0aGlzLl9oYW5kbGVGb2N1c2luKGV2ZW50KSk7XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfS0VZRE9XTl9UQUIsIGV2ZW50ID0+IHRoaXMuX2hhbmRsZUtleWRvd24oZXZlbnQpKTtcclxuICAgICAgdGhpcy5faXNBY3RpdmUgPSB0cnVlO1xyXG4gICAgfVxyXG4gICAgZGVhY3RpdmF0ZSgpIHtcclxuICAgICAgaWYgKCF0aGlzLl9pc0FjdGl2ZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9pc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICBFdmVudEhhbmRsZXIub2ZmKGRvY3VtZW50LCBFVkVOVF9LRVkkNSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJpdmF0ZVxyXG4gICAgX2hhbmRsZUZvY3VzaW4oZXZlbnQpIHtcclxuICAgICAgY29uc3Qge1xyXG4gICAgICAgIHRyYXBFbGVtZW50XHJcbiAgICAgIH0gPSB0aGlzLl9jb25maWc7XHJcbiAgICAgIGlmIChldmVudC50YXJnZXQgPT09IGRvY3VtZW50IHx8IGV2ZW50LnRhcmdldCA9PT0gdHJhcEVsZW1lbnQgfHwgdHJhcEVsZW1lbnQuY29udGFpbnMoZXZlbnQudGFyZ2V0KSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBlbGVtZW50cyA9IFNlbGVjdG9yRW5naW5lLmZvY3VzYWJsZUNoaWxkcmVuKHRyYXBFbGVtZW50KTtcclxuICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIHRyYXBFbGVtZW50LmZvY3VzKCk7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5fbGFzdFRhYk5hdkRpcmVjdGlvbiA9PT0gVEFCX05BVl9CQUNLV0FSRCkge1xyXG4gICAgICAgIGVsZW1lbnRzW2VsZW1lbnRzLmxlbmd0aCAtIDFdLmZvY3VzKCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgZWxlbWVudHNbMF0uZm9jdXMoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2hhbmRsZUtleWRvd24oZXZlbnQpIHtcclxuICAgICAgaWYgKGV2ZW50LmtleSAhPT0gVEFCX0tFWSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9sYXN0VGFiTmF2RGlyZWN0aW9uID0gZXZlbnQuc2hpZnRLZXkgPyBUQUJfTkFWX0JBQ0tXQVJEIDogVEFCX05BVl9GT1JXQVJEO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgdXRpbC9zY3JvbGxCYXIuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IFNFTEVDVE9SX0ZJWEVEX0NPTlRFTlQgPSAnLmZpeGVkLXRvcCwgLmZpeGVkLWJvdHRvbSwgLmlzLWZpeGVkLCAuc3RpY2t5LXRvcCc7XHJcbiAgY29uc3QgU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQgPSAnLnN0aWNreS10b3AnO1xyXG4gIGNvbnN0IFBST1BFUlRZX1BBRERJTkcgPSAncGFkZGluZy1yaWdodCc7XHJcbiAgY29uc3QgUFJPUEVSVFlfTUFSR0lOID0gJ21hcmdpbi1yaWdodCc7XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYXNzIGRlZmluaXRpb25cclxuICAgKi9cclxuXHJcbiAgY2xhc3MgU2Nyb2xsQmFySGVscGVyIHtcclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICB0aGlzLl9lbGVtZW50ID0gZG9jdW1lbnQuYm9keTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQdWJsaWNcclxuICAgIGdldFdpZHRoKCkge1xyXG4gICAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9BUEkvV2luZG93L2lubmVyV2lkdGgjdXNhZ2Vfbm90ZXNcclxuICAgICAgY29uc3QgZG9jdW1lbnRXaWR0aCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aDtcclxuICAgICAgcmV0dXJuIE1hdGguYWJzKHdpbmRvdy5pbm5lcldpZHRoIC0gZG9jdW1lbnRXaWR0aCk7XHJcbiAgICB9XHJcbiAgICBoaWRlKCkge1xyXG4gICAgICBjb25zdCB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcclxuICAgICAgdGhpcy5fZGlzYWJsZU92ZXJGbG93KCk7XHJcbiAgICAgIC8vIGdpdmUgcGFkZGluZyB0byBlbGVtZW50IHRvIGJhbGFuY2UgdGhlIGhpZGRlbiBzY3JvbGxiYXIgd2lkdGhcclxuICAgICAgdGhpcy5fc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgUFJPUEVSVFlfUEFERElORywgY2FsY3VsYXRlZFZhbHVlID0+IGNhbGN1bGF0ZWRWYWx1ZSArIHdpZHRoKTtcclxuICAgICAgLy8gdHJpY2s6IFdlIGFkanVzdCBwb3NpdGl2ZSBwYWRkaW5nUmlnaHQgYW5kIG5lZ2F0aXZlIG1hcmdpblJpZ2h0IHRvIHN0aWNreS10b3AgZWxlbWVudHMgdG8ga2VlcCBzaG93aW5nIGZ1bGx3aWR0aFxyXG4gICAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9GSVhFRF9DT05URU5ULCBQUk9QRVJUWV9QQURESU5HLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlICsgd2lkdGgpO1xyXG4gICAgICB0aGlzLl9zZXRFbGVtZW50QXR0cmlidXRlcyhTRUxFQ1RPUl9TVElDS1lfQ09OVEVOVCwgUFJPUEVSVFlfTUFSR0lOLCBjYWxjdWxhdGVkVmFsdWUgPT4gY2FsY3VsYXRlZFZhbHVlIC0gd2lkdGgpO1xyXG4gICAgfVxyXG4gICAgcmVzZXQoKSB7XHJcbiAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgJ292ZXJmbG93Jyk7XHJcbiAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXModGhpcy5fZWxlbWVudCwgUFJPUEVSVFlfUEFERElORyk7XHJcbiAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfRklYRURfQ09OVEVOVCwgUFJPUEVSVFlfUEFERElORyk7XHJcbiAgICAgIHRoaXMuX3Jlc2V0RWxlbWVudEF0dHJpYnV0ZXMoU0VMRUNUT1JfU1RJQ0tZX0NPTlRFTlQsIFBST1BFUlRZX01BUkdJTik7XHJcbiAgICB9XHJcbiAgICBpc092ZXJmbG93aW5nKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5nZXRXaWR0aCgpID4gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcml2YXRlXHJcbiAgICBfZGlzYWJsZU92ZXJGbG93KCkge1xyXG4gICAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZSh0aGlzLl9lbGVtZW50LCAnb3ZlcmZsb3cnKTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5vdmVyZmxvdyA9ICdoaWRkZW4nO1xyXG4gICAgfVxyXG4gICAgX3NldEVsZW1lbnRBdHRyaWJ1dGVzKHNlbGVjdG9yLCBzdHlsZVByb3BlcnR5LCBjYWxsYmFjaykge1xyXG4gICAgICBjb25zdCBzY3JvbGxiYXJXaWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcclxuICAgICAgY29uc3QgbWFuaXB1bGF0aW9uQ2FsbEJhY2sgPSBlbGVtZW50ID0+IHtcclxuICAgICAgICBpZiAoZWxlbWVudCAhPT0gdGhpcy5fZWxlbWVudCAmJiB3aW5kb3cuaW5uZXJXaWR0aCA+IGVsZW1lbnQuY2xpZW50V2lkdGggKyBzY3JvbGxiYXJXaWR0aCkge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl9zYXZlSW5pdGlhbEF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5KTtcclxuICAgICAgICBjb25zdCBjYWxjdWxhdGVkVmFsdWUgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5nZXRQcm9wZXJ0eVZhbHVlKHN0eWxlUHJvcGVydHkpO1xyXG4gICAgICAgIGVsZW1lbnQuc3R5bGUuc2V0UHJvcGVydHkoc3R5bGVQcm9wZXJ0eSwgYCR7Y2FsbGJhY2soTnVtYmVyLnBhcnNlRmxvYXQoY2FsY3VsYXRlZFZhbHVlKSl9cHhgKTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayhzZWxlY3RvciwgbWFuaXB1bGF0aW9uQ2FsbEJhY2spO1xyXG4gICAgfVxyXG4gICAgX3NhdmVJbml0aWFsQXR0cmlidXRlKGVsZW1lbnQsIHN0eWxlUHJvcGVydHkpIHtcclxuICAgICAgY29uc3QgYWN0dWFsVmFsdWUgPSBlbGVtZW50LnN0eWxlLmdldFByb3BlcnR5VmFsdWUoc3R5bGVQcm9wZXJ0eSk7XHJcbiAgICAgIGlmIChhY3R1YWxWYWx1ZSkge1xyXG4gICAgICAgIE1hbmlwdWxhdG9yLnNldERhdGFBdHRyaWJ1dGUoZWxlbWVudCwgc3R5bGVQcm9wZXJ0eSwgYWN0dWFsVmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfcmVzZXRFbGVtZW50QXR0cmlidXRlcyhzZWxlY3Rvciwgc3R5bGVQcm9wZXJ0eSkge1xyXG4gICAgICBjb25zdCBtYW5pcHVsYXRpb25DYWxsQmFjayA9IGVsZW1lbnQgPT4ge1xyXG4gICAgICAgIGNvbnN0IHZhbHVlID0gTWFuaXB1bGF0b3IuZ2V0RGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5KTtcclxuICAgICAgICAvLyBXZSBvbmx5IHdhbnQgdG8gcmVtb3ZlIHRoZSBwcm9wZXJ0eSBpZiB0aGUgdmFsdWUgaXMgYG51bGxgOyB0aGUgdmFsdWUgY2FuIGFsc28gYmUgemVyb1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xyXG4gICAgICAgICAgZWxlbWVudC5zdHlsZS5yZW1vdmVQcm9wZXJ0eShzdHlsZVByb3BlcnR5KTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgTWFuaXB1bGF0b3IucmVtb3ZlRGF0YUF0dHJpYnV0ZShlbGVtZW50LCBzdHlsZVByb3BlcnR5KTtcclxuICAgICAgICBlbGVtZW50LnN0eWxlLnNldFByb3BlcnR5KHN0eWxlUHJvcGVydHksIHZhbHVlKTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5fYXBwbHlNYW5pcHVsYXRpb25DYWxsYmFjayhzZWxlY3RvciwgbWFuaXB1bGF0aW9uQ2FsbEJhY2spO1xyXG4gICAgfVxyXG4gICAgX2FwcGx5TWFuaXB1bGF0aW9uQ2FsbGJhY2soc2VsZWN0b3IsIGNhbGxCYWNrKSB7XHJcbiAgICAgIGlmIChpc0VsZW1lbnQkMShzZWxlY3RvcikpIHtcclxuICAgICAgICBjYWxsQmFjayhzZWxlY3Rvcik7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAoY29uc3Qgc2VsIG9mIFNlbGVjdG9yRW5naW5lLmZpbmQoc2VsZWN0b3IsIHRoaXMuX2VsZW1lbnQpKSB7XHJcbiAgICAgICAgY2FsbEJhY2soc2VsKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgbW9kYWwuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE5BTUUkNyA9ICdtb2RhbCc7XHJcbiAgY29uc3QgREFUQV9LRVkkNCA9ICdicy5tb2RhbCc7XHJcbiAgY29uc3QgRVZFTlRfS0VZJDQgPSBgLiR7REFUQV9LRVkkNH1gO1xyXG4gIGNvbnN0IERBVEFfQVBJX0tFWSQyID0gJy5kYXRhLWFwaSc7XHJcbiAgY29uc3QgRVNDQVBFX0tFWSQxID0gJ0VzY2FwZSc7XHJcbiAgY29uc3QgRVZFTlRfSElERSQ0ID0gYGhpZGUke0VWRU5UX0tFWSQ0fWA7XHJcbiAgY29uc3QgRVZFTlRfSElERV9QUkVWRU5URUQkMSA9IGBoaWRlUHJldmVudGVkJHtFVkVOVF9LRVkkNH1gO1xyXG4gIGNvbnN0IEVWRU5UX0hJRERFTiQ0ID0gYGhpZGRlbiR7RVZFTlRfS0VZJDR9YDtcclxuICBjb25zdCBFVkVOVF9TSE9XJDQgPSBgc2hvdyR7RVZFTlRfS0VZJDR9YDtcclxuICBjb25zdCBFVkVOVF9TSE9XTiQ0ID0gYHNob3duJHtFVkVOVF9LRVkkNH1gO1xyXG4gIGNvbnN0IEVWRU5UX1JFU0laRSQxID0gYHJlc2l6ZSR7RVZFTlRfS0VZJDR9YDtcclxuICBjb25zdCBFVkVOVF9DTElDS19ESVNNSVNTID0gYGNsaWNrLmRpc21pc3Mke0VWRU5UX0tFWSQ0fWA7XHJcbiAgY29uc3QgRVZFTlRfTU9VU0VET1dOX0RJU01JU1MgPSBgbW91c2Vkb3duLmRpc21pc3Mke0VWRU5UX0tFWSQ0fWA7XHJcbiAgY29uc3QgRVZFTlRfS0VZRE9XTl9ESVNNSVNTJDEgPSBga2V5ZG93bi5kaXNtaXNzJHtFVkVOVF9LRVkkNH1gO1xyXG4gIGNvbnN0IEVWRU5UX0NMSUNLX0RBVEFfQVBJJDIgPSBgY2xpY2ske0VWRU5UX0tFWSQ0fSR7REFUQV9BUElfS0VZJDJ9YDtcclxuICBjb25zdCBDTEFTU19OQU1FX09QRU4gPSAnbW9kYWwtb3Blbic7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9GQURFJDMgPSAnZmFkZSc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDQgPSAnc2hvdyc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9TVEFUSUMgPSAnbW9kYWwtc3RhdGljJztcclxuICBjb25zdCBPUEVOX1NFTEVDVE9SJDEgPSAnLm1vZGFsLnNob3cnO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0RJQUxPRyA9ICcubW9kYWwtZGlhbG9nJztcclxuICBjb25zdCBTRUxFQ1RPUl9NT0RBTF9CT0RZID0gJy5tb2RhbC1ib2R5JztcclxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQyID0gJ1tkYXRhLWJzLXRvZ2dsZT1cIm1vZGFsXCJdJztcclxuICBjb25zdCBEZWZhdWx0JDYgPSB7XHJcbiAgICBiYWNrZHJvcDogdHJ1ZSxcclxuICAgIGZvY3VzOiB0cnVlLFxyXG4gICAga2V5Ym9hcmQ6IHRydWVcclxuICB9O1xyXG4gIGNvbnN0IERlZmF1bHRUeXBlJDYgPSB7XHJcbiAgICBiYWNrZHJvcDogJyhib29sZWFufHN0cmluZyknLFxyXG4gICAgZm9jdXM6ICdib29sZWFuJyxcclxuICAgIGtleWJvYXJkOiAnYm9vbGVhbidcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIE1vZGFsIGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcclxuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcclxuICAgICAgdGhpcy5fZGlhbG9nID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9ESUFMT0csIHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgICB0aGlzLl9iYWNrZHJvcCA9IHRoaXMuX2luaXRpYWxpemVCYWNrRHJvcCgpO1xyXG4gICAgICB0aGlzLl9mb2N1c3RyYXAgPSB0aGlzLl9pbml0aWFsaXplRm9jdXNUcmFwKCk7XHJcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcclxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX3Njcm9sbEJhciA9IG5ldyBTY3JvbGxCYXJIZWxwZXIoKTtcclxuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXR0ZXJzXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0JDY7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkNjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcclxuICAgICAgcmV0dXJuIE5BTUUkNztcclxuICAgIH1cclxuXHJcbiAgICAvLyBQdWJsaWNcclxuICAgIHRvZ2dsZShyZWxhdGVkVGFyZ2V0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3cocmVsYXRlZFRhcmdldCk7XHJcbiAgICB9XHJcbiAgICBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcclxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24gfHwgdGhpcy5faXNUcmFuc2l0aW9uaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1ckNCwge1xyXG4gICAgICAgIHJlbGF0ZWRUYXJnZXRcclxuICAgICAgfSk7XHJcbiAgICAgIGlmIChzaG93RXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9pc1Nob3duID0gdHJ1ZTtcclxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcclxuICAgICAgdGhpcy5fc2Nyb2xsQmFyLmhpZGUoKTtcclxuICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfT1BFTik7XHJcbiAgICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xyXG4gICAgICB0aGlzLl9iYWNrZHJvcC5zaG93KCgpID0+IHRoaXMuX3Nob3dFbGVtZW50KHJlbGF0ZWRUYXJnZXQpKTtcclxuICAgIH1cclxuICAgIGhpZGUoKSB7XHJcbiAgICAgIGlmICghdGhpcy5faXNTaG93biB8fCB0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQ0KTtcclxuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2lzU2hvd24gPSBmYWxzZTtcclxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gdHJ1ZTtcclxuICAgICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQ0KTtcclxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB0aGlzLl9oaWRlTW9kYWwoKSwgdGhpcy5fZWxlbWVudCwgdGhpcy5faXNBbmltYXRlZCgpKTtcclxuICAgIH1cclxuICAgIGRpc3Bvc2UoKSB7XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYod2luZG93LCBFVkVOVF9LRVkkNCk7XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vZmYodGhpcy5fZGlhbG9nLCBFVkVOVF9LRVkkNCk7XHJcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmRpc3Bvc2UoKTtcclxuICAgICAgdGhpcy5fZm9jdXN0cmFwLmRlYWN0aXZhdGUoKTtcclxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG4gICAgaGFuZGxlVXBkYXRlKCkge1xyXG4gICAgICB0aGlzLl9hZGp1c3REaWFsb2coKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcml2YXRlXHJcbiAgICBfaW5pdGlhbGl6ZUJhY2tEcm9wKCkge1xyXG4gICAgICByZXR1cm4gbmV3IEJhY2tkcm9wKHtcclxuICAgICAgICBpc1Zpc2libGU6IEJvb2xlYW4odGhpcy5fY29uZmlnLmJhY2tkcm9wKSxcclxuICAgICAgICAvLyAnc3RhdGljJyBvcHRpb24gd2lsbCBiZSB0cmFuc2xhdGVkIHRvIHRydWUsIGFuZCBib29sZWFucyB3aWxsIGtlZXAgdGhlaXIgdmFsdWUsXHJcbiAgICAgICAgaXNBbmltYXRlZDogdGhpcy5faXNBbmltYXRlZCgpXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2luaXRpYWxpemVGb2N1c1RyYXAoKSB7XHJcbiAgICAgIHJldHVybiBuZXcgRm9jdXNUcmFwKHtcclxuICAgICAgICB0cmFwRWxlbWVudDogdGhpcy5fZWxlbWVudFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIF9zaG93RWxlbWVudChyZWxhdGVkVGFyZ2V0KSB7XHJcbiAgICAgIC8vIHRyeSB0byBhcHBlbmQgZHluYW1pYyBtb2RhbFxyXG4gICAgICBpZiAoIWRvY3VtZW50LmJvZHkuY29udGFpbnModGhpcy5fZWxlbWVudCkpIHtcclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZCh0aGlzLl9lbGVtZW50KTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLmRpc3BsYXkgPSAnYmxvY2snO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nKTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCB0cnVlKTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZGlhbG9nJyk7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuc2Nyb2xsVG9wID0gMDtcclxuICAgICAgY29uc3QgbW9kYWxCb2R5ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShTRUxFQ1RPUl9NT0RBTF9CT0RZLCB0aGlzLl9kaWFsb2cpO1xyXG4gICAgICBpZiAobW9kYWxCb2R5KSB7XHJcbiAgICAgICAgbW9kYWxCb2R5LnNjcm9sbFRvcCA9IDA7XHJcbiAgICAgIH1cclxuICAgICAgcmVmbG93KHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDQpO1xyXG4gICAgICBjb25zdCB0cmFuc2l0aW9uQ29tcGxldGUgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5mb2N1cykge1xyXG4gICAgICAgICAgdGhpcy5fZm9jdXN0cmFwLmFjdGl2YXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2lzVHJhbnNpdGlvbmluZyA9IGZhbHNlO1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1dOJDQsIHtcclxuICAgICAgICAgIHJlbGF0ZWRUYXJnZXRcclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayh0cmFuc2l0aW9uQ29tcGxldGUsIHRoaXMuX2RpYWxvZywgdGhpcy5faXNBbmltYXRlZCgpKTtcclxuICAgIH1cclxuICAgIF9hZGRFdmVudExpc3RlbmVycygpIHtcclxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV05fRElTTUlTUyQxLCBldmVudCA9PiB7XHJcbiAgICAgICAgaWYgKGV2ZW50LmtleSAhPT0gRVNDQVBFX0tFWSQxKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcua2V5Ym9hcmQpIHtcclxuICAgICAgICAgIHRoaXMuaGlkZSgpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgICBFdmVudEhhbmRsZXIub24od2luZG93LCBFVkVOVF9SRVNJWkUkMSwgKCkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9pc1Nob3duICYmICF0aGlzLl9pc1RyYW5zaXRpb25pbmcpIHtcclxuICAgICAgICAgIHRoaXMuX2FkanVzdERpYWxvZygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRURPV05fRElTTUlTUywgZXZlbnQgPT4ge1xyXG4gICAgICAgIC8vIGEgYmFkIHRyaWNrIHRvIHNlZ3JlZ2F0ZSBjbGlja3MgdGhhdCBtYXkgc3RhcnQgaW5zaWRlIGRpYWxvZyBidXQgZW5kIG91dHNpZGUsIGFuZCBhdm9pZCBsaXN0ZW4gdG8gc2Nyb2xsYmFyIGNsaWNrc1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci5vbmUodGhpcy5fZWxlbWVudCwgRVZFTlRfQ0xJQ0tfRElTTUlTUywgZXZlbnQyID0+IHtcclxuICAgICAgICAgIGlmICh0aGlzLl9lbGVtZW50ICE9PSBldmVudC50YXJnZXQgfHwgdGhpcy5fZWxlbWVudCAhPT0gZXZlbnQyLnRhcmdldCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAnc3RhdGljJykge1xyXG4gICAgICAgICAgICB0aGlzLl90cmlnZ2VyQmFja2Ryb3BUcmFuc2l0aW9uKCk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0aGlzLl9jb25maWcuYmFja2Ryb3ApIHtcclxuICAgICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2hpZGVNb2RhbCgpIHtcclxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCB0cnVlKTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnKTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3JvbGUnKTtcclxuICAgICAgdGhpcy5faXNUcmFuc2l0aW9uaW5nID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmhpZGUoKCkgPT4ge1xyXG4gICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX09QRU4pO1xyXG4gICAgICAgIHRoaXMuX3Jlc2V0QWRqdXN0bWVudHMoKTtcclxuICAgICAgICB0aGlzLl9zY3JvbGxCYXIucmVzZXQoKTtcclxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURERU4kNCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2lzQW5pbWF0ZWQoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMyk7XHJcbiAgICB9XHJcbiAgICBfdHJpZ2dlckJhY2tkcm9wVHJhbnNpdGlvbigpIHtcclxuICAgICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERV9QUkVWRU5URUQkMSk7XHJcbiAgICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBpc01vZGFsT3ZlcmZsb3dpbmcgPSB0aGlzLl9lbGVtZW50LnNjcm9sbEhlaWdodCA+IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgIGNvbnN0IGluaXRpYWxPdmVyZmxvd1kgPSB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WTtcclxuICAgICAgLy8gcmV0dXJuIGlmIHRoZSBmb2xsb3dpbmcgYmFja2dyb3VuZCB0cmFuc2l0aW9uIGhhc24ndCB5ZXQgY29tcGxldGVkXHJcbiAgICAgIGlmIChpbml0aWFsT3ZlcmZsb3dZID09PSAnaGlkZGVuJyB8fCB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NUQVRJQykpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKCFpc01vZGFsT3ZlcmZsb3dpbmcpIHtcclxuICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9ICdoaWRkZW4nO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NUQVRJQyk7XHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NUQVRJQyk7XHJcbiAgICAgICAgdGhpcy5fcXVldWVDYWxsYmFjaygoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9IGluaXRpYWxPdmVyZmxvd1k7XHJcbiAgICAgICAgfSwgdGhpcy5fZGlhbG9nKTtcclxuICAgICAgfSwgdGhpcy5fZGlhbG9nKTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5mb2N1cygpO1xyXG4gICAgfVxyXG5cclxuICAgIC8qKlxyXG4gICAgICogVGhlIGZvbGxvd2luZyBtZXRob2RzIGFyZSB1c2VkIHRvIGhhbmRsZSBvdmVyZmxvd2luZyBtb2RhbHNcclxuICAgICAqL1xyXG5cclxuICAgIF9hZGp1c3REaWFsb2coKSB7XHJcbiAgICAgIGNvbnN0IGlzTW9kYWxPdmVyZmxvd2luZyA9IHRoaXMuX2VsZW1lbnQuc2Nyb2xsSGVpZ2h0ID4gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmNsaWVudEhlaWdodDtcclxuICAgICAgY29uc3Qgc2Nyb2xsYmFyV2lkdGggPSB0aGlzLl9zY3JvbGxCYXIuZ2V0V2lkdGgoKTtcclxuICAgICAgY29uc3QgaXNCb2R5T3ZlcmZsb3dpbmcgPSBzY3JvbGxiYXJXaWR0aCA+IDA7XHJcbiAgICAgIGlmIChpc0JvZHlPdmVyZmxvd2luZyAmJiAhaXNNb2RhbE92ZXJmbG93aW5nKSB7XHJcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBpc1JUTCgpID8gJ3BhZGRpbmdMZWZ0JyA6ICdwYWRkaW5nUmlnaHQnO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbcHJvcGVydHldID0gYCR7c2Nyb2xsYmFyV2lkdGh9cHhgO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghaXNCb2R5T3ZlcmZsb3dpbmcgJiYgaXNNb2RhbE92ZXJmbG93aW5nKSB7XHJcbiAgICAgICAgY29uc3QgcHJvcGVydHkgPSBpc1JUTCgpID8gJ3BhZGRpbmdSaWdodCcgOiAncGFkZGluZ0xlZnQnO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc3R5bGVbcHJvcGVydHldID0gYCR7c2Nyb2xsYmFyV2lkdGh9cHhgO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfcmVzZXRBZGp1c3RtZW50cygpIHtcclxuICAgICAgdGhpcy5fZWxlbWVudC5zdHlsZS5wYWRkaW5nTGVmdCA9ICcnO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnN0eWxlLnBhZGRpbmdSaWdodCA9ICcnO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0YXRpY1xyXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcsIHJlbGF0ZWRUYXJnZXQpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IE1vZGFsLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhW2NvbmZpZ10ocmVsYXRlZFRhcmdldCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cclxuICAgKi9cclxuXHJcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQyLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQyLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcyk7XHJcbiAgICBpZiAoWydBJywgJ0FSRUEnXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpKSB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbiAgICBFdmVudEhhbmRsZXIub25lKHRhcmdldCwgRVZFTlRfU0hPVyQ0LCBzaG93RXZlbnQgPT4ge1xyXG4gICAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICAvLyBvbmx5IHJlZ2lzdGVyIGZvY3VzIHJlc3RvcmVyIGlmIG1vZGFsIHdpbGwgYWN0dWFsbHkgZ2V0IHNob3duXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vbmUodGFyZ2V0LCBFVkVOVF9ISURERU4kNCwgKCkgPT4ge1xyXG4gICAgICAgIGlmIChpc1Zpc2libGUodGhpcykpIHtcclxuICAgICAgICAgIHRoaXMuZm9jdXMoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gYXZvaWQgY29uZmxpY3Qgd2hlbiBjbGlja2luZyBtb2RhbCB0b2dnbGVyIHdoaWxlIGFub3RoZXIgb25lIGlzIG9wZW5cclxuICAgIGNvbnN0IGFscmVhZHlPcGVuID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShPUEVOX1NFTEVDVE9SJDEpO1xyXG4gICAgaWYgKGFscmVhZHlPcGVuKSB7XHJcbiAgICAgIE1vZGFsLmdldEluc3RhbmNlKGFscmVhZHlPcGVuKS5oaWRlKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXRhID0gTW9kYWwuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0YXJnZXQpO1xyXG4gICAgZGF0YS50b2dnbGUodGhpcyk7XHJcbiAgfSk7XHJcbiAgZW5hYmxlRGlzbWlzc1RyaWdnZXIoTW9kYWwpO1xyXG5cclxuICAvKipcclxuICAgKiBqUXVlcnlcclxuICAgKi9cclxuXHJcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKE1vZGFsKTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgb2ZmY2FudmFzLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBOQU1FJDYgPSAnb2ZmY2FudmFzJztcclxuICBjb25zdCBEQVRBX0tFWSQzID0gJ2JzLm9mZmNhbnZhcyc7XHJcbiAgY29uc3QgRVZFTlRfS0VZJDMgPSBgLiR7REFUQV9LRVkkM31gO1xyXG4gIGNvbnN0IERBVEFfQVBJX0tFWSQxID0gJy5kYXRhLWFwaSc7XHJcbiAgY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSQyID0gYGxvYWQke0VWRU5UX0tFWSQzfSR7REFUQV9BUElfS0VZJDF9YDtcclxuICBjb25zdCBFU0NBUEVfS0VZID0gJ0VzY2FwZSc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XJDMgPSAnc2hvdyc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XSU5HJDEgPSAnc2hvd2luZyc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9ISURJTkcgPSAnaGlkaW5nJztcclxuICBjb25zdCBDTEFTU19OQU1FX0JBQ0tEUk9QID0gJ29mZmNhbnZhcy1iYWNrZHJvcCc7XHJcbiAgY29uc3QgT1BFTl9TRUxFQ1RPUiA9ICcub2ZmY2FudmFzLnNob3cnO1xyXG4gIGNvbnN0IEVWRU5UX1NIT1ckMyA9IGBzaG93JHtFVkVOVF9LRVkkM31gO1xyXG4gIGNvbnN0IEVWRU5UX1NIT1dOJDMgPSBgc2hvd24ke0VWRU5UX0tFWSQzfWA7XHJcbiAgY29uc3QgRVZFTlRfSElERSQzID0gYGhpZGUke0VWRU5UX0tFWSQzfWA7XHJcbiAgY29uc3QgRVZFTlRfSElERV9QUkVWRU5URUQgPSBgaGlkZVByZXZlbnRlZCR7RVZFTlRfS0VZJDN9YDtcclxuICBjb25zdCBFVkVOVF9ISURERU4kMyA9IGBoaWRkZW4ke0VWRU5UX0tFWSQzfWA7XHJcbiAgY29uc3QgRVZFTlRfUkVTSVpFID0gYHJlc2l6ZSR7RVZFTlRfS0VZJDN9YDtcclxuICBjb25zdCBFVkVOVF9DTElDS19EQVRBX0FQSSQxID0gYGNsaWNrJHtFVkVOVF9LRVkkM30ke0RBVEFfQVBJX0tFWSQxfWA7XHJcbiAgY29uc3QgRVZFTlRfS0VZRE9XTl9ESVNNSVNTID0gYGtleWRvd24uZGlzbWlzcyR7RVZFTlRfS0VZJDN9YDtcclxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxID0gJ1tkYXRhLWJzLXRvZ2dsZT1cIm9mZmNhbnZhc1wiXSc7XHJcbiAgY29uc3QgRGVmYXVsdCQ1ID0ge1xyXG4gICAgYmFja2Ryb3A6IHRydWUsXHJcbiAgICBrZXlib2FyZDogdHJ1ZSxcclxuICAgIHNjcm9sbDogZmFsc2VcclxuICB9O1xyXG4gIGNvbnN0IERlZmF1bHRUeXBlJDUgPSB7XHJcbiAgICBiYWNrZHJvcDogJyhib29sZWFufHN0cmluZyknLFxyXG4gICAga2V5Ym9hcmQ6ICdib29sZWFuJyxcclxuICAgIHNjcm9sbDogJ2Jvb2xlYW4nXHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBPZmZjYW52YXMgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xyXG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xyXG4gICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2JhY2tkcm9wID0gdGhpcy5faW5pdGlhbGl6ZUJhY2tEcm9wKCk7XHJcbiAgICAgIHRoaXMuX2ZvY3VzdHJhcCA9IHRoaXMuX2luaXRpYWxpemVGb2N1c1RyYXAoKTtcclxuICAgICAgdGhpcy5fYWRkRXZlbnRMaXN0ZW5lcnMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXR0ZXJzXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0JDU7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkNTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcclxuICAgICAgcmV0dXJuIE5BTUUkNjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQdWJsaWNcclxuICAgIHRvZ2dsZShyZWxhdGVkVGFyZ2V0KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9pc1Nob3duID8gdGhpcy5oaWRlKCkgOiB0aGlzLnNob3cocmVsYXRlZFRhcmdldCk7XHJcbiAgICB9XHJcbiAgICBzaG93KHJlbGF0ZWRUYXJnZXQpIHtcclxuICAgICAgaWYgKHRoaXMuX2lzU2hvd24pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc2hvd0V2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPVyQzLCB7XHJcbiAgICAgICAgcmVsYXRlZFRhcmdldFxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2lzU2hvd24gPSB0cnVlO1xyXG4gICAgICB0aGlzLl9iYWNrZHJvcC5zaG93KCk7XHJcbiAgICAgIGlmICghdGhpcy5fY29uZmlnLnNjcm9sbCkge1xyXG4gICAgICAgIG5ldyBTY3JvbGxCYXJIZWxwZXIoKS5oaWRlKCk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbW9kYWwnLCB0cnVlKTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JvbGUnLCAnZGlhbG9nJyk7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1dJTkckMSk7XHJcbiAgICAgIGNvbnN0IGNvbXBsZXRlQ2FsbEJhY2sgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9jb25maWcuc2Nyb2xsIHx8IHRoaXMuX2NvbmZpZy5iYWNrZHJvcCkge1xyXG4gICAgICAgICAgdGhpcy5fZm9jdXN0cmFwLmFjdGl2YXRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1ckMyk7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORyQxKTtcclxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9TSE9XTiQzLCB7XHJcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGVDYWxsQmFjaywgdGhpcy5fZWxlbWVudCwgdHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBoaWRlKCkge1xyXG4gICAgICBpZiAoIXRoaXMuX2lzU2hvd24pIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERSQzKTtcclxuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2ZvY3VzdHJhcC5kZWFjdGl2YXRlKCk7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuYmx1cigpO1xyXG4gICAgICB0aGlzLl9pc1Nob3duID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0hJRElORyk7XHJcbiAgICAgIHRoaXMuX2JhY2tkcm9wLmhpZGUoKTtcclxuICAgICAgY29uc3QgY29tcGxldGVDYWxsYmFjayA9ICgpID0+IHtcclxuICAgICAgICB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9TSE9XJDMsIENMQVNTX05BTUVfSElESU5HKTtcclxuICAgICAgICB0aGlzLl9lbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgnYXJpYS1tb2RhbCcpO1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdyb2xlJyk7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9jb25maWcuc2Nyb2xsKSB7XHJcbiAgICAgICAgICBuZXcgU2Nyb2xsQmFySGVscGVyKCkucmVzZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOJDMpO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlQ2FsbGJhY2ssIHRoaXMuX2VsZW1lbnQsIHRydWUpO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgdGhpcy5fYmFja2Ryb3AuZGlzcG9zZSgpO1xyXG4gICAgICB0aGlzLl9mb2N1c3RyYXAuZGVhY3RpdmF0ZSgpO1xyXG4gICAgICBzdXBlci5kaXNwb3NlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJpdmF0ZVxyXG4gICAgX2luaXRpYWxpemVCYWNrRHJvcCgpIHtcclxuICAgICAgY29uc3QgY2xpY2tDYWxsYmFjayA9ICgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5fY29uZmlnLmJhY2tkcm9wID09PSAnc3RhdGljJykge1xyXG4gICAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElERV9QUkVWRU5URUQpO1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vICdzdGF0aWMnIG9wdGlvbiB3aWxsIGJlIHRyYW5zbGF0ZWQgdG8gdHJ1ZSwgYW5kIGJvb2xlYW5zIHdpbGwga2VlcCB0aGVpciB2YWx1ZVxyXG4gICAgICBjb25zdCBpc1Zpc2libGUgPSBCb29sZWFuKHRoaXMuX2NvbmZpZy5iYWNrZHJvcCk7XHJcbiAgICAgIHJldHVybiBuZXcgQmFja2Ryb3Aoe1xyXG4gICAgICAgIGNsYXNzTmFtZTogQ0xBU1NfTkFNRV9CQUNLRFJPUCxcclxuICAgICAgICBpc1Zpc2libGUsXHJcbiAgICAgICAgaXNBbmltYXRlZDogdHJ1ZSxcclxuICAgICAgICByb290RWxlbWVudDogdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLFxyXG4gICAgICAgIGNsaWNrQ2FsbGJhY2s6IGlzVmlzaWJsZSA/IGNsaWNrQ2FsbGJhY2sgOiBudWxsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gICAgX2luaXRpYWxpemVGb2N1c1RyYXAoKSB7XHJcbiAgICAgIHJldHVybiBuZXcgRm9jdXNUcmFwKHtcclxuICAgICAgICB0cmFwRWxlbWVudDogdGhpcy5fZWxlbWVudFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIF9hZGRFdmVudExpc3RlbmVycygpIHtcclxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV05fRElTTUlTUywgZXZlbnQgPT4ge1xyXG4gICAgICAgIGlmIChldmVudC5rZXkgIT09IEVTQ0FQRV9LRVkpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2NvbmZpZy5rZXlib2FyZCkge1xyXG4gICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0hJREVfUFJFVkVOVEVEKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RhdGljXHJcbiAgICBzdGF0aWMgalF1ZXJ5SW50ZXJmYWNlKGNvbmZpZykge1xyXG4gICAgICByZXR1cm4gdGhpcy5lYWNoKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBjb25zdCBkYXRhID0gT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGRhdGFbY29uZmlnXSA9PT0gdW5kZWZpbmVkIHx8IGNvbmZpZy5zdGFydHNXaXRoKCdfJykgfHwgY29uZmlnID09PSAnY29uc3RydWN0b3InKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhW2NvbmZpZ10odGhpcyk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cclxuICAgKi9cclxuXHJcbiAgRXZlbnRIYW5kbGVyLm9uKGRvY3VtZW50LCBFVkVOVF9DTElDS19EQVRBX0FQSSQxLCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSQxLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIGNvbnN0IHRhcmdldCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IodGhpcyk7XHJcbiAgICBpZiAoWydBJywgJ0FSRUEnXS5pbmNsdWRlcyh0aGlzLnRhZ05hbWUpKSB7XHJcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICB9XHJcbiAgICBpZiAoaXNEaXNhYmxlZCh0aGlzKSkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBFdmVudEhhbmRsZXIub25lKHRhcmdldCwgRVZFTlRfSElEREVOJDMsICgpID0+IHtcclxuICAgICAgLy8gZm9jdXMgb24gdHJpZ2dlciB3aGVuIGl0IGlzIGNsb3NlZFxyXG4gICAgICBpZiAoaXNWaXNpYmxlKHRoaXMpKSB7XHJcbiAgICAgICAgdGhpcy5mb2N1cygpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBhdm9pZCBjb25mbGljdCB3aGVuIGNsaWNraW5nIGEgdG9nZ2xlciBvZiBhbiBvZmZjYW52YXMsIHdoaWxlIGFub3RoZXIgaXMgb3BlblxyXG4gICAgY29uc3QgYWxyZWFkeU9wZW4gPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKE9QRU5fU0VMRUNUT1IpO1xyXG4gICAgaWYgKGFscmVhZHlPcGVuICYmIGFscmVhZHlPcGVuICE9PSB0YXJnZXQpIHtcclxuICAgICAgT2ZmY2FudmFzLmdldEluc3RhbmNlKGFscmVhZHlPcGVuKS5oaWRlKCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkYXRhID0gT2ZmY2FudmFzLmdldE9yQ3JlYXRlSW5zdGFuY2UodGFyZ2V0KTtcclxuICAgIGRhdGEudG9nZ2xlKHRoaXMpO1xyXG4gIH0pO1xyXG4gIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEkkMiwgKCkgPT4ge1xyXG4gICAgZm9yIChjb25zdCBzZWxlY3RvciBvZiBTZWxlY3RvckVuZ2luZS5maW5kKE9QRU5fU0VMRUNUT1IpKSB7XHJcbiAgICAgIE9mZmNhbnZhcy5nZXRPckNyZWF0ZUluc3RhbmNlKHNlbGVjdG9yKS5zaG93KCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgRXZlbnRIYW5kbGVyLm9uKHdpbmRvdywgRVZFTlRfUkVTSVpFLCAoKSA9PiB7XHJcbiAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgU2VsZWN0b3JFbmdpbmUuZmluZCgnW2FyaWEtbW9kYWxdW2NsYXNzKj1zaG93XVtjbGFzcyo9b2ZmY2FudmFzLV0nKSkge1xyXG4gICAgICBpZiAoZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KS5wb3NpdGlvbiAhPT0gJ2ZpeGVkJykge1xyXG4gICAgICAgIE9mZmNhbnZhcy5nZXRPckNyZWF0ZUluc3RhbmNlKGVsZW1lbnQpLmhpZGUoKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH0pO1xyXG4gIGVuYWJsZURpc21pc3NUcmlnZ2VyKE9mZmNhbnZhcyk7XHJcblxyXG4gIC8qKlxyXG4gICAqIGpRdWVyeVxyXG4gICAqL1xyXG5cclxuICBkZWZpbmVKUXVlcnlQbHVnaW4oT2ZmY2FudmFzKTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgdXRpbC9zYW5pdGl6ZXIuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuICAvLyBqcy1kb2NzLXN0YXJ0IGFsbG93LWxpc3RcclxuICBjb25zdCBBUklBX0FUVFJJQlVURV9QQVRURVJOID0gL15hcmlhLVtcXHctXSokL2k7XHJcbiAgY29uc3QgRGVmYXVsdEFsbG93bGlzdCA9IHtcclxuICAgIC8vIEdsb2JhbCBhdHRyaWJ1dGVzIGFsbG93ZWQgb24gYW55IHN1cHBsaWVkIGVsZW1lbnQgYmVsb3cuXHJcbiAgICAnKic6IFsnY2xhc3MnLCAnZGlyJywgJ2lkJywgJ2xhbmcnLCAncm9sZScsIEFSSUFfQVRUUklCVVRFX1BBVFRFUk5dLFxyXG4gICAgYTogWyd0YXJnZXQnLCAnaHJlZicsICd0aXRsZScsICdyZWwnXSxcclxuICAgIGFyZWE6IFtdLFxyXG4gICAgYjogW10sXHJcbiAgICBicjogW10sXHJcbiAgICBjb2w6IFtdLFxyXG4gICAgY29kZTogW10sXHJcbiAgICBkZDogW10sXHJcbiAgICBkaXY6IFtdLFxyXG4gICAgZGw6IFtdLFxyXG4gICAgZHQ6IFtdLFxyXG4gICAgZW06IFtdLFxyXG4gICAgaHI6IFtdLFxyXG4gICAgaDE6IFtdLFxyXG4gICAgaDI6IFtdLFxyXG4gICAgaDM6IFtdLFxyXG4gICAgaDQ6IFtdLFxyXG4gICAgaDU6IFtdLFxyXG4gICAgaDY6IFtdLFxyXG4gICAgaTogW10sXHJcbiAgICBpbWc6IFsnc3JjJywgJ3NyY3NldCcsICdhbHQnLCAndGl0bGUnLCAnd2lkdGgnLCAnaGVpZ2h0J10sXHJcbiAgICBsaTogW10sXHJcbiAgICBvbDogW10sXHJcbiAgICBwOiBbXSxcclxuICAgIHByZTogW10sXHJcbiAgICBzOiBbXSxcclxuICAgIHNtYWxsOiBbXSxcclxuICAgIHNwYW46IFtdLFxyXG4gICAgc3ViOiBbXSxcclxuICAgIHN1cDogW10sXHJcbiAgICBzdHJvbmc6IFtdLFxyXG4gICAgdTogW10sXHJcbiAgICB1bDogW11cclxuICB9O1xyXG4gIC8vIGpzLWRvY3MtZW5kIGFsbG93LWxpc3RcclxuXHJcbiAgY29uc3QgdXJpQXR0cmlidXRlcyA9IG5ldyBTZXQoWydiYWNrZ3JvdW5kJywgJ2NpdGUnLCAnaHJlZicsICdpdGVtdHlwZScsICdsb25nZGVzYycsICdwb3N0ZXInLCAnc3JjJywgJ3hsaW5rOmhyZWYnXSk7XHJcblxyXG4gIC8qKlxyXG4gICAqIEEgcGF0dGVybiB0aGF0IHJlY29nbml6ZXMgVVJMcyB0aGF0IGFyZSBzYWZlIHdydC4gWFNTIGluIFVSTCBuYXZpZ2F0aW9uXHJcbiAgICogY29udGV4dHMuXHJcbiAgICpcclxuICAgKiBTaG91dC1vdXQgdG8gQW5ndWxhciBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvMTUuMi44L3BhY2thZ2VzL2NvcmUvc3JjL3Nhbml0aXphdGlvbi91cmxfc2FuaXRpemVyLnRzI0wzOFxyXG4gICAqL1xyXG4gIGNvbnN0IFNBRkVfVVJMX1BBVFRFUk4gPSAvXig/IWphdmFzY3JpcHQ6KSg/OlthLXowLTkrLi1dKzp8W14mOi8/I10qKD86Wy8/I118JCkpL2k7XHJcbiAgY29uc3QgYWxsb3dlZEF0dHJpYnV0ZSA9IChhdHRyaWJ1dGUsIGFsbG93ZWRBdHRyaWJ1dGVMaXN0KSA9PiB7XHJcbiAgICBjb25zdCBhdHRyaWJ1dGVOYW1lID0gYXR0cmlidXRlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICBpZiAoYWxsb3dlZEF0dHJpYnV0ZUxpc3QuaW5jbHVkZXMoYXR0cmlidXRlTmFtZSkpIHtcclxuICAgICAgaWYgKHVyaUF0dHJpYnV0ZXMuaGFzKGF0dHJpYnV0ZU5hbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIEJvb2xlYW4oU0FGRV9VUkxfUEFUVEVSTi50ZXN0KGF0dHJpYnV0ZS5ub2RlVmFsdWUpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBpZiBhIHJlZ3VsYXIgZXhwcmVzc2lvbiB2YWxpZGF0ZXMgdGhlIGF0dHJpYnV0ZS5cclxuICAgIHJldHVybiBhbGxvd2VkQXR0cmlidXRlTGlzdC5maWx0ZXIoYXR0cmlidXRlUmVnZXggPT4gYXR0cmlidXRlUmVnZXggaW5zdGFuY2VvZiBSZWdFeHApLnNvbWUocmVnZXggPT4gcmVnZXgudGVzdChhdHRyaWJ1dGVOYW1lKSk7XHJcbiAgfTtcclxuICBmdW5jdGlvbiBzYW5pdGl6ZUh0bWwodW5zYWZlSHRtbCwgYWxsb3dMaXN0LCBzYW5pdGl6ZUZ1bmN0aW9uKSB7XHJcbiAgICBpZiAoIXVuc2FmZUh0bWwubGVuZ3RoKSB7XHJcbiAgICAgIHJldHVybiB1bnNhZmVIdG1sO1xyXG4gICAgfVxyXG4gICAgaWYgKHNhbml0aXplRnVuY3Rpb24gJiYgdHlwZW9mIHNhbml0aXplRnVuY3Rpb24gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgcmV0dXJuIHNhbml0aXplRnVuY3Rpb24odW5zYWZlSHRtbCk7XHJcbiAgICB9XHJcbiAgICBjb25zdCBkb21QYXJzZXIgPSBuZXcgd2luZG93LkRPTVBhcnNlcigpO1xyXG4gICAgY29uc3QgY3JlYXRlZERvY3VtZW50ID0gZG9tUGFyc2VyLnBhcnNlRnJvbVN0cmluZyh1bnNhZmVIdG1sLCAndGV4dC9odG1sJyk7XHJcbiAgICBjb25zdCBlbGVtZW50cyA9IFtdLmNvbmNhdCguLi5jcmVhdGVkRG9jdW1lbnQuYm9keS5xdWVyeVNlbGVjdG9yQWxsKCcqJykpO1xyXG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XHJcbiAgICAgIGNvbnN0IGVsZW1lbnROYW1lID0gZWxlbWVudC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICBpZiAoIU9iamVjdC5rZXlzKGFsbG93TGlzdCkuaW5jbHVkZXMoZWxlbWVudE5hbWUpKSB7XHJcbiAgICAgICAgZWxlbWVudC5yZW1vdmUoKTtcclxuICAgICAgICBjb250aW51ZTtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBhdHRyaWJ1dGVMaXN0ID0gW10uY29uY2F0KC4uLmVsZW1lbnQuYXR0cmlidXRlcyk7XHJcbiAgICAgIGNvbnN0IGFsbG93ZWRBdHRyaWJ1dGVzID0gW10uY29uY2F0KGFsbG93TGlzdFsnKiddIHx8IFtdLCBhbGxvd0xpc3RbZWxlbWVudE5hbWVdIHx8IFtdKTtcclxuICAgICAgZm9yIChjb25zdCBhdHRyaWJ1dGUgb2YgYXR0cmlidXRlTGlzdCkge1xyXG4gICAgICAgIGlmICghYWxsb3dlZEF0dHJpYnV0ZShhdHRyaWJ1dGUsIGFsbG93ZWRBdHRyaWJ1dGVzKSkge1xyXG4gICAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoYXR0cmlidXRlLm5vZGVOYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjcmVhdGVkRG9jdW1lbnQuYm9keS5pbm5lckhUTUw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCB1dGlsL3RlbXBsYXRlLWZhY3RvcnkuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE5BTUUkNSA9ICdUZW1wbGF0ZUZhY3RvcnknO1xyXG4gIGNvbnN0IERlZmF1bHQkNCA9IHtcclxuICAgIGFsbG93TGlzdDogRGVmYXVsdEFsbG93bGlzdCxcclxuICAgIGNvbnRlbnQ6IHt9LFxyXG4gICAgLy8geyBzZWxlY3RvciA6IHRleHQgLCAgc2VsZWN0b3IyIDogdGV4dDIgLCB9XHJcbiAgICBleHRyYUNsYXNzOiAnJyxcclxuICAgIGh0bWw6IGZhbHNlLFxyXG4gICAgc2FuaXRpemU6IHRydWUsXHJcbiAgICBzYW5pdGl6ZUZuOiBudWxsLFxyXG4gICAgdGVtcGxhdGU6ICc8ZGl2PjwvZGl2PidcclxuICB9O1xyXG4gIGNvbnN0IERlZmF1bHRUeXBlJDQgPSB7XHJcbiAgICBhbGxvd0xpc3Q6ICdvYmplY3QnLFxyXG4gICAgY29udGVudDogJ29iamVjdCcsXHJcbiAgICBleHRyYUNsYXNzOiAnKHN0cmluZ3xmdW5jdGlvbiknLFxyXG4gICAgaHRtbDogJ2Jvb2xlYW4nLFxyXG4gICAgc2FuaXRpemU6ICdib29sZWFuJyxcclxuICAgIHNhbml0aXplRm46ICcobnVsbHxmdW5jdGlvbiknLFxyXG4gICAgdGVtcGxhdGU6ICdzdHJpbmcnXHJcbiAgfTtcclxuICBjb25zdCBEZWZhdWx0Q29udGVudFR5cGUgPSB7XHJcbiAgICBlbnRyeTogJyhzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbnxudWxsKScsXHJcbiAgICBzZWxlY3RvcjogJyhzdHJpbmd8ZWxlbWVudCknXHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBUZW1wbGF0ZUZhY3RvcnkgZXh0ZW5kcyBDb25maWcge1xyXG4gICAgY29uc3RydWN0b3IoY29uZmlnKSB7XHJcbiAgICAgIHN1cGVyKCk7XHJcbiAgICAgIHRoaXMuX2NvbmZpZyA9IHRoaXMuX2dldENvbmZpZyhjb25maWcpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldHRlcnNcclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHQkNDtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQ0O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgICByZXR1cm4gTkFNRSQ1O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFB1YmxpY1xyXG4gICAgZ2V0Q29udGVudCgpIHtcclxuICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fY29uZmlnLmNvbnRlbnQpLm1hcChjb25maWcgPT4gdGhpcy5fcmVzb2x2ZVBvc3NpYmxlRnVuY3Rpb24oY29uZmlnKSkuZmlsdGVyKEJvb2xlYW4pO1xyXG4gICAgfVxyXG4gICAgaGFzQ29udGVudCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZ2V0Q29udGVudCgpLmxlbmd0aCA+IDA7XHJcbiAgICB9XHJcbiAgICBjaGFuZ2VDb250ZW50KGNvbnRlbnQpIHtcclxuICAgICAgdGhpcy5fY2hlY2tDb250ZW50KGNvbnRlbnQpO1xyXG4gICAgICB0aGlzLl9jb25maWcuY29udGVudCA9IHtcclxuICAgICAgICAuLi50aGlzLl9jb25maWcuY29udGVudCxcclxuICAgICAgICAuLi5jb250ZW50XHJcbiAgICAgIH07XHJcbiAgICAgIHJldHVybiB0aGlzO1xyXG4gICAgfVxyXG4gICAgdG9IdG1sKCkge1xyXG4gICAgICBjb25zdCB0ZW1wbGF0ZVdyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgdGVtcGxhdGVXcmFwcGVyLmlubmVySFRNTCA9IHRoaXMuX21heWJlU2FuaXRpemUodGhpcy5fY29uZmlnLnRlbXBsYXRlKTtcclxuICAgICAgZm9yIChjb25zdCBbc2VsZWN0b3IsIHRleHRdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuX2NvbmZpZy5jb250ZW50KSkge1xyXG4gICAgICAgIHRoaXMuX3NldENvbnRlbnQodGVtcGxhdGVXcmFwcGVyLCB0ZXh0LCBzZWxlY3Rvcik7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgdGVtcGxhdGUgPSB0ZW1wbGF0ZVdyYXBwZXIuY2hpbGRyZW5bMF07XHJcbiAgICAgIGNvbnN0IGV4dHJhQ2xhc3MgPSB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbih0aGlzLl9jb25maWcuZXh0cmFDbGFzcyk7XHJcbiAgICAgIGlmIChleHRyYUNsYXNzKSB7XHJcbiAgICAgICAgdGVtcGxhdGUuY2xhc3NMaXN0LmFkZCguLi5leHRyYUNsYXNzLnNwbGl0KCcgJykpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0ZW1wbGF0ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcml2YXRlXHJcbiAgICBfdHlwZUNoZWNrQ29uZmlnKGNvbmZpZykge1xyXG4gICAgICBzdXBlci5fdHlwZUNoZWNrQ29uZmlnKGNvbmZpZyk7XHJcbiAgICAgIHRoaXMuX2NoZWNrQ29udGVudChjb25maWcuY29udGVudCk7XHJcbiAgICB9XHJcbiAgICBfY2hlY2tDb250ZW50KGFyZykge1xyXG4gICAgICBmb3IgKGNvbnN0IFtzZWxlY3RvciwgY29udGVudF0gb2YgT2JqZWN0LmVudHJpZXMoYXJnKSkge1xyXG4gICAgICAgIHN1cGVyLl90eXBlQ2hlY2tDb25maWcoe1xyXG4gICAgICAgICAgc2VsZWN0b3IsXHJcbiAgICAgICAgICBlbnRyeTogY29udGVudFxyXG4gICAgICAgIH0sIERlZmF1bHRDb250ZW50VHlwZSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIF9zZXRDb250ZW50KHRlbXBsYXRlLCBjb250ZW50LCBzZWxlY3Rvcikge1xyXG4gICAgICBjb25zdCB0ZW1wbGF0ZUVsZW1lbnQgPSBTZWxlY3RvckVuZ2luZS5maW5kT25lKHNlbGVjdG9yLCB0ZW1wbGF0ZSk7XHJcbiAgICAgIGlmICghdGVtcGxhdGVFbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnRlbnQgPSB0aGlzLl9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihjb250ZW50KTtcclxuICAgICAgaWYgKCFjb250ZW50KSB7XHJcbiAgICAgICAgdGVtcGxhdGVFbGVtZW50LnJlbW92ZSgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoaXNFbGVtZW50JDEoY29udGVudCkpIHtcclxuICAgICAgICB0aGlzLl9wdXRFbGVtZW50SW5UZW1wbGF0ZShnZXRFbGVtZW50KGNvbnRlbnQpLCB0ZW1wbGF0ZUVsZW1lbnQpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAodGhpcy5fY29uZmlnLmh0bWwpIHtcclxuICAgICAgICB0ZW1wbGF0ZUVsZW1lbnQuaW5uZXJIVE1MID0gdGhpcy5fbWF5YmVTYW5pdGl6ZShjb250ZW50KTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGVtcGxhdGVFbGVtZW50LnRleHRDb250ZW50ID0gY29udGVudDtcclxuICAgIH1cclxuICAgIF9tYXliZVNhbml0aXplKGFyZykge1xyXG4gICAgICByZXR1cm4gdGhpcy5fY29uZmlnLnNhbml0aXplID8gc2FuaXRpemVIdG1sKGFyZywgdGhpcy5fY29uZmlnLmFsbG93TGlzdCwgdGhpcy5fY29uZmlnLnNhbml0aXplRm4pIDogYXJnO1xyXG4gICAgfVxyXG4gICAgX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKGFyZykge1xyXG4gICAgICByZXR1cm4gZXhlY3V0ZShhcmcsIFt1bmRlZmluZWQsIHRoaXNdKTtcclxuICAgIH1cclxuICAgIF9wdXRFbGVtZW50SW5UZW1wbGF0ZShlbGVtZW50LCB0ZW1wbGF0ZUVsZW1lbnQpIHtcclxuICAgICAgaWYgKHRoaXMuX2NvbmZpZy5odG1sKSB7XHJcbiAgICAgICAgdGVtcGxhdGVFbGVtZW50LmlubmVySFRNTCA9ICcnO1xyXG4gICAgICAgIHRlbXBsYXRlRWxlbWVudC5hcHBlbmQoZWxlbWVudCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRlbXBsYXRlRWxlbWVudC50ZXh0Q29udGVudCA9IGVsZW1lbnQudGV4dENvbnRlbnQ7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCB0b29sdGlwLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcblxyXG4gIC8qKlxyXG4gICAqIENvbnN0YW50c1xyXG4gICAqL1xyXG5cclxuICBjb25zdCBOQU1FJDQgPSAndG9vbHRpcCc7XHJcbiAgY29uc3QgRElTQUxMT1dFRF9BVFRSSUJVVEVTID0gbmV3IFNldChbJ3Nhbml0aXplJywgJ2FsbG93TGlzdCcsICdzYW5pdGl6ZUZuJ10pO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSQyID0gJ2ZhZGUnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfTU9EQUwgPSAnbW9kYWwnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPVyQyID0gJ3Nob3cnO1xyXG4gIGNvbnN0IFNFTEVDVE9SX1RPT0xUSVBfSU5ORVIgPSAnLnRvb2x0aXAtaW5uZXInO1xyXG4gIGNvbnN0IFNFTEVDVE9SX01PREFMID0gYC4ke0NMQVNTX05BTUVfTU9EQUx9YDtcclxuICBjb25zdCBFVkVOVF9NT0RBTF9ISURFID0gJ2hpZGUuYnMubW9kYWwnO1xyXG4gIGNvbnN0IFRSSUdHRVJfSE9WRVIgPSAnaG92ZXInO1xyXG4gIGNvbnN0IFRSSUdHRVJfRk9DVVMgPSAnZm9jdXMnO1xyXG4gIGNvbnN0IFRSSUdHRVJfQ0xJQ0sgPSAnY2xpY2snO1xyXG4gIGNvbnN0IFRSSUdHRVJfTUFOVUFMID0gJ21hbnVhbCc7XHJcbiAgY29uc3QgRVZFTlRfSElERSQyID0gJ2hpZGUnO1xyXG4gIGNvbnN0IEVWRU5UX0hJRERFTiQyID0gJ2hpZGRlbic7XHJcbiAgY29uc3QgRVZFTlRfU0hPVyQyID0gJ3Nob3cnO1xyXG4gIGNvbnN0IEVWRU5UX1NIT1dOJDIgPSAnc2hvd24nO1xyXG4gIGNvbnN0IEVWRU5UX0lOU0VSVEVEID0gJ2luc2VydGVkJztcclxuICBjb25zdCBFVkVOVF9DTElDSyQxID0gJ2NsaWNrJztcclxuICBjb25zdCBFVkVOVF9GT0NVU0lOJDEgPSAnZm9jdXNpbic7XHJcbiAgY29uc3QgRVZFTlRfRk9DVVNPVVQkMSA9ICdmb2N1c291dCc7XHJcbiAgY29uc3QgRVZFTlRfTU9VU0VFTlRFUiA9ICdtb3VzZWVudGVyJztcclxuICBjb25zdCBFVkVOVF9NT1VTRUxFQVZFID0gJ21vdXNlbGVhdmUnO1xyXG4gIGNvbnN0IEF0dGFjaG1lbnRNYXAgPSB7XHJcbiAgICBBVVRPOiAnYXV0bycsXHJcbiAgICBUT1A6ICd0b3AnLFxyXG4gICAgUklHSFQ6IGlzUlRMKCkgPyAnbGVmdCcgOiAncmlnaHQnLFxyXG4gICAgQk9UVE9NOiAnYm90dG9tJyxcclxuICAgIExFRlQ6IGlzUlRMKCkgPyAncmlnaHQnIDogJ2xlZnQnXHJcbiAgfTtcclxuICBjb25zdCBEZWZhdWx0JDMgPSB7XHJcbiAgICBhbGxvd0xpc3Q6IERlZmF1bHRBbGxvd2xpc3QsXHJcbiAgICBhbmltYXRpb246IHRydWUsXHJcbiAgICBib3VuZGFyeTogJ2NsaXBwaW5nUGFyZW50cycsXHJcbiAgICBjb250YWluZXI6IGZhbHNlLFxyXG4gICAgY3VzdG9tQ2xhc3M6ICcnLFxyXG4gICAgZGVsYXk6IDAsXHJcbiAgICBmYWxsYmFja1BsYWNlbWVudHM6IFsndG9wJywgJ3JpZ2h0JywgJ2JvdHRvbScsICdsZWZ0J10sXHJcbiAgICBodG1sOiBmYWxzZSxcclxuICAgIG9mZnNldDogWzAsIDZdLFxyXG4gICAgcGxhY2VtZW50OiAndG9wJyxcclxuICAgIHBvcHBlckNvbmZpZzogbnVsbCxcclxuICAgIHNhbml0aXplOiB0cnVlLFxyXG4gICAgc2FuaXRpemVGbjogbnVsbCxcclxuICAgIHNlbGVjdG9yOiBmYWxzZSxcclxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInRvb2x0aXBcIiByb2xlPVwidG9vbHRpcFwiPicgKyAnPGRpdiBjbGFzcz1cInRvb2x0aXAtYXJyb3dcIj48L2Rpdj4nICsgJzxkaXYgY2xhc3M9XCJ0b29sdGlwLWlubmVyXCI+PC9kaXY+JyArICc8L2Rpdj4nLFxyXG4gICAgdGl0bGU6ICcnLFxyXG4gICAgdHJpZ2dlcjogJ2hvdmVyIGZvY3VzJ1xyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdFR5cGUkMyA9IHtcclxuICAgIGFsbG93TGlzdDogJ29iamVjdCcsXHJcbiAgICBhbmltYXRpb246ICdib29sZWFuJyxcclxuICAgIGJvdW5kYXJ5OiAnKHN0cmluZ3xlbGVtZW50KScsXHJcbiAgICBjb250YWluZXI6ICcoc3RyaW5nfGVsZW1lbnR8Ym9vbGVhbiknLFxyXG4gICAgY3VzdG9tQ2xhc3M6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXHJcbiAgICBkZWxheTogJyhudW1iZXJ8b2JqZWN0KScsXHJcbiAgICBmYWxsYmFja1BsYWNlbWVudHM6ICdhcnJheScsXHJcbiAgICBodG1sOiAnYm9vbGVhbicsXHJcbiAgICBvZmZzZXQ6ICcoYXJyYXl8c3RyaW5nfGZ1bmN0aW9uKScsXHJcbiAgICBwbGFjZW1lbnQ6ICcoc3RyaW5nfGZ1bmN0aW9uKScsXHJcbiAgICBwb3BwZXJDb25maWc6ICcobnVsbHxvYmplY3R8ZnVuY3Rpb24pJyxcclxuICAgIHNhbml0aXplOiAnYm9vbGVhbicsXHJcbiAgICBzYW5pdGl6ZUZuOiAnKG51bGx8ZnVuY3Rpb24pJyxcclxuICAgIHNlbGVjdG9yOiAnKHN0cmluZ3xib29sZWFuKScsXHJcbiAgICB0ZW1wbGF0ZTogJ3N0cmluZycsXHJcbiAgICB0aXRsZTogJyhzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknLFxyXG4gICAgdHJpZ2dlcjogJ3N0cmluZydcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIFRvb2x0aXAgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xyXG4gICAgICBpZiAodHlwZW9mIFBvcHBlciA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdCb290c3RyYXBcXCdzIHRvb2x0aXBzIHJlcXVpcmUgUG9wcGVyIChodHRwczovL3BvcHBlci5qcy5vcmcvZG9jcy92Mi8pJyk7XHJcbiAgICAgIH1cclxuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcclxuXHJcbiAgICAgIC8vIFByaXZhdGVcclxuICAgICAgdGhpcy5faXNFbmFibGVkID0gdHJ1ZTtcclxuICAgICAgdGhpcy5fdGltZW91dCA9IDA7XHJcbiAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IG51bGw7XHJcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXIgPSB7fTtcclxuICAgICAgdGhpcy5fcG9wcGVyID0gbnVsbDtcclxuICAgICAgdGhpcy5fdGVtcGxhdGVGYWN0b3J5ID0gbnVsbDtcclxuICAgICAgdGhpcy5fbmV3Q29udGVudCA9IG51bGw7XHJcblxyXG4gICAgICAvLyBQcm90ZWN0ZWRcclxuICAgICAgdGhpcy50aXAgPSBudWxsO1xyXG4gICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcclxuICAgICAgaWYgKCF0aGlzLl9jb25maWcuc2VsZWN0b3IpIHtcclxuICAgICAgICB0aGlzLl9maXhUaXRsZSgpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgLy8gR2V0dGVyc1xyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0KCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdCQzO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlJDM7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHJldHVybiBOQU1FJDQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHVibGljXHJcbiAgICBlbmFibGUoKSB7XHJcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9IHRydWU7XHJcbiAgICB9XHJcbiAgICBkaXNhYmxlKCkge1xyXG4gICAgICB0aGlzLl9pc0VuYWJsZWQgPSBmYWxzZTtcclxuICAgIH1cclxuICAgIHRvZ2dsZUVuYWJsZWQoKSB7XHJcbiAgICAgIHRoaXMuX2lzRW5hYmxlZCA9ICF0aGlzLl9pc0VuYWJsZWQ7XHJcbiAgICB9XHJcbiAgICB0b2dnbGUoKSB7XHJcbiAgICAgIGlmICghdGhpcy5faXNFbmFibGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKCkpIHtcclxuICAgICAgICB0aGlzLl9sZWF2ZSgpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9lbnRlcigpO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xyXG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2VsZW1lbnQuY2xvc2VzdChTRUxFQ1RPUl9NT0RBTCksIEVWRU5UX01PREFMX0hJREUsIHRoaXMuX2hpZGVNb2RhbEhhbmRsZXIpO1xyXG4gICAgICBpZiAodGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnKSkge1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuc2V0QXR0cmlidXRlKCd0aXRsZScsIHRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdkYXRhLWJzLW9yaWdpbmFsLXRpdGxlJykpO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKTtcclxuICAgICAgc3VwZXIuZGlzcG9zZSgpO1xyXG4gICAgfVxyXG4gICAgc2hvdygpIHtcclxuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgdXNlIHNob3cgb24gdmlzaWJsZSBlbGVtZW50cycpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghKHRoaXMuX2lzV2l0aENvbnRlbnQoKSAmJiB0aGlzLl9pc0VuYWJsZWQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX1NIT1ckMikpO1xyXG4gICAgICBjb25zdCBzaGFkb3dSb290ID0gZmluZFNoYWRvd1Jvb3QodGhpcy5fZWxlbWVudCk7XHJcbiAgICAgIGNvbnN0IGlzSW5UaGVEb20gPSAoc2hhZG93Um9vdCB8fCB0aGlzLl9lbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5jb250YWlucyh0aGlzLl9lbGVtZW50KTtcclxuICAgICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkIHx8ICFpc0luVGhlRG9tKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBUT0RPOiB2NiByZW1vdmUgdGhpcyBvciBtYWtlIGl0IG9wdGlvbmFsXHJcbiAgICAgIHRoaXMuX2Rpc3Bvc2VQb3BwZXIoKTtcclxuICAgICAgY29uc3QgdGlwID0gdGhpcy5fZ2V0VGlwRWxlbWVudCgpO1xyXG4gICAgICB0aGlzLl9lbGVtZW50LnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsIHRpcC5nZXRBdHRyaWJ1dGUoJ2lkJykpO1xyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgY29udGFpbmVyXHJcbiAgICAgIH0gPSB0aGlzLl9jb25maWc7XHJcbiAgICAgIGlmICghdGhpcy5fZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jb250YWlucyh0aGlzLnRpcCkpIHtcclxuICAgICAgICBjb250YWluZXIuYXBwZW5kKHRpcCk7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfSU5TRVJURUQpKTtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9wb3BwZXIgPSB0aGlzLl9jcmVhdGVQb3BwZXIodGlwKTtcclxuICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9TSE9XJDIpO1xyXG5cclxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHRvdWNoLWVuYWJsZWQgZGV2aWNlIHdlIGFkZCBleHRyYVxyXG4gICAgICAvLyBlbXB0eSBtb3VzZW92ZXIgbGlzdGVuZXJzIHRvIHRoZSBib2R5J3MgaW1tZWRpYXRlIGNoaWxkcmVuO1xyXG4gICAgICAvLyBvbmx5IG5lZWRlZCBiZWNhdXNlIG9mIGJyb2tlbiBldmVudCBkZWxlZ2F0aW9uIG9uIGlPU1xyXG4gICAgICAvLyBodHRwczovL3d3dy5xdWlya3Ntb2RlLm9yZy9ibG9nL2FyY2hpdmVzLzIwMTQvMDIvbW91c2VfZXZlbnRfYnViLmh0bWxcclxuICAgICAgaWYgKCdvbnRvdWNoc3RhcnQnIGluIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xyXG4gICAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBbXS5jb25jYXQoLi4uZG9jdW1lbnQuYm9keS5jaGlsZHJlbikpIHtcclxuICAgICAgICAgIEV2ZW50SGFuZGxlci5vbihlbGVtZW50LCAnbW91c2VvdmVyJywgbm9vcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xyXG4gICAgICAgIEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX1NIT1dOJDIpKTtcclxuICAgICAgICBpZiAodGhpcy5faXNIb3ZlcmVkID09PSBmYWxzZSkge1xyXG4gICAgICAgICAgdGhpcy5fbGVhdmUoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5faXNIb3ZlcmVkID0gZmFsc2U7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMudGlwLCB0aGlzLl9pc0FuaW1hdGVkKCkpO1xyXG4gICAgfVxyXG4gICAgaGlkZSgpIHtcclxuICAgICAgaWYgKCF0aGlzLl9pc1Nob3duKCkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgaGlkZUV2ZW50ID0gRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfSElERSQyKSk7XHJcbiAgICAgIGlmIChoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCB0aXAgPSB0aGlzLl9nZXRUaXBFbGVtZW50KCk7XHJcbiAgICAgIHRpcC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPVyQyKTtcclxuXHJcbiAgICAgIC8vIElmIHRoaXMgaXMgYSB0b3VjaC1lbmFibGVkIGRldmljZSB3ZSByZW1vdmUgdGhlIGV4dHJhXHJcbiAgICAgIC8vIGVtcHR5IG1vdXNlb3ZlciBsaXN0ZW5lcnMgd2UgYWRkZWQgZm9yIGlPUyBzdXBwb3J0XHJcbiAgICAgIGlmICgnb250b3VjaHN0YXJ0JyBpbiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpIHtcclxuICAgICAgICBmb3IgKGNvbnN0IGVsZW1lbnQgb2YgW10uY29uY2F0KC4uLmRvY3VtZW50LmJvZHkuY2hpbGRyZW4pKSB7XHJcbiAgICAgICAgICBFdmVudEhhbmRsZXIub2ZmKGVsZW1lbnQsICdtb3VzZW92ZXInLCBub29wKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0NMSUNLXSA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9hY3RpdmVUcmlnZ2VyW1RSSUdHRVJfRk9DVVNdID0gZmFsc2U7XHJcbiAgICAgIHRoaXMuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9IT1ZFUl0gPSBmYWxzZTtcclxuICAgICAgdGhpcy5faXNIb3ZlcmVkID0gbnVsbDsgLy8gaXQgaXMgYSB0cmljayB0byBzdXBwb3J0IG1hbnVhbCB0cmlnZ2VyaW5nXHJcblxyXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcclxuICAgICAgICBpZiAodGhpcy5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5faXNIb3ZlcmVkKSB7XHJcbiAgICAgICAgICB0aGlzLl9kaXNwb3NlUG9wcGVyKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5Jyk7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfSElEREVOJDIpKTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgdGhpcy50aXAsIHRoaXMuX2lzQW5pbWF0ZWQoKSk7XHJcbiAgICB9XHJcbiAgICB1cGRhdGUoKSB7XHJcbiAgICAgIGlmICh0aGlzLl9wb3BwZXIpIHtcclxuICAgICAgICB0aGlzLl9wb3BwZXIudXBkYXRlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBQcm90ZWN0ZWRcclxuICAgIF9pc1dpdGhDb250ZW50KCkge1xyXG4gICAgICByZXR1cm4gQm9vbGVhbih0aGlzLl9nZXRUaXRsZSgpKTtcclxuICAgIH1cclxuICAgIF9nZXRUaXBFbGVtZW50KCkge1xyXG4gICAgICBpZiAoIXRoaXMudGlwKSB7XHJcbiAgICAgICAgdGhpcy50aXAgPSB0aGlzLl9jcmVhdGVUaXBFbGVtZW50KHRoaXMuX25ld0NvbnRlbnQgfHwgdGhpcy5fZ2V0Q29udGVudEZvclRlbXBsYXRlKCkpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aGlzLnRpcDtcclxuICAgIH1cclxuICAgIF9jcmVhdGVUaXBFbGVtZW50KGNvbnRlbnQpIHtcclxuICAgICAgY29uc3QgdGlwID0gdGhpcy5fZ2V0VGVtcGxhdGVGYWN0b3J5KGNvbnRlbnQpLnRvSHRtbCgpO1xyXG5cclxuICAgICAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgY2hlY2sgaW4gdjZcclxuICAgICAgaWYgKCF0aXApIHtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICB0aXAuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0ZBREUkMiwgQ0xBU1NfTkFNRV9TSE9XJDIpO1xyXG4gICAgICAvLyBUT0RPOiB2NiB0aGUgZm9sbG93aW5nIGNhbiBiZSBhY2hpZXZlZCB3aXRoIENTUyBvbmx5XHJcbiAgICAgIHRpcC5jbGFzc0xpc3QuYWRkKGBicy0ke3RoaXMuY29uc3RydWN0b3IuTkFNRX0tYXV0b2ApO1xyXG4gICAgICBjb25zdCB0aXBJZCA9IGdldFVJRCh0aGlzLmNvbnN0cnVjdG9yLk5BTUUpLnRvU3RyaW5nKCk7XHJcbiAgICAgIHRpcC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGlwSWQpO1xyXG4gICAgICBpZiAodGhpcy5faXNBbmltYXRlZCgpKSB7XHJcbiAgICAgICAgdGlwLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9GQURFJDIpO1xyXG4gICAgICB9XHJcbiAgICAgIHJldHVybiB0aXA7XHJcbiAgICB9XHJcbiAgICBzZXRDb250ZW50KGNvbnRlbnQpIHtcclxuICAgICAgdGhpcy5fbmV3Q29udGVudCA9IGNvbnRlbnQ7XHJcbiAgICAgIGlmICh0aGlzLl9pc1Nob3duKCkpIHtcclxuICAgICAgICB0aGlzLl9kaXNwb3NlUG9wcGVyKCk7XHJcbiAgICAgICAgdGhpcy5zaG93KCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIF9nZXRUZW1wbGF0ZUZhY3RvcnkoY29udGVudCkge1xyXG4gICAgICBpZiAodGhpcy5fdGVtcGxhdGVGYWN0b3J5KSB7XHJcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVGYWN0b3J5LmNoYW5nZUNvbnRlbnQoY29udGVudCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fdGVtcGxhdGVGYWN0b3J5ID0gbmV3IFRlbXBsYXRlRmFjdG9yeSh7XHJcbiAgICAgICAgICAuLi50aGlzLl9jb25maWcsXHJcbiAgICAgICAgICAvLyB0aGUgYGNvbnRlbnRgIHZhciBoYXMgdG8gYmUgYWZ0ZXIgYHRoaXMuX2NvbmZpZ2BcclxuICAgICAgICAgIC8vIHRvIG92ZXJyaWRlIGNvbmZpZy5jb250ZW50IGluIGNhc2Ugb2YgcG9wb3ZlclxyXG4gICAgICAgICAgY29udGVudCxcclxuICAgICAgICAgIGV4dHJhQ2xhc3M6IHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jdXN0b21DbGFzcylcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gdGhpcy5fdGVtcGxhdGVGYWN0b3J5O1xyXG4gICAgfVxyXG4gICAgX2dldENvbnRlbnRGb3JUZW1wbGF0ZSgpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBbU0VMRUNUT1JfVE9PTFRJUF9JTk5FUl06IHRoaXMuX2dldFRpdGxlKClcclxuICAgICAgfTtcclxuICAgIH1cclxuICAgIF9nZXRUaXRsZSgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy50aXRsZSkgfHwgdGhpcy5fZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcml2YXRlXHJcbiAgICBfaW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLmdldE9yQ3JlYXRlSW5zdGFuY2UoZXZlbnQuZGVsZWdhdGVUYXJnZXQsIHRoaXMuX2dldERlbGVnYXRlQ29uZmlnKCkpO1xyXG4gICAgfVxyXG4gICAgX2lzQW5pbWF0ZWQoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9jb25maWcuYW5pbWF0aW9uIHx8IHRoaXMudGlwICYmIHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMik7XHJcbiAgICB9XHJcbiAgICBfaXNTaG93bigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMudGlwICYmIHRoaXMudGlwLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1ckMik7XHJcbiAgICB9XHJcbiAgICBfY3JlYXRlUG9wcGVyKHRpcCkge1xyXG4gICAgICBjb25zdCBwbGFjZW1lbnQgPSBleGVjdXRlKHRoaXMuX2NvbmZpZy5wbGFjZW1lbnQsIFt0aGlzLCB0aXAsIHRoaXMuX2VsZW1lbnRdKTtcclxuICAgICAgY29uc3QgYXR0YWNobWVudCA9IEF0dGFjaG1lbnRNYXBbcGxhY2VtZW50LnRvVXBwZXJDYXNlKCldO1xyXG4gICAgICByZXR1cm4gY3JlYXRlUG9wcGVyKHRoaXMuX2VsZW1lbnQsIHRpcCwgdGhpcy5fZ2V0UG9wcGVyQ29uZmlnKGF0dGFjaG1lbnQpKTtcclxuICAgIH1cclxuICAgIF9nZXRPZmZzZXQoKSB7XHJcbiAgICAgIGNvbnN0IHtcclxuICAgICAgICBvZmZzZXRcclxuICAgICAgfSA9IHRoaXMuX2NvbmZpZztcclxuICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgcmV0dXJuIG9mZnNldC5zcGxpdCgnLCcpLm1hcCh2YWx1ZSA9PiBOdW1iZXIucGFyc2VJbnQodmFsdWUsIDEwKSk7XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHR5cGVvZiBvZmZzZXQgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICByZXR1cm4gcG9wcGVyRGF0YSA9PiBvZmZzZXQocG9wcGVyRGF0YSwgdGhpcy5fZWxlbWVudCk7XHJcbiAgICAgIH1cclxuICAgICAgcmV0dXJuIG9mZnNldDtcclxuICAgIH1cclxuICAgIF9yZXNvbHZlUG9zc2libGVGdW5jdGlvbihhcmcpIHtcclxuICAgICAgcmV0dXJuIGV4ZWN1dGUoYXJnLCBbdGhpcy5fZWxlbWVudCwgdGhpcy5fZWxlbWVudF0pO1xyXG4gICAgfVxyXG4gICAgX2dldFBvcHBlckNvbmZpZyhhdHRhY2htZW50KSB7XHJcbiAgICAgIGNvbnN0IGRlZmF1bHRCc1BvcHBlckNvbmZpZyA9IHtcclxuICAgICAgICBwbGFjZW1lbnQ6IGF0dGFjaG1lbnQsXHJcbiAgICAgICAgbW9kaWZpZXJzOiBbe1xyXG4gICAgICAgICAgbmFtZTogJ2ZsaXAnLFxyXG4gICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBmYWxsYmFja1BsYWNlbWVudHM6IHRoaXMuX2NvbmZpZy5mYWxsYmFja1BsYWNlbWVudHNcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LCB7XHJcbiAgICAgICAgICBuYW1lOiAnb2Zmc2V0JyxcclxuICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLl9nZXRPZmZzZXQoKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0sIHtcclxuICAgICAgICAgIG5hbWU6ICdwcmV2ZW50T3ZlcmZsb3cnLFxyXG4gICAgICAgICAgb3B0aW9uczoge1xyXG4gICAgICAgICAgICBib3VuZGFyeTogdGhpcy5fY29uZmlnLmJvdW5kYXJ5XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgbmFtZTogJ2Fycm93JyxcclxuICAgICAgICAgIG9wdGlvbnM6IHtcclxuICAgICAgICAgICAgZWxlbWVudDogYC4ke3RoaXMuY29uc3RydWN0b3IuTkFNRX0tYXJyb3dgXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSwge1xyXG4gICAgICAgICAgbmFtZTogJ3ByZVNldFBsYWNlbWVudCcsXHJcbiAgICAgICAgICBlbmFibGVkOiB0cnVlLFxyXG4gICAgICAgICAgcGhhc2U6ICdiZWZvcmVNYWluJyxcclxuICAgICAgICAgIGZuOiBkYXRhID0+IHtcclxuICAgICAgICAgICAgLy8gUHJlLXNldCBQb3BwZXIncyBwbGFjZW1lbnQgYXR0cmlidXRlIGluIG9yZGVyIHRvIHJlYWQgdGhlIGFycm93IHNpemVzIHByb3Blcmx5LlxyXG4gICAgICAgICAgICAvLyBPdGhlcndpc2UsIFBvcHBlciBtaXhlcyB1cCB0aGUgd2lkdGggYW5kIGhlaWdodCBkaW1lbnNpb25zIHNpbmNlIHRoZSBpbml0aWFsIGFycm93IHN0eWxlIGlzIGZvciB0b3AgcGxhY2VtZW50XHJcbiAgICAgICAgICAgIHRoaXMuX2dldFRpcEVsZW1lbnQoKS5zZXRBdHRyaWJ1dGUoJ2RhdGEtcG9wcGVyLXBsYWNlbWVudCcsIGRhdGEuc3RhdGUucGxhY2VtZW50KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XVxyXG4gICAgICB9O1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIC4uLmRlZmF1bHRCc1BvcHBlckNvbmZpZyxcclxuICAgICAgICAuLi5leGVjdXRlKHRoaXMuX2NvbmZpZy5wb3BwZXJDb25maWcsIFt1bmRlZmluZWQsIGRlZmF1bHRCc1BvcHBlckNvbmZpZ10pXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfc2V0TGlzdGVuZXJzKCkge1xyXG4gICAgICBjb25zdCB0cmlnZ2VycyA9IHRoaXMuX2NvbmZpZy50cmlnZ2VyLnNwbGl0KCcgJyk7XHJcbiAgICAgIGZvciAoY29uc3QgdHJpZ2dlciBvZiB0cmlnZ2Vycykge1xyXG4gICAgICAgIGlmICh0cmlnZ2VyID09PSAnY2xpY2snKSB7XHJcbiAgICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgdGhpcy5jb25zdHJ1Y3Rvci5ldmVudE5hbWUoRVZFTlRfQ0xJQ0skMSksIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KTtcclxuICAgICAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltUUklHR0VSX0NMSUNLXSA9ICEoY29udGV4dC5faXNTaG93bigpICYmIGNvbnRleHQuX2FjdGl2ZVRyaWdnZXJbVFJJR0dFUl9DTElDS10pO1xyXG4gICAgICAgICAgICBjb250ZXh0LnRvZ2dsZSgpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfSBlbHNlIGlmICh0cmlnZ2VyICE9PSBUUklHR0VSX01BTlVBTCkge1xyXG4gICAgICAgICAgY29uc3QgZXZlbnRJbiA9IHRyaWdnZXIgPT09IFRSSUdHRVJfSE9WRVIgPyB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9NT1VTRUVOVEVSKSA6IHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0ZPQ1VTSU4kMSk7XHJcbiAgICAgICAgICBjb25zdCBldmVudE91dCA9IHRyaWdnZXIgPT09IFRSSUdHRVJfSE9WRVIgPyB0aGlzLmNvbnN0cnVjdG9yLmV2ZW50TmFtZShFVkVOVF9NT1VTRUxFQVZFKSA6IHRoaXMuY29uc3RydWN0b3IuZXZlbnROYW1lKEVWRU5UX0ZPQ1VTT1VUJDEpO1xyXG4gICAgICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIGV2ZW50SW4sIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KTtcclxuICAgICAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltldmVudC50eXBlID09PSAnZm9jdXNpbicgPyBUUklHR0VSX0ZPQ1VTIDogVFJJR0dFUl9IT1ZFUl0gPSB0cnVlO1xyXG4gICAgICAgICAgICBjb250ZXh0Ll9lbnRlcigpO1xyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgZXZlbnRPdXQsIHRoaXMuX2NvbmZpZy5zZWxlY3RvciwgZXZlbnQgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBjb250ZXh0ID0gdGhpcy5faW5pdGlhbGl6ZU9uRGVsZWdhdGVkVGFyZ2V0KGV2ZW50KTtcclxuICAgICAgICAgICAgY29udGV4dC5fYWN0aXZlVHJpZ2dlcltldmVudC50eXBlID09PSAnZm9jdXNvdXQnID8gVFJJR0dFUl9GT0NVUyA6IFRSSUdHRVJfSE9WRVJdID0gY29udGV4dC5fZWxlbWVudC5jb250YWlucyhldmVudC5yZWxhdGVkVGFyZ2V0KTtcclxuICAgICAgICAgICAgY29udGV4dC5fbGVhdmUoKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyID0gKCkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9lbGVtZW50KSB7XHJcbiAgICAgICAgICB0aGlzLmhpZGUoKTtcclxuICAgICAgICB9XHJcbiAgICAgIH07XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LmNsb3Nlc3QoU0VMRUNUT1JfTU9EQUwpLCBFVkVOVF9NT0RBTF9ISURFLCB0aGlzLl9oaWRlTW9kYWxIYW5kbGVyKTtcclxuICAgIH1cclxuICAgIF9maXhUaXRsZSgpIHtcclxuICAgICAgY29uc3QgdGl0bGUgPSB0aGlzLl9lbGVtZW50LmdldEF0dHJpYnV0ZSgndGl0bGUnKTtcclxuICAgICAgaWYgKCF0aXRsZSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBpZiAoIXRoaXMuX2VsZW1lbnQuZ2V0QXR0cmlidXRlKCdhcmlhLWxhYmVsJykgJiYgIXRoaXMuX2VsZW1lbnQudGV4dENvbnRlbnQudHJpbSgpKSB7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCB0aXRsZSk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2RhdGEtYnMtb3JpZ2luYWwtdGl0bGUnLCB0aXRsZSk7IC8vIERPIE5PVCBVU0UgSVQuIElzIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQucmVtb3ZlQXR0cmlidXRlKCd0aXRsZScpO1xyXG4gICAgfVxyXG4gICAgX2VudGVyKCkge1xyXG4gICAgICBpZiAodGhpcy5faXNTaG93bigpIHx8IHRoaXMuX2lzSG92ZXJlZCkge1xyXG4gICAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IHRydWU7XHJcbiAgICAgIHRoaXMuX3NldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9pc0hvdmVyZWQpIHtcclxuICAgICAgICAgIHRoaXMuc2hvdygpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSwgdGhpcy5fY29uZmlnLmRlbGF5LnNob3cpO1xyXG4gICAgfVxyXG4gICAgX2xlYXZlKCkge1xyXG4gICAgICBpZiAodGhpcy5faXNXaXRoQWN0aXZlVHJpZ2dlcigpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2lzSG92ZXJlZCA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9zZXRUaW1lb3V0KCgpID0+IHtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzSG92ZXJlZCkge1xyXG4gICAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCB0aGlzLl9jb25maWcuZGVsYXkuaGlkZSk7XHJcbiAgICB9XHJcbiAgICBfc2V0VGltZW91dChoYW5kbGVyLCB0aW1lb3V0KSB7XHJcbiAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcclxuICAgICAgdGhpcy5fdGltZW91dCA9IHNldFRpbWVvdXQoaGFuZGxlciwgdGltZW91dCk7XHJcbiAgICB9XHJcbiAgICBfaXNXaXRoQWN0aXZlVHJpZ2dlcigpIHtcclxuICAgICAgcmV0dXJuIE9iamVjdC52YWx1ZXModGhpcy5fYWN0aXZlVHJpZ2dlcikuaW5jbHVkZXModHJ1ZSk7XHJcbiAgICB9XHJcbiAgICBfZ2V0Q29uZmlnKGNvbmZpZykge1xyXG4gICAgICBjb25zdCBkYXRhQXR0cmlidXRlcyA9IE1hbmlwdWxhdG9yLmdldERhdGFBdHRyaWJ1dGVzKHRoaXMuX2VsZW1lbnQpO1xyXG4gICAgICBmb3IgKGNvbnN0IGRhdGFBdHRyaWJ1dGUgb2YgT2JqZWN0LmtleXMoZGF0YUF0dHJpYnV0ZXMpKSB7XHJcbiAgICAgICAgaWYgKERJU0FMTE9XRURfQVRUUklCVVRFUy5oYXMoZGF0YUF0dHJpYnV0ZSkpIHtcclxuICAgICAgICAgIGRlbGV0ZSBkYXRhQXR0cmlidXRlc1tkYXRhQXR0cmlidXRlXTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgY29uZmlnID0ge1xyXG4gICAgICAgIC4uLmRhdGFBdHRyaWJ1dGVzLFxyXG4gICAgICAgIC4uLih0eXBlb2YgY29uZmlnID09PSAnb2JqZWN0JyAmJiBjb25maWcgPyBjb25maWcgOiB7fSlcclxuICAgICAgfTtcclxuICAgICAgY29uZmlnID0gdGhpcy5fbWVyZ2VDb25maWdPYmooY29uZmlnKTtcclxuICAgICAgY29uZmlnID0gdGhpcy5fY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpO1xyXG4gICAgICB0aGlzLl90eXBlQ2hlY2tDb25maWcoY29uZmlnKTtcclxuICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgIH1cclxuICAgIF9jb25maWdBZnRlck1lcmdlKGNvbmZpZykge1xyXG4gICAgICBjb25maWcuY29udGFpbmVyID0gY29uZmlnLmNvbnRhaW5lciA9PT0gZmFsc2UgPyBkb2N1bWVudC5ib2R5IDogZ2V0RWxlbWVudChjb25maWcuY29udGFpbmVyKTtcclxuICAgICAgaWYgKHR5cGVvZiBjb25maWcuZGVsYXkgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgY29uZmlnLmRlbGF5ID0ge1xyXG4gICAgICAgICAgc2hvdzogY29uZmlnLmRlbGF5LFxyXG4gICAgICAgICAgaGlkZTogY29uZmlnLmRlbGF5XHJcbiAgICAgICAgfTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy50aXRsZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBjb25maWcudGl0bGUgPSBjb25maWcudGl0bGUudG9TdHJpbmcoKTtcclxuICAgICAgfVxyXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy5jb250ZW50ID09PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGNvbmZpZy5jb250ZW50ID0gY29uZmlnLmNvbnRlbnQudG9TdHJpbmcoKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgX2dldERlbGVnYXRlQ29uZmlnKCkge1xyXG4gICAgICBjb25zdCBjb25maWcgPSB7fTtcclxuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5fY29uZmlnKSkge1xyXG4gICAgICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRba2V5XSAhPT0gdmFsdWUpIHtcclxuICAgICAgICAgIGNvbmZpZ1trZXldID0gdmFsdWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGNvbmZpZy5zZWxlY3RvciA9IGZhbHNlO1xyXG4gICAgICBjb25maWcudHJpZ2dlciA9ICdtYW51YWwnO1xyXG5cclxuICAgICAgLy8gSW4gdGhlIGZ1dHVyZSBjYW4gYmUgcmVwbGFjZWQgd2l0aDpcclxuICAgICAgLy8gY29uc3Qga2V5c1dpdGhEaWZmZXJlbnRWYWx1ZXMgPSBPYmplY3QuZW50cmllcyh0aGlzLl9jb25maWcpLmZpbHRlcihlbnRyeSA9PiB0aGlzLmNvbnN0cnVjdG9yLkRlZmF1bHRbZW50cnlbMF1dICE9PSB0aGlzLl9jb25maWdbZW50cnlbMF1dKVxyXG4gICAgICAvLyBgT2JqZWN0LmZyb21FbnRyaWVzKGtleXNXaXRoRGlmZmVyZW50VmFsdWVzKWBcclxuICAgICAgcmV0dXJuIGNvbmZpZztcclxuICAgIH1cclxuICAgIF9kaXNwb3NlUG9wcGVyKCkge1xyXG4gICAgICBpZiAodGhpcy5fcG9wcGVyKSB7XHJcbiAgICAgICAgdGhpcy5fcG9wcGVyLmRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLl9wb3BwZXIgPSBudWxsO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICh0aGlzLnRpcCkge1xyXG4gICAgICAgIHRoaXMudGlwLnJlbW92ZSgpO1xyXG4gICAgICAgIHRoaXMudGlwID0gbnVsbDtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0YXRpY1xyXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IFRvb2x0aXAuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIGpRdWVyeVxyXG4gICAqL1xyXG5cclxuICBkZWZpbmVKUXVlcnlQbHVnaW4oVG9vbHRpcCk7XHJcblxyXG4gIC8qKlxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICogQm9vdHN0cmFwIHBvcG92ZXIuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE5BTUUkMyA9ICdwb3BvdmVyJztcclxuICBjb25zdCBTRUxFQ1RPUl9USVRMRSA9ICcucG9wb3Zlci1oZWFkZXInO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0NPTlRFTlQgPSAnLnBvcG92ZXItYm9keSc7XHJcbiAgY29uc3QgRGVmYXVsdCQyID0ge1xyXG4gICAgLi4uVG9vbHRpcC5EZWZhdWx0LFxyXG4gICAgY29udGVudDogJycsXHJcbiAgICBvZmZzZXQ6IFswLCA4XSxcclxuICAgIHBsYWNlbWVudDogJ3JpZ2h0JyxcclxuICAgIHRlbXBsYXRlOiAnPGRpdiBjbGFzcz1cInBvcG92ZXJcIiByb2xlPVwidG9vbHRpcFwiPicgKyAnPGRpdiBjbGFzcz1cInBvcG92ZXItYXJyb3dcIj48L2Rpdj4nICsgJzxoMyBjbGFzcz1cInBvcG92ZXItaGVhZGVyXCI+PC9oMz4nICsgJzxkaXYgY2xhc3M9XCJwb3BvdmVyLWJvZHlcIj48L2Rpdj4nICsgJzwvZGl2PicsXHJcbiAgICB0cmlnZ2VyOiAnY2xpY2snXHJcbiAgfTtcclxuICBjb25zdCBEZWZhdWx0VHlwZSQyID0ge1xyXG4gICAgLi4uVG9vbHRpcC5EZWZhdWx0VHlwZSxcclxuICAgIGNvbnRlbnQ6ICcobnVsbHxzdHJpbmd8ZWxlbWVudHxmdW5jdGlvbiknXHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBQb3BvdmVyIGV4dGVuZHMgVG9vbHRpcCB7XHJcbiAgICAvLyBHZXR0ZXJzXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0JDI7XHJcbiAgICB9XHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHRUeXBlKCkge1xyXG4gICAgICByZXR1cm4gRGVmYXVsdFR5cGUkMjtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgTkFNRSgpIHtcclxuICAgICAgcmV0dXJuIE5BTUUkMztcclxuICAgIH1cclxuXHJcbiAgICAvLyBPdmVycmlkZXNcclxuICAgIF9pc1dpdGhDb250ZW50KCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fZ2V0VGl0bGUoKSB8fCB0aGlzLl9nZXRDb250ZW50KCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJpdmF0ZVxyXG4gICAgX2dldENvbnRlbnRGb3JUZW1wbGF0ZSgpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBbU0VMRUNUT1JfVElUTEVdOiB0aGlzLl9nZXRUaXRsZSgpLFxyXG4gICAgICAgIFtTRUxFQ1RPUl9DT05URU5UXTogdGhpcy5fZ2V0Q29udGVudCgpXHJcbiAgICAgIH07XHJcbiAgICB9XHJcbiAgICBfZ2V0Q29udGVudCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX3Jlc29sdmVQb3NzaWJsZUZ1bmN0aW9uKHRoaXMuX2NvbmZpZy5jb250ZW50KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGF0aWNcclxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBQb3BvdmVyLmdldE9yQ3JlYXRlSW5zdGFuY2UodGhpcywgY29uZmlnKTtcclxuICAgICAgICBpZiAodHlwZW9mIGNvbmZpZyAhPT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhW2NvbmZpZ10gPT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBObyBtZXRob2QgbmFtZWQgXCIke2NvbmZpZ31cImApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhW2NvbmZpZ10oKTtcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBqUXVlcnlcclxuICAgKi9cclxuXHJcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKFBvcG92ZXIpO1xyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCBzY3JvbGxzcHkuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE5BTUUkMiA9ICdzY3JvbGxzcHknO1xyXG4gIGNvbnN0IERBVEFfS0VZJDIgPSAnYnMuc2Nyb2xsc3B5JztcclxuICBjb25zdCBFVkVOVF9LRVkkMiA9IGAuJHtEQVRBX0tFWSQyfWA7XHJcbiAgY29uc3QgREFUQV9BUElfS0VZID0gJy5kYXRhLWFwaSc7XHJcbiAgY29uc3QgRVZFTlRfQUNUSVZBVEUgPSBgYWN0aXZhdGUke0VWRU5UX0tFWSQyfWA7XHJcbiAgY29uc3QgRVZFTlRfQ0xJQ0sgPSBgY2xpY2ske0VWRU5UX0tFWSQyfWA7XHJcbiAgY29uc3QgRVZFTlRfTE9BRF9EQVRBX0FQSSQxID0gYGxvYWQke0VWRU5UX0tFWSQyfSR7REFUQV9BUElfS0VZfWA7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNID0gJ2Ryb3Bkb3duLWl0ZW0nO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfQUNUSVZFJDEgPSAnYWN0aXZlJztcclxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1NQWSA9ICdbZGF0YS1icy1zcHk9XCJzY3JvbGxcIl0nO1xyXG4gIGNvbnN0IFNFTEVDVE9SX1RBUkdFVF9MSU5LUyA9ICdbaHJlZl0nO1xyXG4gIGNvbnN0IFNFTEVDVE9SX05BVl9MSVNUX0dST1VQID0gJy5uYXYsIC5saXN0LWdyb3VwJztcclxuICBjb25zdCBTRUxFQ1RPUl9OQVZfTElOS1MgPSAnLm5hdi1saW5rJztcclxuICBjb25zdCBTRUxFQ1RPUl9OQVZfSVRFTVMgPSAnLm5hdi1pdGVtJztcclxuICBjb25zdCBTRUxFQ1RPUl9MSVNUX0lURU1TID0gJy5saXN0LWdyb3VwLWl0ZW0nO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0xJTktfSVRFTVMgPSBgJHtTRUxFQ1RPUl9OQVZfTElOS1N9LCAke1NFTEVDVE9SX05BVl9JVEVNU30gPiAke1NFTEVDVE9SX05BVl9MSU5LU30sICR7U0VMRUNUT1JfTElTVF9JVEVNU31gO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0RST1BET1dOID0gJy5kcm9wZG93bic7XHJcbiAgY29uc3QgU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFJDEgPSAnLmRyb3Bkb3duLXRvZ2dsZSc7XHJcbiAgY29uc3QgRGVmYXVsdCQxID0ge1xyXG4gICAgb2Zmc2V0OiBudWxsLFxyXG4gICAgLy8gVE9ETzogdjYgQGRlcHJlY2F0ZWQsIGtlZXAgaXQgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5IHJlYXNvbnNcclxuICAgIHJvb3RNYXJnaW46ICcwcHggMHB4IC0yNSUnLFxyXG4gICAgc21vb3RoU2Nyb2xsOiBmYWxzZSxcclxuICAgIHRhcmdldDogbnVsbCxcclxuICAgIHRocmVzaG9sZDogWzAuMSwgMC41LCAxXVxyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdFR5cGUkMSA9IHtcclxuICAgIG9mZnNldDogJyhudW1iZXJ8bnVsbCknLFxyXG4gICAgLy8gVE9ETyB2NiBAZGVwcmVjYXRlZCwga2VlcCBpdCBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcmVhc29uc1xyXG4gICAgcm9vdE1hcmdpbjogJ3N0cmluZycsXHJcbiAgICBzbW9vdGhTY3JvbGw6ICdib29sZWFuJyxcclxuICAgIHRhcmdldDogJ2VsZW1lbnQnLFxyXG4gICAgdGhyZXNob2xkOiAnYXJyYXknXHJcbiAgfTtcclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhc3MgZGVmaW5pdGlvblxyXG4gICAqL1xyXG5cclxuICBjbGFzcyBTY3JvbGxTcHkgZXh0ZW5kcyBCYXNlQ29tcG9uZW50IHtcclxuICAgIGNvbnN0cnVjdG9yKGVsZW1lbnQsIGNvbmZpZykge1xyXG4gICAgICBzdXBlcihlbGVtZW50LCBjb25maWcpO1xyXG5cclxuICAgICAgLy8gdGhpcy5fZWxlbWVudCBpcyB0aGUgb2JzZXJ2YWJsZXNDb250YWluZXIgYW5kIGNvbmZpZy50YXJnZXQgdGhlIG1lbnUgbGlua3Mgd3JhcHBlclxyXG4gICAgICB0aGlzLl90YXJnZXRMaW5rcyA9IG5ldyBNYXAoKTtcclxuICAgICAgdGhpcy5fb2JzZXJ2YWJsZVNlY3Rpb25zID0gbmV3IE1hcCgpO1xyXG4gICAgICB0aGlzLl9yb290RWxlbWVudCA9IGdldENvbXB1dGVkU3R5bGUodGhpcy5fZWxlbWVudCkub3ZlcmZsb3dZID09PSAndmlzaWJsZScgPyBudWxsIDogdGhpcy5fZWxlbWVudDtcclxuICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBudWxsO1xyXG4gICAgICB0aGlzLl9wcmV2aW91c1Njcm9sbERhdGEgPSB7XHJcbiAgICAgICAgdmlzaWJsZUVudHJ5VG9wOiAwLFxyXG4gICAgICAgIHBhcmVudFNjcm9sbFRvcDogMFxyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLnJlZnJlc2goKTsgLy8gaW5pdGlhbGl6ZVxyXG4gICAgfVxyXG5cclxuICAgIC8vIEdldHRlcnNcclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdCgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHQkMTtcclxuICAgIH1cclxuICAgIHN0YXRpYyBnZXQgRGVmYXVsdFR5cGUoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0VHlwZSQxO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgICByZXR1cm4gTkFNRSQyO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFB1YmxpY1xyXG4gICAgcmVmcmVzaCgpIHtcclxuICAgICAgdGhpcy5faW5pdGlhbGl6ZVRhcmdldHNBbmRPYnNlcnZhYmxlcygpO1xyXG4gICAgICB0aGlzLl9tYXliZUVuYWJsZVNtb290aFNjcm9sbCgpO1xyXG4gICAgICBpZiAodGhpcy5fb2JzZXJ2ZXIpIHtcclxuICAgICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSB0aGlzLl9nZXROZXdPYnNlcnZlcigpO1xyXG4gICAgICB9XHJcbiAgICAgIGZvciAoY29uc3Qgc2VjdGlvbiBvZiB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMudmFsdWVzKCkpIHtcclxuICAgICAgICB0aGlzLl9vYnNlcnZlci5vYnNlcnZlKHNlY3Rpb24pO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBkaXNwb3NlKCkge1xyXG4gICAgICB0aGlzLl9vYnNlcnZlci5kaXNjb25uZWN0KCk7XHJcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQcml2YXRlXHJcbiAgICBfY29uZmlnQWZ0ZXJNZXJnZShjb25maWcpIHtcclxuICAgICAgLy8gVE9ETzogb24gdjYgdGFyZ2V0IHNob3VsZCBiZSBnaXZlbiBleHBsaWNpdGx5ICYgcmVtb3ZlIHRoZSB7dGFyZ2V0OiAnc3MtdGFyZ2V0J30gY2FzZVxyXG4gICAgICBjb25maWcudGFyZ2V0ID0gZ2V0RWxlbWVudChjb25maWcudGFyZ2V0KSB8fCBkb2N1bWVudC5ib2R5O1xyXG5cclxuICAgICAgLy8gVE9ETzogdjYgT25seSBmb3IgYmFja3dhcmRzIGNvbXBhdGliaWxpdHkgcmVhc29ucy4gVXNlIHJvb3RNYXJnaW4gb25seVxyXG4gICAgICBjb25maWcucm9vdE1hcmdpbiA9IGNvbmZpZy5vZmZzZXQgPyBgJHtjb25maWcub2Zmc2V0fXB4IDBweCAtMzAlYCA6IGNvbmZpZy5yb290TWFyZ2luO1xyXG4gICAgICBpZiAodHlwZW9mIGNvbmZpZy50aHJlc2hvbGQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgY29uZmlnLnRocmVzaG9sZCA9IGNvbmZpZy50aHJlc2hvbGQuc3BsaXQoJywnKS5tYXAodmFsdWUgPT4gTnVtYmVyLnBhcnNlRmxvYXQodmFsdWUpKTtcclxuICAgICAgfVxyXG4gICAgICByZXR1cm4gY29uZmlnO1xyXG4gICAgfVxyXG4gICAgX21heWJlRW5hYmxlU21vb3RoU2Nyb2xsKCkge1xyXG4gICAgICBpZiAoIXRoaXMuX2NvbmZpZy5zbW9vdGhTY3JvbGwpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHVucmVnaXN0ZXIgYW55IHByZXZpb3VzIGxpc3RlbmVyc1xyXG4gICAgICBFdmVudEhhbmRsZXIub2ZmKHRoaXMuX2NvbmZpZy50YXJnZXQsIEVWRU5UX0NMSUNLKTtcclxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2NvbmZpZy50YXJnZXQsIEVWRU5UX0NMSUNLLCBTRUxFQ1RPUl9UQVJHRVRfTElOS1MsIGV2ZW50ID0+IHtcclxuICAgICAgICBjb25zdCBvYnNlcnZhYmxlU2VjdGlvbiA9IHRoaXMuX29ic2VydmFibGVTZWN0aW9ucy5nZXQoZXZlbnQudGFyZ2V0Lmhhc2gpO1xyXG4gICAgICAgIGlmIChvYnNlcnZhYmxlU2VjdGlvbikge1xyXG4gICAgICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgIGNvbnN0IHJvb3QgPSB0aGlzLl9yb290RWxlbWVudCB8fCB3aW5kb3c7XHJcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBvYnNlcnZhYmxlU2VjdGlvbi5vZmZzZXRUb3AgLSB0aGlzLl9lbGVtZW50Lm9mZnNldFRvcDtcclxuICAgICAgICAgIGlmIChyb290LnNjcm9sbFRvKSB7XHJcbiAgICAgICAgICAgIHJvb3Quc2Nyb2xsVG8oe1xyXG4gICAgICAgICAgICAgIHRvcDogaGVpZ2h0LFxyXG4gICAgICAgICAgICAgIGJlaGF2aW9yOiAnc21vb3RoJ1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIC8vIENocm9tZSA2MCBkb2Vzbid0IHN1cHBvcnQgYHNjcm9sbFRvYFxyXG4gICAgICAgICAgcm9vdC5zY3JvbGxUb3AgPSBoZWlnaHQ7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIF9nZXROZXdPYnNlcnZlcigpIHtcclxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICByb290OiB0aGlzLl9yb290RWxlbWVudCxcclxuICAgICAgICB0aHJlc2hvbGQ6IHRoaXMuX2NvbmZpZy50aHJlc2hvbGQsXHJcbiAgICAgICAgcm9vdE1hcmdpbjogdGhpcy5fY29uZmlnLnJvb3RNYXJnaW5cclxuICAgICAgfTtcclxuICAgICAgcmV0dXJuIG5ldyBJbnRlcnNlY3Rpb25PYnNlcnZlcihlbnRyaWVzID0+IHRoaXMuX29ic2VydmVyQ2FsbGJhY2soZW50cmllcyksIG9wdGlvbnMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRoZSBsb2dpYyBvZiBzZWxlY3Rpb25cclxuICAgIF9vYnNlcnZlckNhbGxiYWNrKGVudHJpZXMpIHtcclxuICAgICAgY29uc3QgdGFyZ2V0RWxlbWVudCA9IGVudHJ5ID0+IHRoaXMuX3RhcmdldExpbmtzLmdldChgIyR7ZW50cnkudGFyZ2V0LmlkfWApO1xyXG4gICAgICBjb25zdCBhY3RpdmF0ZSA9IGVudHJ5ID0+IHtcclxuICAgICAgICB0aGlzLl9wcmV2aW91c1Njcm9sbERhdGEudmlzaWJsZUVudHJ5VG9wID0gZW50cnkudGFyZ2V0Lm9mZnNldFRvcDtcclxuICAgICAgICB0aGlzLl9wcm9jZXNzKHRhcmdldEVsZW1lbnQoZW50cnkpKTtcclxuICAgICAgfTtcclxuICAgICAgY29uc3QgcGFyZW50U2Nyb2xsVG9wID0gKHRoaXMuX3Jvb3RFbGVtZW50IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkuc2Nyb2xsVG9wO1xyXG4gICAgICBjb25zdCB1c2VyU2Nyb2xsc0Rvd24gPSBwYXJlbnRTY3JvbGxUb3AgPj0gdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnBhcmVudFNjcm9sbFRvcDtcclxuICAgICAgdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnBhcmVudFNjcm9sbFRvcCA9IHBhcmVudFNjcm9sbFRvcDtcclxuICAgICAgZm9yIChjb25zdCBlbnRyeSBvZiBlbnRyaWVzKSB7XHJcbiAgICAgICAgaWYgKCFlbnRyeS5pc0ludGVyc2VjdGluZykge1xyXG4gICAgICAgICAgdGhpcy5fYWN0aXZlVGFyZ2V0ID0gbnVsbDtcclxuICAgICAgICAgIHRoaXMuX2NsZWFyQWN0aXZlQ2xhc3ModGFyZ2V0RWxlbWVudChlbnRyeSkpO1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IGVudHJ5SXNMb3dlclRoYW5QcmV2aW91cyA9IGVudHJ5LnRhcmdldC5vZmZzZXRUb3AgPj0gdGhpcy5fcHJldmlvdXNTY3JvbGxEYXRhLnZpc2libGVFbnRyeVRvcDtcclxuICAgICAgICAvLyBpZiB3ZSBhcmUgc2Nyb2xsaW5nIGRvd24sIHBpY2sgdGhlIGJpZ2dlciBvZmZzZXRUb3BcclxuICAgICAgICBpZiAodXNlclNjcm9sbHNEb3duICYmIGVudHJ5SXNMb3dlclRoYW5QcmV2aW91cykge1xyXG4gICAgICAgICAgYWN0aXZhdGUoZW50cnkpO1xyXG4gICAgICAgICAgLy8gaWYgcGFyZW50IGlzbid0IHNjcm9sbGVkLCBsZXQncyBrZWVwIHRoZSBmaXJzdCB2aXNpYmxlIGl0ZW0sIGJyZWFraW5nIHRoZSBpdGVyYXRpb25cclxuICAgICAgICAgIGlmICghcGFyZW50U2Nyb2xsVG9wKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGNvbnRpbnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gaWYgd2UgYXJlIHNjcm9sbGluZyB1cCwgcGljayB0aGUgc21hbGxlc3Qgb2Zmc2V0VG9wXHJcbiAgICAgICAgaWYgKCF1c2VyU2Nyb2xsc0Rvd24gJiYgIWVudHJ5SXNMb3dlclRoYW5QcmV2aW91cykge1xyXG4gICAgICAgICAgYWN0aXZhdGUoZW50cnkpO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgX2luaXRpYWxpemVUYXJnZXRzQW5kT2JzZXJ2YWJsZXMoKSB7XHJcbiAgICAgIHRoaXMuX3RhcmdldExpbmtzID0gbmV3IE1hcCgpO1xyXG4gICAgICB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMgPSBuZXcgTWFwKCk7XHJcbiAgICAgIGNvbnN0IHRhcmdldExpbmtzID0gU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9UQVJHRVRfTElOS1MsIHRoaXMuX2NvbmZpZy50YXJnZXQpO1xyXG4gICAgICBmb3IgKGNvbnN0IGFuY2hvciBvZiB0YXJnZXRMaW5rcykge1xyXG4gICAgICAgIC8vIGVuc3VyZSB0aGF0IHRoZSBhbmNob3IgaGFzIGFuIGlkIGFuZCBpcyBub3QgZGlzYWJsZWRcclxuICAgICAgICBpZiAoIWFuY2hvci5oYXNoIHx8IGlzRGlzYWJsZWQoYW5jaG9yKSkge1xyXG4gICAgICAgICAgY29udGludWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGNvbnN0IG9ic2VydmFibGVTZWN0aW9uID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShkZWNvZGVVUkkoYW5jaG9yLmhhc2gpLCB0aGlzLl9lbGVtZW50KTtcclxuXHJcbiAgICAgICAgLy8gZW5zdXJlIHRoYXQgdGhlIG9ic2VydmFibGVTZWN0aW9uIGV4aXN0cyAmIGlzIHZpc2libGVcclxuICAgICAgICBpZiAoaXNWaXNpYmxlKG9ic2VydmFibGVTZWN0aW9uKSkge1xyXG4gICAgICAgICAgdGhpcy5fdGFyZ2V0TGlua3Muc2V0KGRlY29kZVVSSShhbmNob3IuaGFzaCksIGFuY2hvcik7XHJcbiAgICAgICAgICB0aGlzLl9vYnNlcnZhYmxlU2VjdGlvbnMuc2V0KGFuY2hvci5oYXNoLCBvYnNlcnZhYmxlU2VjdGlvbik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfcHJvY2Vzcyh0YXJnZXQpIHtcclxuICAgICAgaWYgKHRoaXMuX2FjdGl2ZVRhcmdldCA9PT0gdGFyZ2V0KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX2NsZWFyQWN0aXZlQ2xhc3ModGhpcy5fY29uZmlnLnRhcmdldCk7XHJcbiAgICAgIHRoaXMuX2FjdGl2ZVRhcmdldCA9IHRhcmdldDtcclxuICAgICAgdGFyZ2V0LmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XHJcbiAgICAgIHRoaXMuX2FjdGl2YXRlUGFyZW50cyh0YXJnZXQpO1xyXG4gICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9BQ1RJVkFURSwge1xyXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IHRhcmdldFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICAgIF9hY3RpdmF0ZVBhcmVudHModGFyZ2V0KSB7XHJcbiAgICAgIC8vIEFjdGl2YXRlIGRyb3Bkb3duIHBhcmVudHNcclxuICAgICAgaWYgKHRhcmdldC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9EUk9QRE9XTl9JVEVNKSkge1xyXG4gICAgICAgIFNlbGVjdG9yRW5naW5lLmZpbmRPbmUoU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFJDEsIHRhcmdldC5jbG9zZXN0KFNFTEVDVE9SX0RST1BET1dOKSkuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0FDVElWRSQxKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgZm9yIChjb25zdCBsaXN0R3JvdXAgb2YgU2VsZWN0b3JFbmdpbmUucGFyZW50cyh0YXJnZXQsIFNFTEVDVE9SX05BVl9MSVNUX0dST1VQKSkge1xyXG4gICAgICAgIC8vIFNldCB0cmlnZ2VyZWQgbGlua3MgcGFyZW50cyBhcyBhY3RpdmVcclxuICAgICAgICAvLyBXaXRoIGJvdGggPHVsPiBhbmQgPG5hdj4gbWFya3VwIGEgcGFyZW50IGlzIHRoZSBwcmV2aW91cyBzaWJsaW5nIG9mIGFueSBuYXYgYW5jZXN0b3JcclxuICAgICAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgU2VsZWN0b3JFbmdpbmUucHJldihsaXN0R3JvdXAsIFNFTEVDVE9SX0xJTktfSVRFTVMpKSB7XHJcbiAgICAgICAgICBpdGVtLmNsYXNzTGlzdC5hZGQoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfY2xlYXJBY3RpdmVDbGFzcyhwYXJlbnQpIHtcclxuICAgICAgcGFyZW50LmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XHJcbiAgICAgIGNvbnN0IGFjdGl2ZU5vZGVzID0gU2VsZWN0b3JFbmdpbmUuZmluZChgJHtTRUxFQ1RPUl9UQVJHRVRfTElOS1N9LiR7Q0xBU1NfTkFNRV9BQ1RJVkUkMX1gLCBwYXJlbnQpO1xyXG4gICAgICBmb3IgKGNvbnN0IG5vZGUgb2YgYWN0aXZlTm9kZXMpIHtcclxuICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoQ0xBU1NfTkFNRV9BQ1RJVkUkMSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGF0aWNcclxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBTY3JvbGxTcHkuZ2V0T3JDcmVhdGVJbnN0YW5jZSh0aGlzLCBjb25maWcpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXHJcbiAgICovXHJcblxyXG4gIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEkkMSwgKCkgPT4ge1xyXG4gICAgZm9yIChjb25zdCBzcHkgb2YgU2VsZWN0b3JFbmdpbmUuZmluZChTRUxFQ1RPUl9EQVRBX1NQWSkpIHtcclxuICAgICAgU2Nyb2xsU3B5LmdldE9yQ3JlYXRlSW5zdGFuY2Uoc3B5KTtcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgLyoqXHJcbiAgICogalF1ZXJ5XHJcbiAgICovXHJcblxyXG4gIGRlZmluZUpRdWVyeVBsdWdpbihTY3JvbGxTcHkpO1xyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCB0YWIuanNcclxuICAgKiBMaWNlbnNlZCB1bmRlciBNSVQgKGh0dHBzOi8vZ2l0aHViLmNvbS90d2JzL2Jvb3RzdHJhcC9ibG9iL21haW4vTElDRU5TRSlcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqL1xyXG5cclxuXHJcbiAgLyoqXHJcbiAgICogQ29uc3RhbnRzXHJcbiAgICovXHJcblxyXG4gIGNvbnN0IE5BTUUkMSA9ICd0YWInO1xyXG4gIGNvbnN0IERBVEFfS0VZJDEgPSAnYnMudGFiJztcclxuICBjb25zdCBFVkVOVF9LRVkkMSA9IGAuJHtEQVRBX0tFWSQxfWA7XHJcbiAgY29uc3QgRVZFTlRfSElERSQxID0gYGhpZGUke0VWRU5UX0tFWSQxfWA7XHJcbiAgY29uc3QgRVZFTlRfSElEREVOJDEgPSBgaGlkZGVuJHtFVkVOVF9LRVkkMX1gO1xyXG4gIGNvbnN0IEVWRU5UX1NIT1ckMSA9IGBzaG93JHtFVkVOVF9LRVkkMX1gO1xyXG4gIGNvbnN0IEVWRU5UX1NIT1dOJDEgPSBgc2hvd24ke0VWRU5UX0tFWSQxfWA7XHJcbiAgY29uc3QgRVZFTlRfQ0xJQ0tfREFUQV9BUEkgPSBgY2xpY2ske0VWRU5UX0tFWSQxfWA7XHJcbiAgY29uc3QgRVZFTlRfS0VZRE9XTiA9IGBrZXlkb3duJHtFVkVOVF9LRVkkMX1gO1xyXG4gIGNvbnN0IEVWRU5UX0xPQURfREFUQV9BUEkgPSBgbG9hZCR7RVZFTlRfS0VZJDF9YDtcclxuICBjb25zdCBBUlJPV19MRUZUX0tFWSA9ICdBcnJvd0xlZnQnO1xyXG4gIGNvbnN0IEFSUk9XX1JJR0hUX0tFWSA9ICdBcnJvd1JpZ2h0JztcclxuICBjb25zdCBBUlJPV19VUF9LRVkgPSAnQXJyb3dVcCc7XHJcbiAgY29uc3QgQVJST1dfRE9XTl9LRVkgPSAnQXJyb3dEb3duJztcclxuICBjb25zdCBIT01FX0tFWSA9ICdIb21lJztcclxuICBjb25zdCBFTkRfS0VZID0gJ0VuZCc7XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9BQ1RJVkUgPSAnYWN0aXZlJztcclxuICBjb25zdCBDTEFTU19OQU1FX0ZBREUkMSA9ICdmYWRlJztcclxuICBjb25zdCBDTEFTU19OQU1FX1NIT1ckMSA9ICdzaG93JztcclxuICBjb25zdCBDTEFTU19EUk9QRE9XTiA9ICdkcm9wZG93bic7XHJcbiAgY29uc3QgU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFID0gJy5kcm9wZG93bi10b2dnbGUnO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0RST1BET1dOX01FTlUgPSAnLmRyb3Bkb3duLW1lbnUnO1xyXG4gIGNvbnN0IE5PVF9TRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEUgPSBgOm5vdCgke1NFTEVDVE9SX0RST1BET1dOX1RPR0dMRX0pYDtcclxuICBjb25zdCBTRUxFQ1RPUl9UQUJfUEFORUwgPSAnLmxpc3QtZ3JvdXAsIC5uYXYsIFtyb2xlPVwidGFibGlzdFwiXSc7XHJcbiAgY29uc3QgU0VMRUNUT1JfT1VURVIgPSAnLm5hdi1pdGVtLCAubGlzdC1ncm91cC1pdGVtJztcclxuICBjb25zdCBTRUxFQ1RPUl9JTk5FUiA9IGAubmF2LWxpbmske05PVF9TRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEV9LCAubGlzdC1ncm91cC1pdGVtJHtOT1RfU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFfSwgW3JvbGU9XCJ0YWJcIl0ke05PVF9TRUxFQ1RPUl9EUk9QRE9XTl9UT0dHTEV9YDtcclxuICBjb25zdCBTRUxFQ1RPUl9EQVRBX1RPR0dMRSA9ICdbZGF0YS1icy10b2dnbGU9XCJ0YWJcIl0sIFtkYXRhLWJzLXRvZ2dsZT1cInBpbGxcIl0sIFtkYXRhLWJzLXRvZ2dsZT1cImxpc3RcIl0nOyAvLyBUT0RPOiBjb3VsZCBvbmx5IGJlIGB0YWJgIGluIHY2XHJcbiAgY29uc3QgU0VMRUNUT1JfSU5ORVJfRUxFTSA9IGAke1NFTEVDVE9SX0lOTkVSfSwgJHtTRUxFQ1RPUl9EQVRBX1RPR0dMRX1gO1xyXG4gIGNvbnN0IFNFTEVDVE9SX0RBVEFfVE9HR0xFX0FDVElWRSA9IGAuJHtDTEFTU19OQU1FX0FDVElWRX1bZGF0YS1icy10b2dnbGU9XCJ0YWJcIl0sIC4ke0NMQVNTX05BTUVfQUNUSVZFfVtkYXRhLWJzLXRvZ2dsZT1cInBpbGxcIl0sIC4ke0NMQVNTX05BTUVfQUNUSVZFfVtkYXRhLWJzLXRvZ2dsZT1cImxpc3RcIl1gO1xyXG5cclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIFRhYiBleHRlbmRzIEJhc2VDb21wb25lbnQge1xyXG4gICAgY29uc3RydWN0b3IoZWxlbWVudCkge1xyXG4gICAgICBzdXBlcihlbGVtZW50KTtcclxuICAgICAgdGhpcy5fcGFyZW50ID0gdGhpcy5fZWxlbWVudC5jbG9zZXN0KFNFTEVDVE9SX1RBQl9QQU5FTCk7XHJcbiAgICAgIGlmICghdGhpcy5fcGFyZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIC8vIFRPRE86IHNob3VsZCB0aHJvdyBleGNlcHRpb24gaW4gdjZcclxuICAgICAgICAvLyB0aHJvdyBuZXcgVHlwZUVycm9yKGAke2VsZW1lbnQub3V0ZXJIVE1MfSBoYXMgbm90IGEgdmFsaWQgcGFyZW50ICR7U0VMRUNUT1JfSU5ORVJfRUxFTX1gKVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTZXQgdXAgaW5pdGlhbCBhcmlhIGF0dHJpYnV0ZXNcclxuICAgICAgdGhpcy5fc2V0SW5pdGlhbEF0dHJpYnV0ZXModGhpcy5fcGFyZW50LCB0aGlzLl9nZXRDaGlsZHJlbigpKTtcclxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0tFWURPV04sIGV2ZW50ID0+IHRoaXMuX2tleWRvd24oZXZlbnQpKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXR0ZXJzXHJcbiAgICBzdGF0aWMgZ2V0IE5BTUUoKSB7XHJcbiAgICAgIHJldHVybiBOQU1FJDE7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHVibGljXHJcbiAgICBzaG93KCkge1xyXG4gICAgICAvLyBTaG93cyB0aGlzIGVsZW0gYW5kIGRlYWN0aXZhdGUgdGhlIGFjdGl2ZSBzaWJsaW5nIGlmIGV4aXN0c1xyXG4gICAgICBjb25zdCBpbm5lckVsZW0gPSB0aGlzLl9lbGVtZW50O1xyXG4gICAgICBpZiAodGhpcy5fZWxlbUlzQWN0aXZlKGlubmVyRWxlbSkpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNlYXJjaCBmb3IgYWN0aXZlIHRhYiBvbiBzYW1lIHBhcmVudCB0byBkZWFjdGl2YXRlIGl0XHJcbiAgICAgIGNvbnN0IGFjdGl2ZSA9IHRoaXMuX2dldEFjdGl2ZUVsZW0oKTtcclxuICAgICAgY29uc3QgaGlkZUV2ZW50ID0gYWN0aXZlID8gRXZlbnRIYW5kbGVyLnRyaWdnZXIoYWN0aXZlLCBFVkVOVF9ISURFJDEsIHtcclxuICAgICAgICByZWxhdGVkVGFyZ2V0OiBpbm5lckVsZW1cclxuICAgICAgfSkgOiBudWxsO1xyXG4gICAgICBjb25zdCBzaG93RXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcihpbm5lckVsZW0sIEVWRU5UX1NIT1ckMSwge1xyXG4gICAgICAgIHJlbGF0ZWRUYXJnZXQ6IGFjdGl2ZVxyXG4gICAgICB9KTtcclxuICAgICAgaWYgKHNob3dFdmVudC5kZWZhdWx0UHJldmVudGVkIHx8IGhpZGVFdmVudCAmJiBoaWRlRXZlbnQuZGVmYXVsdFByZXZlbnRlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9kZWFjdGl2YXRlKGFjdGl2ZSwgaW5uZXJFbGVtKTtcclxuICAgICAgdGhpcy5fYWN0aXZhdGUoaW5uZXJFbGVtLCBhY3RpdmUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByaXZhdGVcclxuICAgIF9hY3RpdmF0ZShlbGVtZW50LCByZWxhdGVkRWxlbSkge1xyXG4gICAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfQUNUSVZFKTtcclxuICAgICAgdGhpcy5fYWN0aXZhdGUoU2VsZWN0b3JFbmdpbmUuZ2V0RWxlbWVudEZyb21TZWxlY3RvcihlbGVtZW50KSk7IC8vIFNlYXJjaCBhbmQgYWN0aXZhdGUvc2hvdyB0aGUgcHJvcGVyIHNlY3Rpb25cclxuXHJcbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xyXG4gICAgICAgIGlmIChlbGVtZW50LmdldEF0dHJpYnV0ZSgncm9sZScpICE9PSAndGFiJykge1xyXG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPVyQxKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxlbWVudC5yZW1vdmVBdHRyaWJ1dGUoJ3RhYmluZGV4Jyk7XHJcbiAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2FyaWEtc2VsZWN0ZWQnLCB0cnVlKTtcclxuICAgICAgICB0aGlzLl90b2dnbGVEcm9wRG93bihlbGVtZW50LCB0cnVlKTtcclxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcihlbGVtZW50LCBFVkVOVF9TSE9XTiQxLCB7XHJcbiAgICAgICAgICByZWxhdGVkVGFyZ2V0OiByZWxhdGVkRWxlbVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9O1xyXG4gICAgICB0aGlzLl9xdWV1ZUNhbGxiYWNrKGNvbXBsZXRlLCBlbGVtZW50LCBlbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX0ZBREUkMSkpO1xyXG4gICAgfVxyXG4gICAgX2RlYWN0aXZhdGUoZWxlbWVudCwgcmVsYXRlZEVsZW0pIHtcclxuICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0FDVElWRSk7XHJcbiAgICAgIGVsZW1lbnQuYmx1cigpO1xyXG4gICAgICB0aGlzLl9kZWFjdGl2YXRlKFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IoZWxlbWVudCkpOyAvLyBTZWFyY2ggYW5kIGRlYWN0aXZhdGUgdGhlIHNob3duIHNlY3Rpb24gdG9vXHJcblxyXG4gICAgICBjb25zdCBjb21wbGV0ZSA9ICgpID0+IHtcclxuICAgICAgICBpZiAoZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3JvbGUnKSAhPT0gJ3RhYicpIHtcclxuICAgICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1ckMSk7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCdhcmlhLXNlbGVjdGVkJywgZmFsc2UpO1xyXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKCd0YWJpbmRleCcsICctMScpO1xyXG4gICAgICAgIHRoaXMuX3RvZ2dsZURyb3BEb3duKGVsZW1lbnQsIGZhbHNlKTtcclxuICAgICAgICBFdmVudEhhbmRsZXIudHJpZ2dlcihlbGVtZW50LCBFVkVOVF9ISURERU4kMSwge1xyXG4gICAgICAgICAgcmVsYXRlZFRhcmdldDogcmVsYXRlZEVsZW1cclxuICAgICAgICB9KTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5fcXVldWVDYWxsYmFjayhjb21wbGV0ZSwgZWxlbWVudCwgZWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoQ0xBU1NfTkFNRV9GQURFJDEpKTtcclxuICAgIH1cclxuICAgIF9rZXlkb3duKGV2ZW50KSB7XHJcbiAgICAgIGlmICghW0FSUk9XX0xFRlRfS0VZLCBBUlJPV19SSUdIVF9LRVksIEFSUk9XX1VQX0tFWSwgQVJST1dfRE9XTl9LRVksIEhPTUVfS0VZLCBFTkRfS0VZXS5pbmNsdWRlcyhldmVudC5rZXkpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOyAvLyBzdG9wUHJvcGFnYXRpb24vcHJldmVudERlZmF1bHQgYm90aCBhZGRlZCB0byBzdXBwb3J0IHVwL2Rvd24ga2V5cyB3aXRob3V0IHNjcm9sbGluZyB0aGUgcGFnZVxyXG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICBjb25zdCBjaGlsZHJlbiA9IHRoaXMuX2dldENoaWxkcmVuKCkuZmlsdGVyKGVsZW1lbnQgPT4gIWlzRGlzYWJsZWQoZWxlbWVudCkpO1xyXG4gICAgICBsZXQgbmV4dEFjdGl2ZUVsZW1lbnQ7XHJcbiAgICAgIGlmIChbSE9NRV9LRVksIEVORF9LRVldLmluY2x1ZGVzKGV2ZW50LmtleSkpIHtcclxuICAgICAgICBuZXh0QWN0aXZlRWxlbWVudCA9IGNoaWxkcmVuW2V2ZW50LmtleSA9PT0gSE9NRV9LRVkgPyAwIDogY2hpbGRyZW4ubGVuZ3RoIC0gMV07XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc3QgaXNOZXh0ID0gW0FSUk9XX1JJR0hUX0tFWSwgQVJST1dfRE9XTl9LRVldLmluY2x1ZGVzKGV2ZW50LmtleSk7XHJcbiAgICAgICAgbmV4dEFjdGl2ZUVsZW1lbnQgPSBnZXROZXh0QWN0aXZlRWxlbWVudChjaGlsZHJlbiwgZXZlbnQudGFyZ2V0LCBpc05leHQsIHRydWUpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmIChuZXh0QWN0aXZlRWxlbWVudCkge1xyXG4gICAgICAgIG5leHRBY3RpdmVFbGVtZW50LmZvY3VzKHtcclxuICAgICAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcclxuICAgICAgICB9KTtcclxuICAgICAgICBUYWIuZ2V0T3JDcmVhdGVJbnN0YW5jZShuZXh0QWN0aXZlRWxlbWVudCkuc2hvdygpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfZ2V0Q2hpbGRyZW4oKSB7XHJcbiAgICAgIC8vIGNvbGxlY3Rpb24gb2YgaW5uZXIgZWxlbWVudHNcclxuICAgICAgcmV0dXJuIFNlbGVjdG9yRW5naW5lLmZpbmQoU0VMRUNUT1JfSU5ORVJfRUxFTSwgdGhpcy5fcGFyZW50KTtcclxuICAgIH1cclxuICAgIF9nZXRBY3RpdmVFbGVtKCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5fZ2V0Q2hpbGRyZW4oKS5maW5kKGNoaWxkID0+IHRoaXMuX2VsZW1Jc0FjdGl2ZShjaGlsZCkpIHx8IG51bGw7XHJcbiAgICB9XHJcbiAgICBfc2V0SW5pdGlhbEF0dHJpYnV0ZXMocGFyZW50LCBjaGlsZHJlbikge1xyXG4gICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyhwYXJlbnQsICdyb2xlJywgJ3RhYmxpc3QnKTtcclxuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBjaGlsZHJlbikge1xyXG4gICAgICAgIHRoaXMuX3NldEluaXRpYWxBdHRyaWJ1dGVzT25DaGlsZChjaGlsZCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIF9zZXRJbml0aWFsQXR0cmlidXRlc09uQ2hpbGQoY2hpbGQpIHtcclxuICAgICAgY2hpbGQgPSB0aGlzLl9nZXRJbm5lckVsZW1lbnQoY2hpbGQpO1xyXG4gICAgICBjb25zdCBpc0FjdGl2ZSA9IHRoaXMuX2VsZW1Jc0FjdGl2ZShjaGlsZCk7XHJcbiAgICAgIGNvbnN0IG91dGVyRWxlbSA9IHRoaXMuX2dldE91dGVyRWxlbWVudChjaGlsZCk7XHJcbiAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZSgnYXJpYS1zZWxlY3RlZCcsIGlzQWN0aXZlKTtcclxuICAgICAgaWYgKG91dGVyRWxlbSAhPT0gY2hpbGQpIHtcclxuICAgICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyhvdXRlckVsZW0sICdyb2xlJywgJ3ByZXNlbnRhdGlvbicpO1xyXG4gICAgICB9XHJcbiAgICAgIGlmICghaXNBY3RpdmUpIHtcclxuICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgJy0xJyk7XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fc2V0QXR0cmlidXRlSWZOb3RFeGlzdHMoY2hpbGQsICdyb2xlJywgJ3RhYicpO1xyXG5cclxuICAgICAgLy8gc2V0IGF0dHJpYnV0ZXMgdG8gdGhlIHJlbGF0ZWQgcGFuZWwgdG9vXHJcbiAgICAgIHRoaXMuX3NldEluaXRpYWxBdHRyaWJ1dGVzT25UYXJnZXRQYW5lbChjaGlsZCk7XHJcbiAgICB9XHJcbiAgICBfc2V0SW5pdGlhbEF0dHJpYnV0ZXNPblRhcmdldFBhbmVsKGNoaWxkKSB7XHJcbiAgICAgIGNvbnN0IHRhcmdldCA9IFNlbGVjdG9yRW5naW5lLmdldEVsZW1lbnRGcm9tU2VsZWN0b3IoY2hpbGQpO1xyXG4gICAgICBpZiAoIXRhcmdldCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyh0YXJnZXQsICdyb2xlJywgJ3RhYnBhbmVsJyk7XHJcbiAgICAgIGlmIChjaGlsZC5pZCkge1xyXG4gICAgICAgIHRoaXMuX3NldEF0dHJpYnV0ZUlmTm90RXhpc3RzKHRhcmdldCwgJ2FyaWEtbGFiZWxsZWRieScsIGAke2NoaWxkLmlkfWApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfdG9nZ2xlRHJvcERvd24oZWxlbWVudCwgb3Blbikge1xyXG4gICAgICBjb25zdCBvdXRlckVsZW0gPSB0aGlzLl9nZXRPdXRlckVsZW1lbnQoZWxlbWVudCk7XHJcbiAgICAgIGlmICghb3V0ZXJFbGVtLmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19EUk9QRE9XTikpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgdG9nZ2xlID0gKHNlbGVjdG9yLCBjbGFzc05hbWUpID0+IHtcclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gU2VsZWN0b3JFbmdpbmUuZmluZE9uZShzZWxlY3Rvciwgb3V0ZXJFbGVtKTtcclxuICAgICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgZWxlbWVudC5jbGFzc0xpc3QudG9nZ2xlKGNsYXNzTmFtZSwgb3Blbik7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG4gICAgICB0b2dnbGUoU0VMRUNUT1JfRFJPUERPV05fVE9HR0xFLCBDTEFTU19OQU1FX0FDVElWRSk7XHJcbiAgICAgIHRvZ2dsZShTRUxFQ1RPUl9EUk9QRE9XTl9NRU5VLCBDTEFTU19OQU1FX1NIT1ckMSk7XHJcbiAgICAgIG91dGVyRWxlbS5zZXRBdHRyaWJ1dGUoJ2FyaWEtZXhwYW5kZWQnLCBvcGVuKTtcclxuICAgIH1cclxuICAgIF9zZXRBdHRyaWJ1dGVJZk5vdEV4aXN0cyhlbGVtZW50LCBhdHRyaWJ1dGUsIHZhbHVlKSB7XHJcbiAgICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlKSkge1xyXG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKGF0dHJpYnV0ZSwgdmFsdWUpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBfZWxlbUlzQWN0aXZlKGVsZW0pIHtcclxuICAgICAgcmV0dXJuIGVsZW0uY2xhc3NMaXN0LmNvbnRhaW5zKENMQVNTX05BTUVfQUNUSVZFKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBUcnkgdG8gZ2V0IHRoZSBpbm5lciBlbGVtZW50ICh1c3VhbGx5IHRoZSAubmF2LWxpbmspXHJcbiAgICBfZ2V0SW5uZXJFbGVtZW50KGVsZW0pIHtcclxuICAgICAgcmV0dXJuIGVsZW0ubWF0Y2hlcyhTRUxFQ1RPUl9JTk5FUl9FTEVNKSA/IGVsZW0gOiBTZWxlY3RvckVuZ2luZS5maW5kT25lKFNFTEVDVE9SX0lOTkVSX0VMRU0sIGVsZW0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRyeSB0byBnZXQgdGhlIG91dGVyIGVsZW1lbnQgKHVzdWFsbHkgdGhlIC5uYXYtaXRlbSlcclxuICAgIF9nZXRPdXRlckVsZW1lbnQoZWxlbSkge1xyXG4gICAgICByZXR1cm4gZWxlbS5jbG9zZXN0KFNFTEVDVE9SX09VVEVSKSB8fCBlbGVtO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFN0YXRpY1xyXG4gICAgc3RhdGljIGpRdWVyeUludGVyZmFjZShjb25maWcpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuZWFjaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgY29uc3QgZGF0YSA9IFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpO1xyXG4gICAgICAgIGlmICh0eXBlb2YgY29uZmlnICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZGF0YVtjb25maWddID09PSB1bmRlZmluZWQgfHwgY29uZmlnLnN0YXJ0c1dpdGgoJ18nKSB8fCBjb25maWcgPT09ICdjb25zdHJ1Y3RvcicpIHtcclxuICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYE5vIG1ldGhvZCBuYW1lZCBcIiR7Y29uZmlnfVwiYCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGRhdGFbY29uZmlnXSgpO1xyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERhdGEgQVBJIGltcGxlbWVudGF0aW9uXHJcbiAgICovXHJcblxyXG4gIEV2ZW50SGFuZGxlci5vbihkb2N1bWVudCwgRVZFTlRfQ0xJQ0tfREFUQV9BUEksIFNFTEVDVE9SX0RBVEFfVE9HR0xFLCBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgIGlmIChbJ0EnLCAnQVJFQSddLmluY2x1ZGVzKHRoaXMudGFnTmFtZSkpIHtcclxuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcclxuICAgIH1cclxuICAgIGlmIChpc0Rpc2FibGVkKHRoaXMpKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuICAgIFRhYi5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMpLnNob3coKTtcclxuICB9KTtcclxuXHJcbiAgLyoqXHJcbiAgICogSW5pdGlhbGl6ZSBvbiBmb2N1c1xyXG4gICAqL1xyXG4gIEV2ZW50SGFuZGxlci5vbih3aW5kb3csIEVWRU5UX0xPQURfREFUQV9BUEksICgpID0+IHtcclxuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBTZWxlY3RvckVuZ2luZS5maW5kKFNFTEVDVE9SX0RBVEFfVE9HR0xFX0FDVElWRSkpIHtcclxuICAgICAgVGFiLmdldE9yQ3JlYXRlSW5zdGFuY2UoZWxlbWVudCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcbiAgLyoqXHJcbiAgICogalF1ZXJ5XHJcbiAgICovXHJcblxyXG4gIGRlZmluZUpRdWVyeVBsdWdpbihUYWIpO1xyXG5cclxuICAvKipcclxuICAgKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxyXG4gICAqIEJvb3RzdHJhcCB0b2FzdC5qc1xyXG4gICAqIExpY2Vuc2VkIHVuZGVyIE1JVCAoaHR0cHM6Ly9naXRodWIuY29tL3R3YnMvYm9vdHN0cmFwL2Jsb2IvbWFpbi9MSUNFTlNFKVxyXG4gICAqIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXHJcbiAgICovXHJcblxyXG5cclxuICAvKipcclxuICAgKiBDb25zdGFudHNcclxuICAgKi9cclxuXHJcbiAgY29uc3QgTkFNRSA9ICd0b2FzdCc7XHJcbiAgY29uc3QgREFUQV9LRVkgPSAnYnMudG9hc3QnO1xyXG4gIGNvbnN0IEVWRU5UX0tFWSA9IGAuJHtEQVRBX0tFWX1gO1xyXG4gIGNvbnN0IEVWRU5UX01PVVNFT1ZFUiA9IGBtb3VzZW92ZXIke0VWRU5UX0tFWX1gO1xyXG4gIGNvbnN0IEVWRU5UX01PVVNFT1VUID0gYG1vdXNlb3V0JHtFVkVOVF9LRVl9YDtcclxuICBjb25zdCBFVkVOVF9GT0NVU0lOID0gYGZvY3VzaW4ke0VWRU5UX0tFWX1gO1xyXG4gIGNvbnN0IEVWRU5UX0ZPQ1VTT1VUID0gYGZvY3Vzb3V0JHtFVkVOVF9LRVl9YDtcclxuICBjb25zdCBFVkVOVF9ISURFID0gYGhpZGUke0VWRU5UX0tFWX1gO1xyXG4gIGNvbnN0IEVWRU5UX0hJRERFTiA9IGBoaWRkZW4ke0VWRU5UX0tFWX1gO1xyXG4gIGNvbnN0IEVWRU5UX1NIT1cgPSBgc2hvdyR7RVZFTlRfS0VZfWA7XHJcbiAgY29uc3QgRVZFTlRfU0hPV04gPSBgc2hvd24ke0VWRU5UX0tFWX1gO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfRkFERSA9ICdmYWRlJztcclxuICBjb25zdCBDTEFTU19OQU1FX0hJREUgPSAnaGlkZSc7IC8vIEBkZXByZWNhdGVkIC0ga2VwdCBoZXJlIG9ubHkgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5XHJcbiAgY29uc3QgQ0xBU1NfTkFNRV9TSE9XID0gJ3Nob3cnO1xyXG4gIGNvbnN0IENMQVNTX05BTUVfU0hPV0lORyA9ICdzaG93aW5nJztcclxuICBjb25zdCBEZWZhdWx0VHlwZSA9IHtcclxuICAgIGFuaW1hdGlvbjogJ2Jvb2xlYW4nLFxyXG4gICAgYXV0b2hpZGU6ICdib29sZWFuJyxcclxuICAgIGRlbGF5OiAnbnVtYmVyJ1xyXG4gIH07XHJcbiAgY29uc3QgRGVmYXVsdCA9IHtcclxuICAgIGFuaW1hdGlvbjogdHJ1ZSxcclxuICAgIGF1dG9oaWRlOiB0cnVlLFxyXG4gICAgZGVsYXk6IDUwMDBcclxuICB9O1xyXG5cclxuICAvKipcclxuICAgKiBDbGFzcyBkZWZpbml0aW9uXHJcbiAgICovXHJcblxyXG4gIGNsYXNzIFRvYXN0IGV4dGVuZHMgQmFzZUNvbXBvbmVudCB7XHJcbiAgICBjb25zdHJ1Y3RvcihlbGVtZW50LCBjb25maWcpIHtcclxuICAgICAgc3VwZXIoZWxlbWVudCwgY29uZmlnKTtcclxuICAgICAgdGhpcy5fdGltZW91dCA9IG51bGw7XHJcbiAgICAgIHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gPSBmYWxzZTtcclxuICAgICAgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiA9IGZhbHNlO1xyXG4gICAgICB0aGlzLl9zZXRMaXN0ZW5lcnMoKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBHZXR0ZXJzXHJcbiAgICBzdGF0aWMgZ2V0IERlZmF1bHQoKSB7XHJcbiAgICAgIHJldHVybiBEZWZhdWx0O1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBEZWZhdWx0VHlwZSgpIHtcclxuICAgICAgcmV0dXJuIERlZmF1bHRUeXBlO1xyXG4gICAgfVxyXG4gICAgc3RhdGljIGdldCBOQU1FKCkge1xyXG4gICAgICByZXR1cm4gTkFNRTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQdWJsaWNcclxuICAgIHNob3coKSB7XHJcbiAgICAgIGNvbnN0IHNob3dFdmVudCA9IEV2ZW50SGFuZGxlci50cmlnZ2VyKHRoaXMuX2VsZW1lbnQsIEVWRU5UX1NIT1cpO1xyXG4gICAgICBpZiAoc2hvd0V2ZW50LmRlZmF1bHRQcmV2ZW50ZWQpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XHJcbiAgICAgIGlmICh0aGlzLl9jb25maWcuYW5pbWF0aW9uKSB7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfRkFERSk7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgY29tcGxldGUgPSAoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QucmVtb3ZlKENMQVNTX05BTUVfU0hPV0lORyk7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfU0hPV04pO1xyXG4gICAgICAgIHRoaXMuX21heWJlU2NoZWR1bGVIaWRlKCk7XHJcbiAgICAgIH07XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX0hJREUpOyAvLyBAZGVwcmVjYXRlZFxyXG4gICAgICByZWZsb3codGhpcy5fZWxlbWVudCk7XHJcbiAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX1NIT1csIENMQVNTX05BTUVfU0hPV0lORyk7XHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pO1xyXG4gICAgfVxyXG4gICAgaGlkZSgpIHtcclxuICAgICAgaWYgKCF0aGlzLmlzU2hvd24oKSkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICBjb25zdCBoaWRlRXZlbnQgPSBFdmVudEhhbmRsZXIudHJpZ2dlcih0aGlzLl9lbGVtZW50LCBFVkVOVF9ISURFKTtcclxuICAgICAgaWYgKGhpZGVFdmVudC5kZWZhdWx0UHJldmVudGVkKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IGNvbXBsZXRlID0gKCkgPT4ge1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LmFkZChDTEFTU19OQU1FX0hJREUpOyAvLyBAZGVwcmVjYXRlZFxyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1dJTkcsIENMQVNTX05BTUVfU0hPVyk7XHJcbiAgICAgICAgRXZlbnRIYW5kbGVyLnRyaWdnZXIodGhpcy5fZWxlbWVudCwgRVZFTlRfSElEREVOKTtcclxuICAgICAgfTtcclxuICAgICAgdGhpcy5fZWxlbWVudC5jbGFzc0xpc3QuYWRkKENMQVNTX05BTUVfU0hPV0lORyk7XHJcbiAgICAgIHRoaXMuX3F1ZXVlQ2FsbGJhY2soY29tcGxldGUsIHRoaXMuX2VsZW1lbnQsIHRoaXMuX2NvbmZpZy5hbmltYXRpb24pO1xyXG4gICAgfVxyXG4gICAgZGlzcG9zZSgpIHtcclxuICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XHJcbiAgICAgIGlmICh0aGlzLmlzU2hvd24oKSkge1xyXG4gICAgICAgIHRoaXMuX2VsZW1lbnQuY2xhc3NMaXN0LnJlbW92ZShDTEFTU19OQU1FX1NIT1cpO1xyXG4gICAgICB9XHJcbiAgICAgIHN1cGVyLmRpc3Bvc2UoKTtcclxuICAgIH1cclxuICAgIGlzU2hvd24oKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9lbGVtZW50LmNsYXNzTGlzdC5jb250YWlucyhDTEFTU19OQU1FX1NIT1cpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFByaXZhdGVcclxuICAgIF9tYXliZVNjaGVkdWxlSGlkZSgpIHtcclxuICAgICAgaWYgKCF0aGlzLl9jb25maWcuYXV0b2hpZGUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuICAgICAgaWYgKHRoaXMuX2hhc01vdXNlSW50ZXJhY3Rpb24gfHwgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbikge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG4gICAgICB0aGlzLl90aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XHJcbiAgICAgICAgdGhpcy5oaWRlKCk7XHJcbiAgICAgIH0sIHRoaXMuX2NvbmZpZy5kZWxheSk7XHJcbiAgICB9XHJcbiAgICBfb25JbnRlcmFjdGlvbihldmVudCwgaXNJbnRlcmFjdGluZykge1xyXG4gICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcclxuICAgICAgICBjYXNlICdtb3VzZW92ZXInOlxyXG4gICAgICAgIGNhc2UgJ21vdXNlb3V0JzpcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5faGFzTW91c2VJbnRlcmFjdGlvbiA9IGlzSW50ZXJhY3Rpbmc7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIGNhc2UgJ2ZvY3VzaW4nOlxyXG4gICAgICAgIGNhc2UgJ2ZvY3Vzb3V0JzpcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgdGhpcy5faGFzS2V5Ym9hcmRJbnRlcmFjdGlvbiA9IGlzSW50ZXJhY3Rpbmc7XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIGlmIChpc0ludGVyYWN0aW5nKSB7XHJcbiAgICAgICAgdGhpcy5fY2xlYXJUaW1lb3V0KCk7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIGNvbnN0IG5leHRFbGVtZW50ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcclxuICAgICAgaWYgKHRoaXMuX2VsZW1lbnQgPT09IG5leHRFbGVtZW50IHx8IHRoaXMuX2VsZW1lbnQuY29udGFpbnMobmV4dEVsZW1lbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuX21heWJlU2NoZWR1bGVIaWRlKCk7XHJcbiAgICB9XHJcbiAgICBfc2V0TGlzdGVuZXJzKCkge1xyXG4gICAgICBFdmVudEhhbmRsZXIub24odGhpcy5fZWxlbWVudCwgRVZFTlRfTU9VU0VPVkVSLCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCB0cnVlKSk7XHJcbiAgICAgIEV2ZW50SGFuZGxlci5vbih0aGlzLl9lbGVtZW50LCBFVkVOVF9NT1VTRU9VVCwgZXZlbnQgPT4gdGhpcy5fb25JbnRlcmFjdGlvbihldmVudCwgZmFsc2UpKTtcclxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0ZPQ1VTSU4sIGV2ZW50ID0+IHRoaXMuX29uSW50ZXJhY3Rpb24oZXZlbnQsIHRydWUpKTtcclxuICAgICAgRXZlbnRIYW5kbGVyLm9uKHRoaXMuX2VsZW1lbnQsIEVWRU5UX0ZPQ1VTT1VULCBldmVudCA9PiB0aGlzLl9vbkludGVyYWN0aW9uKGV2ZW50LCBmYWxzZSkpO1xyXG4gICAgfVxyXG4gICAgX2NsZWFyVGltZW91dCgpIHtcclxuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuX3RpbWVvdXQpO1xyXG4gICAgICB0aGlzLl90aW1lb3V0ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBTdGF0aWNcclxuICAgIHN0YXRpYyBqUXVlcnlJbnRlcmZhY2UoY29uZmlnKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLmVhY2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGNvbnN0IGRhdGEgPSBUb2FzdC5nZXRPckNyZWF0ZUluc3RhbmNlKHRoaXMsIGNvbmZpZyk7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGRhdGFbY29uZmlnXSA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgTm8gbWV0aG9kIG5hbWVkIFwiJHtjb25maWd9XCJgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGRhdGFbY29uZmlnXSh0aGlzKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGF0YSBBUEkgaW1wbGVtZW50YXRpb25cclxuICAgKi9cclxuXHJcbiAgZW5hYmxlRGlzbWlzc1RyaWdnZXIoVG9hc3QpO1xyXG5cclxuICAvKipcclxuICAgKiBqUXVlcnlcclxuICAgKi9cclxuXHJcbiAgZGVmaW5lSlF1ZXJ5UGx1Z2luKFRvYXN0KTtcclxuXHJcbiAgLyoqXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKiBCb290c3RyYXAgaW5kZXgudW1kLmpzXHJcbiAgICogTGljZW5zZWQgdW5kZXIgTUlUIChodHRwczovL2dpdGh1Yi5jb20vdHdicy9ib290c3RyYXAvYmxvYi9tYWluL0xJQ0VOU0UpXHJcbiAgICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1cclxuICAgKi9cclxuXHJcbiAgY29uc3QgaW5kZXhfdW1kID0ge1xyXG4gICAgQWxlcnQsXHJcbiAgICBCdXR0b24sXHJcbiAgICBDYXJvdXNlbCxcclxuICAgIENvbGxhcHNlLFxyXG4gICAgRHJvcGRvd24sXHJcbiAgICBNb2RhbCxcclxuICAgIE9mZmNhbnZhcyxcclxuICAgIFBvcG92ZXIsXHJcbiAgICBTY3JvbGxTcHksXHJcbiAgICBUYWIsXHJcbiAgICBUb2FzdCxcclxuICAgIFRvb2x0aXBcclxuICB9O1xyXG5cclxuICByZXR1cm4gaW5kZXhfdW1kO1xyXG5cclxufSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib290c3RyYXAuYnVuZGxlLmpzLm1hcFxyXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/bootstrap/dist/js/bootstrap.bundle.js\n\n}");

/***/ }),

/***/ "./resources/js/app.js":
/*!*****************************!*\
  !*** ./resources/js/app.js ***!
  \*****************************/
/***/ ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {

eval("{// Import Bootstrap JS (use CommonJS require to avoid Babel 'sourceType: module' parse error)\nvar bootstrap = __webpack_require__(/*! bootstrap/dist/js/bootstrap.bundle */ \"./node_modules/bootstrap/dist/js/bootstrap.bundle.js\");\n\n// Main JS entry for Uma Musume Race Planner (MYDS compliant)\nconsole.log('Uma Musume Planner JS loaded');\n\n// MYDS Accessibility: Focus ring for keyboard navigation\ndocument.addEventListener('keydown', function (e) {\n  if (e.key === 'Tab') {\n    document.body.classList.add('user-is-tabbing');\n  }\n});\ndocument.addEventListener('mousedown', function () {\n  document.body.classList.remove('user-is-tabbing');\n});\n\n// MYDS: Skip to content link\nvar skipLink = document.createElement('a');\nskipLink.href = '#main-content';\nskipLink.className = 'skip-link';\nskipLink.textContent = 'Skip to main content';\nskipLink.setAttribute('aria-label', 'Skip to main content');\ndocument.body.prepend(skipLink);\n\n// Initialize Bootstrap components\ndocument.addEventListener('DOMContentLoaded', function () {\n  // Initialize all tooltips\n  var tooltipTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=\"tooltip\"]'));\n  tooltipTriggerList.map(function (tooltipTriggerEl) {\n    return new bootstrap.Tooltip(tooltipTriggerEl);\n  });\n\n  // Initialize all popovers\n  var popoverTriggerList = [].slice.call(document.querySelectorAll('[data-bs-toggle=\"popover\"]'));\n  popoverTriggerList.map(function (popoverTriggerEl) {\n    return new bootstrap.Popover(popoverTriggerEl);\n  });\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvanMvYXBwLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0EsSUFBTUEsU0FBUyxHQUFHQyxtQkFBTyxDQUFDLGdHQUFvQyxDQUFDOztBQUUvRDtBQUNBQyxPQUFPLENBQUNDLEdBQUcsQ0FBQyw4QkFBOEIsQ0FBQzs7QUFFM0M7QUFDQUMsUUFBUSxDQUFDQyxnQkFBZ0IsQ0FBQyxTQUFTLEVBQUUsVUFBU0MsQ0FBQyxFQUFFO0VBQ2hELElBQUlBLENBQUMsQ0FBQ0MsR0FBRyxLQUFLLEtBQUssRUFBRTtJQUNwQkgsUUFBUSxDQUFDSSxJQUFJLENBQUNDLFNBQVMsQ0FBQ0MsR0FBRyxDQUFDLGlCQUFpQixDQUFDO0VBQy9DO0FBQ0QsQ0FBQyxDQUFDO0FBQ0ZOLFFBQVEsQ0FBQ0MsZ0JBQWdCLENBQUMsV0FBVyxFQUFFLFlBQVc7RUFDakRELFFBQVEsQ0FBQ0ksSUFBSSxDQUFDQyxTQUFTLENBQUNFLE1BQU0sQ0FBQyxpQkFBaUIsQ0FBQztBQUNsRCxDQUFDLENBQUM7O0FBRUY7QUFDQSxJQUFNQyxRQUFRLEdBQUdSLFFBQVEsQ0FBQ1MsYUFBYSxDQUFDLEdBQUcsQ0FBQztBQUM1Q0QsUUFBUSxDQUFDRSxJQUFJLEdBQUcsZUFBZTtBQUMvQkYsUUFBUSxDQUFDRyxTQUFTLEdBQUcsV0FBVztBQUNoQ0gsUUFBUSxDQUFDSSxXQUFXLEdBQUcsc0JBQXNCO0FBQzdDSixRQUFRLENBQUNLLFlBQVksQ0FBQyxZQUFZLEVBQUUsc0JBQXNCLENBQUM7QUFDM0RiLFFBQVEsQ0FBQ0ksSUFBSSxDQUFDVSxPQUFPLENBQUNOLFFBQVEsQ0FBQzs7QUFFL0I7QUFDQVIsUUFBUSxDQUFDQyxnQkFBZ0IsQ0FBQyxrQkFBa0IsRUFBRSxZQUFXO0VBQ3JEO0VBQ0EsSUFBSWMsa0JBQWtCLEdBQUcsRUFBRSxDQUFDQyxLQUFLLENBQUNDLElBQUksQ0FBQ2pCLFFBQVEsQ0FBQ2tCLGdCQUFnQixDQUFDLDRCQUE0QixDQUFDLENBQUM7RUFDL0ZILGtCQUFrQixDQUFDSSxHQUFHLENBQUMsVUFBVUMsZ0JBQWdCLEVBQUU7SUFDL0MsT0FBTyxJQUFJeEIsU0FBUyxDQUFDeUIsT0FBTyxDQUFDRCxnQkFBZ0IsQ0FBQztFQUNsRCxDQUFDLENBQUM7O0VBRUY7RUFDQSxJQUFJRSxrQkFBa0IsR0FBRyxFQUFFLENBQUNOLEtBQUssQ0FBQ0MsSUFBSSxDQUFDakIsUUFBUSxDQUFDa0IsZ0JBQWdCLENBQUMsNEJBQTRCLENBQUMsQ0FBQztFQUMvRkksa0JBQWtCLENBQUNILEdBQUcsQ0FBQyxVQUFVSSxnQkFBZ0IsRUFBRTtJQUMvQyxPQUFPLElBQUkzQixTQUFTLENBQUM0QixPQUFPLENBQUNELGdCQUFnQixDQUFDO0VBQ2xELENBQUMsQ0FBQztBQUNOLENBQUMsQ0FBQyIsInNvdXJjZXMiOlsid2VicGFjazovL3VtYW11c3VtZS10cmFja2VyLWFwcC8uL3Jlc291cmNlcy9qcy9hcHAuanM/Y2VkNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBJbXBvcnQgQm9vdHN0cmFwIEpTICh1c2UgQ29tbW9uSlMgcmVxdWlyZSB0byBhdm9pZCBCYWJlbCAnc291cmNlVHlwZTogbW9kdWxlJyBwYXJzZSBlcnJvcilcclxuY29uc3QgYm9vdHN0cmFwID0gcmVxdWlyZSgnYm9vdHN0cmFwL2Rpc3QvanMvYm9vdHN0cmFwLmJ1bmRsZScpO1xyXG5cclxuLy8gTWFpbiBKUyBlbnRyeSBmb3IgVW1hIE11c3VtZSBSYWNlIFBsYW5uZXIgKE1ZRFMgY29tcGxpYW50KVxyXG5jb25zb2xlLmxvZygnVW1hIE11c3VtZSBQbGFubmVyIEpTIGxvYWRlZCcpO1xyXG5cclxuLy8gTVlEUyBBY2Nlc3NpYmlsaXR5OiBGb2N1cyByaW5nIGZvciBrZXlib2FyZCBuYXZpZ2F0aW9uXHJcbmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBmdW5jdGlvbihlKSB7XHJcblx0aWYgKGUua2V5ID09PSAnVGFiJykge1xyXG5cdFx0ZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCd1c2VyLWlzLXRhYmJpbmcnKTtcclxuXHR9XHJcbn0pO1xyXG5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWRvd24nLCBmdW5jdGlvbigpIHtcclxuXHRkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ3VzZXItaXMtdGFiYmluZycpO1xyXG59KTtcclxuXHJcbi8vIE1ZRFM6IFNraXAgdG8gY29udGVudCBsaW5rXHJcbmNvbnN0IHNraXBMaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnYScpO1xyXG5za2lwTGluay5ocmVmID0gJyNtYWluLWNvbnRlbnQnO1xyXG5za2lwTGluay5jbGFzc05hbWUgPSAnc2tpcC1saW5rJztcclxuc2tpcExpbmsudGV4dENvbnRlbnQgPSAnU2tpcCB0byBtYWluIGNvbnRlbnQnO1xyXG5za2lwTGluay5zZXRBdHRyaWJ1dGUoJ2FyaWEtbGFiZWwnLCAnU2tpcCB0byBtYWluIGNvbnRlbnQnKTtcclxuZG9jdW1lbnQuYm9keS5wcmVwZW5kKHNraXBMaW5rKTtcclxuXHJcbi8vIEluaXRpYWxpemUgQm9vdHN0cmFwIGNvbXBvbmVudHNcclxuZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uKCkge1xyXG4gICAgLy8gSW5pdGlhbGl6ZSBhbGwgdG9vbHRpcHNcclxuICAgIHZhciB0b29sdGlwVHJpZ2dlckxpc3QgPSBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ1tkYXRhLWJzLXRvZ2dsZT1cInRvb2x0aXBcIl0nKSk7XHJcbiAgICB0b29sdGlwVHJpZ2dlckxpc3QubWFwKGZ1bmN0aW9uICh0b29sdGlwVHJpZ2dlckVsKSB7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBib290c3RyYXAuVG9vbHRpcCh0b29sdGlwVHJpZ2dlckVsKTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEluaXRpYWxpemUgYWxsIHBvcG92ZXJzXHJcbiAgICB2YXIgcG9wb3ZlclRyaWdnZXJMaXN0ID0gW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCdbZGF0YS1icy10b2dnbGU9XCJwb3BvdmVyXCJdJykpO1xyXG4gICAgcG9wb3ZlclRyaWdnZXJMaXN0Lm1hcChmdW5jdGlvbiAocG9wb3ZlclRyaWdnZXJFbCkge1xyXG4gICAgICAgIHJldHVybiBuZXcgYm9vdHN0cmFwLlBvcG92ZXIocG9wb3ZlclRyaWdnZXJFbCk7XHJcbiAgICB9KTtcclxufSk7XHJcbiJdLCJuYW1lcyI6WyJib290c3RyYXAiLCJyZXF1aXJlIiwiY29uc29sZSIsImxvZyIsImRvY3VtZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImUiLCJrZXkiLCJib2R5IiwiY2xhc3NMaXN0IiwiYWRkIiwicmVtb3ZlIiwic2tpcExpbmsiLCJjcmVhdGVFbGVtZW50IiwiaHJlZiIsImNsYXNzTmFtZSIsInRleHRDb250ZW50Iiwic2V0QXR0cmlidXRlIiwicHJlcGVuZCIsInRvb2x0aXBUcmlnZ2VyTGlzdCIsInNsaWNlIiwiY2FsbCIsInF1ZXJ5U2VsZWN0b3JBbGwiLCJtYXAiLCJ0b29sdGlwVHJpZ2dlckVsIiwiVG9vbHRpcCIsInBvcG92ZXJUcmlnZ2VyTGlzdCIsInBvcG92ZXJUcmlnZ2VyRWwiLCJQb3BvdmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/js/app.js\n\n}");

/***/ }),

/***/ "./resources/sass/app.scss":
/*!*********************************!*\
  !*** ./resources/sass/app.scss ***!
  \*********************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
eval("{__webpack_require__.r(__webpack_exports__);\n// extracted by mini-css-extract-plugin\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZXNvdXJjZXMvc2Fzcy9hcHAuc2NzcyIsIm1hcHBpbmdzIjoiO0FBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly91bWFtdXN1bWUtdHJhY2tlci1hcHAvLi9yZXNvdXJjZXMvc2Fzcy9hcHAuc2Nzcz9hOTdiIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIGV4dHJhY3RlZCBieSBtaW5pLWNzcy1leHRyYWN0LXBsdWdpblxuZXhwb3J0IHt9OyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./resources/sass/app.scss\n\n}");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"/js/app": 0,
/******/ 			"css/app": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkumamusume_tracker_app"] = self["webpackChunkumamusume_tracker_app"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	__webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/js/app.js")))
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, ["css/app"], () => (__webpack_require__("./resources/sass/app.scss")))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;